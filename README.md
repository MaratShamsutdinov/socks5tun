Хорошо, я подготовлю `README.md`, описывающий проект как кросс-платформенный WSS-туннель с HTTP CONNECT-мостом для обхода блокировок, с упором на серверную и клиентскую части, установку, логирование и Cloudflare. Скоро всё будет готово.

# socks5tun – SOCKS5 через WSS для обхода блокировок

**socks5tun** – это прокси-сервер SOCKS5, позволяющий туннелировать трафик через WebSocket Secure (WSS) соединение, маскируя его под обычный веб-трафик. Проект нацелен на обход сетевых ограничений и цензуры (DPI), выступая в роли портативного VPN: вы можете проксировать как HTTP(S) запросы, так и произвольный TCP/UDP трафик через удалённый сервер, замаскированный под защищённое веб-соединение (например, через Cloudflare).

## Возможности и особенности

- **SOCKS5-прокси с поддержкой TCP и UDP:** Обрабатывает команды CONNECT (TCP) и UDP ASSOCIATE (UDP) протокола SOCKS5. Это позволяет проксировать как обычные TCP-соединения (HTTP, TLS и т.д.), так и DNS-запросы и другой UDP-трафик.
- **Туннелирование в WebSocket (WSS):** Трафик SOCKS5 инкапсулируется в WebSocket, что позволяет передавать его через порты 80/443. В сочетании с Cloudflare это делает прокси **незаметным для DPI**, так как снаружи трафик выглядит как обычное HTTPS/WebSocket-соединение к облачному домену.
- **Интеграция с TUN-интерфейсом (режим VPN):** На сервере поддерживается создание виртуального TUN-интерфейса и NAT, благодаря чему прокси может выступать шлюзом в Интернет подобно VPN. Можно направлять клиентский трафик на сетевой интерфейс (через утилиты _tun2socks_ на стороне клиента), чтобы туннелировать весь поток данных через SOCKS5 (этот режим опционален).
- **Безопасность и фильтрация:** Поддерживается **аутентификация** SOCKS5 (логин/пароль) и списки доступа: можно ограничить диапазоны IP клиентов (`allowed_clients`), а также блокировать или разрешать определённые назначения (`blocked_destinations`, `deny_rules` и `allow_rules`). По умолчанию в конфигурации блокируются локальные подсети (RFC1918, localhost и пр.), чтобы предотвратить доступ к внутренним ресурсам сервера.
- **Логирование и диагностика:** Ведётся подробный лог работы сервера (через `journalctl` или stdout). В логе отображаются подключения клиентов (с указанием, локальное оно или внешнее), разрешённые и запрещённые запросы, DNS-ошибки, и прочие события, что упрощает отладку. Имеются скрипты для health-check мониторинга доступности прокси.
- **Автозапуск и обновление:** Предусмотрены unit-файлы **systemd** для автоматического запуска сервиса при загрузке системы, а также опциональный сервис для обновления сервера. Например, можно настроить таймер health-check, который перезапустит сервис в случае сбоев.

## Схема работы

Основные компоненты системы и поток данных от браузера до Интернета выглядят следующим образом:

```
Браузер → HTTP CONNECT прокси 127.0.0.1:3128
  → connect2socks.exe → SOCKS5 локальный 127.0.0.1:1194
    → wsclient.exe → WSS (через Cloudflare) → Nginx (сервер)
      → ws-bridge (websocat) → socks5tun (серверный SOCKS5) → Интернет
```

- **Браузер/приложение пользователя** отправляет запросы на локальный HTTP-прокси `127.0.0.1:3128`. Например, в системных настройках прокси прописывается `http://127.0.0.1:3128`.
- **connect2socks.exe** – утилита на стороне клиента, которая прослушивает порт 3128 как HTTP CONNECT прокси. Она принимает запросы CONNECT от браузера и перенаправляет их в SOCKS5-протокол на локальный адрес `127.0.0.1:1194`.
- **wsclient.exe** – утилита-клиент, поднимающая локальный SOCKS5-туннель. Она прослушивает порт `127.0.0.1:1194` (куда connect2socks отправляет SOCKS-запросы) и устанавливает защищённое **WSS**-соединение к удалённому серверу (через Cloudflare). Все данные SOCKS5 инкапсулируются в этом WebSocket-туннеле.
- **Cloudflare** проксирует WSS-соединение: с точки зрения цензуры трафик выглядит как обычный HTTPS-трафик к вашему домену (например, `wss://yourdomain.com/...`). Cloudflare принимает зашифрованное соединение от клиента и направляет его на ваш сервер.
- **Nginx** на сервере принимает соединение от Cloudflare (например, на порту 80 или 443) и выполняет **Upgrade** до WebSocket, проксируя его на локальный адрес (внутри сервера).
- **ws-bridge** – служба на сервере, реализующая мост между WebSocket и TCP. В данном проекте используется утилита [`websocat`](https://github.com/vi/websocat) как мост: она слушает локальный порт (например, `127.0.0.1:5001`) по протоколу WS и перенаправляет все сообщения в TCP-соединение с SOCKS5-сервером (локальный `127.0.0.1:5000`). Таким образом, входящий WSS-трафик через Nginx попадает в локальный websocat, который «разворачивает» его обратно в обычный TCP-поток для SOCKS5-сервера.
- **socks5tun (сервер)** – Python-приложение (данный репозиторий), запущенное на сервере. Оно слушает TCP-порт (по умолчанию `5000`) и ожидает входящих SOCKS5-соединений. После установления туннеля, socks5tun обрабатывает SOCKS5-запросы: открывает исходящие соединения к целевым сайтам, пересылает данные туда-обратно. В случае UDP ASSOCIATE, сервер либо напрямую пересылает UDP-пакеты, либо (в режиме TUN) инкапсулирует их в системный TUN-интерфейс и осуществляет маршрутизацию/NAT средствами ОС.

## Установка и настройка сервера

Далее рассматривается настройка сервера (Linux) с Python-приложением **socks5tun**. Предполагается, что у вас уже есть **доменный адрес, настроенный через Cloudflare** для проксирования веб-трафика, и вы имеете права root на вашем сервере.

### Требования

- **ОС:** Linux (например, Ubuntu 22.04+). Для работы TUN-интерфейса требуется права superuser (CAP_NET_ADMIN).
- **Python:** версия 3.8 или выше. Рекомендуется настроить отдельное виртуальное окружение.
- **Доп. ПО:** Git, `pip` (Python package installer), а также **Nginx** для приема WSS, **websocat** для WS–TCP моста.
- **Библиотеки Python:** они указаны в `requirements.txt`. Основные зависимости – `psutil` (для работы с соединениями), `pyroute2` (для некоторых сетевых функций, IPv6 NAT), `pytest` (для тестов, не обязателен в продакшене). Установить зависимости можно через pip.

### Шаг 1: Клонирование репозитория и установка

Склонируйте репозиторий к себе на сервер и установите пакет:

```bash
# Клонируем исходники
git clone https://github.com/yourname/socks5tun.git
cd socks5tun

# (Опционально) создаём и активируем виртуальное окружение
python3 -m venv venv
source venv/bin/activate

# Устанавливаем зависимости
pip install -r requirements.txt

# Устанавливаем пакет (установит как модуль socks5tun)
pip install .
```

Альтернативный вариант без установки пакета – запускать напрямую `python -m socks5tun.run` из клонированной директории (рассмотрим ниже). В составе репозитория уже есть скрипты для сборки wheel-пакета и автоустановки сервиса.

### Шаг 2: Настройка конфигурации

Отредактируйте конфигурационный файл. В репозитории есть примеры: **`config_dev.json`** (для локального тестирования) и **`config_prod.json`** (для боевого сервера). Рассмотрим основные параметры на примере `config_prod.json`:

```json
{
  "tcp_host": "0.0.0.0",
  "tcp_port": 5000,
  "udp_host": "0.0.0.0",
  "udp_port": 5000,
  "tun_mode": "linux",
  "tun": {
    "name": "tun0",
    "address": "10.8.0.1",
    "netmask": "255.255.255.0",
    "peer_address": "10.8.0.2",
    "mtu": 1500
  },
  "nat": {
    "out_iface": "eth0"
  },
  "log_level": "INFO",
  "auth": null,
  "allowed_clients": ["0.0.0.0/0"],
  "blocked_destinations": [
    "0.0.0.0/8",
    "10.0.0.0/8",
    "127.0.0.0/8",
    "169.254.0.0/16",
    "172.16.0.0/12",
    "192.168.0.0/16",
    "240.0.0.0/4"
  ],
  "dns_resolver": "system",
  "self_check": true
}
```

Пояснения основных полей:

- **`tcp_host` / `tcp_port`** – адрес и порт, на котором будет слушать SOCKS5-сервер. В продакшен примере указано `"0.0.0.0:5000"`, то есть слушать на всех интерфейсах порт 5000 (TCP). _Примечание:_ хотя сервер слушает на 0.0.0.0, брандмауэр (UFW) у нас настроен так, чтобы **внешние подключения к этому порту блокировать** – трафик пойдёт только через локальный websocat. Для дополнительной безопасности можете указать `127.0.0.1` вместо `0.0.0.0`, тогда сервер вообще не будет принимать внешние коннекты напрямую.
- **`udp_host` / `udp_port`** – адрес и порт для UDP-ретранслятора (UDP ASSOCIATE). В примере также `0.0.0.0:5000` (порт совмещён с TCP). Это нужно для возможности прямого UDP-взаимодействия. Если **tun-режим** включён, сервер при UDP ASSOCIATE будет использовать виртуальный интерфейс; если нет – может пересылать UDP-пакеты напрямую с этого порта.
  _Примечание:_ Cloudflare **не проксирует UDP**, поэтому UDP-запросы SOCKS5 по WSS напрямую не пройдут. Однако, tun2socks на клиенте может отправлять UDP внутри TCP-соединения, либо можно открыть прямой UDP-канал (например, отдельно поднять WireGuard/OpenVPN). В нашем решении UDP-трафик клиентов при наличии TUN-интерфейса будет идти через него (см. ниже).
- **`tun_mode`** – режим работы TUN-интерфейса. Возможные значения: `"disabled"` (TUN не используется), `"dummy"` (фиктивный TUN для тестов) и `"linux"` (реальный TUN-девайс /dev/net/tun). В продакшен-конфигурации используется режим `"linux"` – будет создан интерфейс tun0.
- **`tun`** – вложенные параметры реального TUN-интерфейса (актуально при `tun_mode="linux"`):

  - `name`: имя устройства (например, tun0).
  - `address` и `peer_address`: IP-адрес сервера на туннеле и «партнёра» (клиента). В примере сервер получит 10.8.0.1/24, а клиенту «виртуально» соответствует 10.8.0.2. Эти адреса используются для маршрутизации: сервер будет ожидать, что исходящий трафик от клиента придёт с IP 10.8.0.2 по туннелю.
  - `netmask`: маска подсети туннеля.
  - `mtu`: MTU туннельного интерфейса.

- **`nat.out_iface`** – внешний сетевой интерфейс сервера для NAT. В нашем случае `eth0` (замените на интерфейс вашего сервера, через который он выходит в Интернет). Сервер настроит iptables/ip6tables для MASQUERADE исходящего трафика с туннеля на этот интерфейс. Это нужно, чтобы пакеты от клиента (10.8.0.2) успешно пошли в сеть с реального IP сервера.
- **`log_level`** – уровень логирования. По умолчанию `"INFO"`. Для более детального логирования установите `"DEBUG"` (полезно для отладки – будет больше информации, например, дампы стека при событиях).
- **`auth`** – данные для SOCKS5-аутентификации. Формат: объект с полями `"username"` и `"password"`. Если указать, сервер будет требовать у клиента авторизацию. (По умолчанию `null` – без пароля, **в продакшене рекомендуется задать** для безопасности, особенно если не используете обфускацию пути или ограничение по IP).
- **`allowed_clients`** – список подсетей, откуда разрешено подключаться к SOCKS5-серверу. По умолчанию `["0.0.0.0/0"]` – все IPv4. Можно сузить, например, только Cloudflare сети или VPN-подсеть. Однако проще полагаться на внешний файрвол (UFW) и/или авторизацию.
- **`blocked_destinations`** – список подсетей, запрещённых в качестве целей для прокси. В примере перечислены локальные сети и резервные адреса. Это предотвращает, например, доступ через прокси к адресам 127.0.0.1 (localhost сервера), внутренней сети хостинга и пр. Можно добавить свои сети. На основе этого списка формируется `deny_rules` (правила блокировки, которые сервер применяет).
- **`dns_resolver`** – режим разрешения DNS для адресов в UDP ASSOCIATE с ATYP=3 (доменные имена). По умолчанию `"system"` – использовать системный резолвер сервера (через `getaddrinfo`). Можно добавить свой резолвер (пока нет поддержки внешнего DNS через Socks5, поэтому обычно оставляем system).
- **`self_check`** – флаг, включающий само-проверку подключения. В данном проекте может использоваться для тестового самоподключения (loopback) с целью мониторинга. Можно оставить `true`.

**Примечание:** Имена файлов конфигурации по умолчанию:

- При запуске без параметров загружается `config_prod.json`.
- Для отладки можно использовать другой файл, указав ключ `-c`, например, `config_dev.json` (см. далее).

После редактирования `config_prod.json` убедитесь, что все параметры корректны. Хотя сервер запускается с правами root (для TUN), старайтесь не оставлять прокси открытым для мира без ограничений и пароля. В нашем примере безопасность обеспечивается комбинацией мер: **UFW** пускает трафик только от Cloudflare, сам socks5tun блокирует доступ к локальным адресам, а секретный путь WebSocket и (опционально) пароль SOCKS5 не дадут воспользоваться туннелем посторонним.

### Шаг 3: Настройка Nginx (WebSocket вход)

На сервере необходимо настроить Nginx для принятия WSS-соединений от Cloudflare и проксирования их на локальный ws-bridge (websocat). Предположим, ваш домен – `example.com`, и через Cloudflare на него будут идти WSS-запросы.

1. **Установите Nginx**, если не установлен (например, `sudo apt install nginx` на Ubuntu). Убедитесь, что Nginx запущен.

2. **Сконфигурируйте серверный блок для WSS.** Ниже приведён пример конфигурации (файл `/etc/nginx/sites-available/ws.conf`):

   ```nginx
   map $http_upgrade $connection_upgrade {
       default   upgrade;
       ''        close;
   }

   server {
       listen 80;
       server_name example.com;

       # Веб-сокет endpoint (пример пути /ws/<SECRET>):
       location = /ws/YourSecretPath123 {
           # Проксируем на локальный WS-сервер (websocat)
           proxy_pass http://127.0.0.1:5001;

           # Обязательные заголовки для WebSocket
           proxy_http_version 1.1;
           proxy_set_header Upgrade $http_upgrade;
           proxy_set_header Connection $connection_upgrade;
           proxy_set_header Host $host;

           # Дополнительные заголовки (помогают сквозь Cloudflare/DPI)
           proxy_set_header X-Forwarded-Proto $scheme;
           proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
           proxy_set_header Origin            https://$host;
           # Если используются подпротоколы WebSocket, пробрасываем:
           proxy_set_header Sec-WebSocket-Protocol $http_sec_websocket_protocol;

           # Настройки таймаутов и буферизации (WebSocket long-lived)
           proxy_read_timeout 3600;
           proxy_send_timeout 3600;
           proxy_buffering off;

           # Логи для отладки (опционально, отдельный access_log)
           access_log /var/log/nginx/ws_access.log;
       }

       # Закрываем доступ ко всему остальному на этом поддомене
       location / {
           return 404;
       }
   }
   ```

   Пояснения:

   - Используется нестандартный секретный URL (`/ws/YourSecretPath123`). Этот секретный путь известен только вам и клиенту. **Не используйте простой путь**, чтобы затруднить обнаружение туннеля.
   - `listen 80;` – мы слушаем порт 80. **Важно:** В настройках Cloudflare для домена `example.com` выберите режим SSL "Flexible". Это значит, что Cloudflare будет принимать HTTPS от клиента, а до нашего сервера доводить его как HTTP на 80-й порт. Мы заблокировали прямой 443, так как не устанавливаем сертификат на сервере (это упрощает настройку). Cloudflare доверяет себе и шифрование от нее до нас не обязательно. Если желаете **Full SSL**, нужно настроить `listen 443 ssl` с сертификатом на сервере и разрешить Cloudflare доступ на 443. В нашем примере будем считать Flexible-режим.
   - Директива `map $http_upgrade` и заголовки `Upgrade/Connection` нужны для корректной работы WebSocket прокси.
   - Заголовок `Origin` устанавливается в значение вашего хоста – это помогает обходить некоторые DPI, которые блокируют нестандартный Origin.
   - В location `/` мы возвращаем 404 на любые другие запросы – весь валидный трафик должен идти только на правильный путь `/ws/YourSecretPath123`. Это доп. защита.
   - Не забудьте заменить `example.com` на ваш домен и `YourSecretPath123` на ваш секретный путь.

3. **Включите конфигурацию и перезагрузите Nginx:**

   ```bash
   sudo ln -s /etc/nginx/sites-available/ws.conf /etc/nginx/sites-enabled/ws.conf
   sudo nginx -t  # проверяем синтаксис
   sudo systemctl reload nginx
   ```

   Убедитесь, что в файрволе **разрешён вход на 80 порт только от Cloudflare**. Можно воспользоваться скриптом из репозитория для UFW: `scripts/update_cf_ufw.sh` – он добавит правила `ALLOW IN` для всех актуальных подсетей Cloudflare на порт 80 и запретит остальным (в конфигурации UFW мы видели правила с комментариями `# CF-80`). Альтернативно, вручную добавьте правила по спискам Cloudflare IPv4/IPv6.

### Шаг 4: Настройка и запуск WS-моста (websocat)

Убедитесь, что установлен **websocat** – удобная утилита для проброса данных между WebSocket и TCP. Можно скачать готовый бинарь или установить через пакетный менеджер. На Debian/Ubuntu можно воспользоваться Cargo (`cargo install websocat`) или скачать релиз с GitHub. После установки положите бинарь в `/usr/local/bin/websocat` и проверьте, что он работает.

Создадим systemd-сервис для **ws-bridge** (если он не предоставлен в репозитории):

Файл `/etc/systemd/system/ws-bridge.service`:

```ini
[Unit]
Description=WebSocket <-> TCP bridge (websocat)
After=network-online.target
Wants=network-online.target

[Service]
User=wsbridge
Group=nogroup
ExecStart=/usr/local/bin/websocat --binary -E ws-l:127.0.0.1:5001 tcp:127.0.0.1:5000
Restart=always
RestartSec=1

# Безопасность: минимизируем привилегии
NoNewPrivileges=yes
ProtectSystem=full
ProtectHome=yes
PrivateTmp=yes
LockPersonality=yes

[Install]
WantedBy=multi-user.target
```

Комментарий: данный сервис запускает `websocat` в режиме **слушателя WebSocket** на локальном `127.0.0.1:5001` (то же, что указано в Nginx `proxy_pass`) и пробрасывает всё в TCP-соединение с нашим SOCKS5-сервером на `127.0.0.1:5000`. Мы запускаем его от отдельного пользователя `wsbridge` без привилегий.

После создания файла,启动 ите и добавьте в автозагрузку:

```bash
sudo useradd -r -s /usr/sbin/nologin wsbridge  # создаём пользователя для моста
sudo systemctl daemon-reload
sudo systemctl enable --now ws-bridge.service
```

Проверьте статус:

```bash
sudo systemctl status ws-bridge.service
```

Должно отображаться **active (running)**. В логах (`journalctl -u ws-bridge`) вы можете видеть сообщения websocat. Часто появляются строки `Connection reset by peer` – это нормально, они означают отсутствие активного подключения или его завершение.

### Шаг 5: Запуск SOCKS5-сервера (socks5tun) как сервиса

Теперь запустим основной сервер **socks5tun**. Если вы устанавливали пакет через pip, исполняемый модуль уже доступен. Если нет – можно запустить его из исходников. Рассмотрим вариант через systemd.

Файл unit для socks5tun уже может поставляться скриптом `scripts/update_socks5tun.sh`, либо создадим свой: `/etc/systemd/system/socks5tun.service`:

```ini
[Unit]
Description=SOCKS5TUN proxy server
Wants=network-online.target
After=network-online.target

[Service]
Type=simple
User=root
AmbientCapabilities=CAP_NET_ADMIN CAP_NET_BIND_SERVICE CAP_NET_RAW
CapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_BIND_SERVICE CAP_NET_RAW

# Подготовка: включим IPv4 forward (если нужно) и настроим NAT6 (если IPv6)
ExecStartPre=/bin/sh -c 'sysctl -w net.ipv4.ip_forward=1'
ExecStartPre=-/bin/bash /opt/socks5tun/scripts/nat6_setup.sh

# Запуск сервера
ExecStart=/usr/bin/python3 -m socks5tun.run -c /opt/socks5tun/config_prod.json
WorkingDirectory=/opt/socks5tun

Environment=PYTHONUNBUFFERED=1
LimitNOFILE=65535
TasksMax=8192
Restart=on-failure
RestartSec=5
TimeoutStopSec=10
KillSignal=SIGINT

# Защита
NoNewPrivileges=yes
PrivateTmp=yes
ProtectSystem=full
ProtectHome=true
DeviceAllow=/dev/net/tun rw
RestrictAddressFamilies=AF_INET AF_INET6 AF_NETLINK

[Install]
WantedBy=multi-user.target
```

Несколько пояснений:

- **AmbientCapabilities и CapabilityBoundingSet** включают CAP_NET_ADMIN (для создания TUN и iptables), CAP_NET_BIND_SERVICE (на случай, если слушаем порт <1024) и CAP_NET_RAW (для raw-сокетов, хотя напрямую не используется, но может быть для pinger). Мы запускаем от root, поэтому эти настройки предосторожности.
- **ExecStartPre**: включаем форвардинг IPv4 (`net.ipv4.ip_forward=1`) и вызываем скрипт `nat6_setup.sh` (который настроит MASQUERADE для IPv6, если нужно). Скрипт `nat6_setup.sh` берёт параметры IPv6 подсети / интерфейса из конфигов или внутри себя (в нашем примере он настроен на `prefix6=64` и интерфейс `eth0`).
- **ExecStart**: запускаем наш сервер. Здесь указано явно `/usr/bin/python3`, но вы можете прописать путь до Python из вашего виртуального окружения. В примере предполагается, что код расположен в `/opt/socks5tun/` – откуда запускаем. Ключ `-c` указывает на файл конфигурации.
- Остальные настройки ограничивают права, как и в случае с ws-bridge.
- _Примечание:_ `WorkingDirectory` стоит указать на каталог проекта, если планируете использовать относительные пути (например, для логов или пр.). В нашем случае он не обязателен, но пусть будет для определённости.

После создания юнита, включите сервис и запустите:

```bash
sudo systemctl daemon-reload
sudo systemctl enable socks5tun.service
sudo systemctl start socks5tun.service
```

Проверьте статус:

```bash
sudo systemctl status socks5tun.service
```

Он должен быть **active (running)**. Также убедитесь, что **socks5tun** и **ws-bridge** успешно запущены и работают совместно:

- `systemctl is-active socks5tun.service` и `ws-bridge.service` должны вернуть "active".
- В логах socks5tun (`journalctl -u socks5tun.service -f`) при старте вы увидите строчку `Starting Socks5 proxy server on 0.0.0.0:5000` и далее `✅ Starting server...`. Если что-то пошло не так – будут сообщения об ошибках (например, неправильный конфиг или отсутствие /dev/net/tun).

**Важно:** После любых правок unit-файла выполните `sudo systemctl daemon-reload`. Если меняли конфиг JSON, перезапустите сервис (`sudo systemctl restart socks5tun.service`). Для просмотра **логов в реальном времени** используйте:

```bash
sudo journalctl -u socks5tun.service -f
```

Для отладки можно временно запустить сервер в консоли напрямую:

```bash
# Запуск с указанным конфигом и выводом логов в stdout:
python -m socks5tun.run -c config_prod.json
```

При этом удобнее выставить `"log_level": "DEBUG"` в конфиге, чтобы видеть подробный вывод. Остановить – `Ctrl+C`.

## Настройка клиента

Для подключения клиента вам понадобятся утилиты для создания локального прокси и установления WSS-туннеля. В примере используются **Windows-клиенты** `connect2socks.exe` и `wsclient.exe`. Однако есть и кросс-платформенные альтернативы (например, использование `websocat` или реализации на Go). Расскажем об обоих подходах.

### Вариант 1: Windows (connect2socks + wsclient)

**connect2socks.exe** – небольшая программа, которая открывает локальный HTTP-прокси и переправляет поступающие через `CONNECT` соединения в SOCKS5.

**wsclient.exe** – клиентская утилита, устанавливающая WebSocket-соединение с сервером и работающая как локальный SOCKS5-туннель.

Шаги по настройке:

1. **Запустите wsclient.** Он будет выступать в роли локального SOCKS5-прокси, который переправляет трафик на сервер. Предположим, он слушает порт `127.0.0.1:1194` (можно выбрать любой свободный порт). Команда запуска может выглядеть так:

   ```powershell
   wsclient.exe -L 127.0.0.1:1194 -R wss://example.com/ws/YourSecretPath123
   ```

   Здесь ключ `-L` задаёт локальный адрес:порт для SOCKS5, а `-R` – удаленный WSS-URL вашего сервера (через Cloudflare). После запуска wsclient устанавливает соединение с сервером по WSS. Если настроена SOCKS5-авторизация, передайте креденшалы (например, `-U user -P pass`, в зависимости от реализации клиента).

   > **Примечание:** Если у вас нет готового `wsclient.exe`, убедитесь, что используете программу, поддерживающую проксирование SOCKS5 через WebSocket. Возможно, вы найдете готовые клиенты или придётся скомпилировать (например, существуют реализации на Go). На крайний случай, можно заменить связкой `websocat` + `ssh` (но это сложнее).
   > В простейшем случае `wsclient.exe` может быть аналогом `websocat tcp-l:127.0.0.1:1194 wss://...`.

2. **Запустите connect2socks.** Теперь, чтобы браузер (который умеет работать с HTTP-прокси) мог использовать наш SOCKS5-туннель, поднимем локальный HTTP-прокси на порт 3128:

   ```powershell
   connect2socks.exe -L 127.0.0.1:3128 -R 127.0.0.1:1194
   ```

   Здесь `-L` – адрес:порт для локального HTTP-прокси, `-R` – адрес SOCKS5-прокси (наш wsclient на 1194). После запуска, connect2socks слушает 3128 и при получении от браузера команды `CONNECT` к какому-либо хосту, сам устанавливает SOCKS5-соединение к wsclient (1194) и просит прокси соединиться с нужным адресом.

3. **Настройте браузер/систему использовать прокси:** Укажите HTTP-прокси `127.0.0.1` порт `3128`. Например, в настройках Chrome/Edge можно задать адрес локального прокси. **Важно:** не включайте системный прокси для всех протоколов, если ОС может резолвить DNS вне прокси – возможны утечки DNS. Лучше использовать браузер с настройкой "proxy SOCKS5 DNS" или воспользоваться режимом VPN (см. ниже).

   - Для **Chrome**: можно запустить с параметрами командной строки или настроить через системные настройки (Chrome использует системный прокси).
   - Для **Firefox**: можно прямо указать SOCKS5 прокси, минуя HTTP (см. ниже про вариант без connect2socks).
   - Для других приложений: укажите HTTP-прокси `127.0.0.1:3128` для тех, кто не умеет SOCKS5.

4. **Проверьте работу:** Зайдите на сайт, проверьте внешний IP (он должен быть IP вашего сервера). В логах сервера (journalctl) вы увидите записи о подключениях. Например:

   ```
   [LOCAL FORWARD] TCP connection from 127.0.0.1:54321 (...)
   [UDP-ALLOW] 10.8.0.2:12345 → 8.8.8.8:53 len=...
   ```

   Первая строка означает, что локальный форвардер (connect2socks/wsclient) установил TCP-соединение. Вторая – что UDP запрос (DNS) с клиента 10.8.0.2 на 8.8.8.8 был разрешён и отправлен (через TUN).

   Если страницы не открываются:

   - Проверьте, установилось ли WSS-соединение (в логе wsclient должны быть строки об успешном подключении).
   - Проверьте, проходит ли трафик через Cloudflare: на Cloudflare Dashboard в разделе Analytics можно увидеть WebSocket соединения.
   - Убедитесь, что **Correct Secret Path** совпадает на клиенте и в nginx.
   - Проверьте UFW: порт 80 от Cloudflare, порт 5000/udp (если используете) открыты, остальное закрыто.
   - Попробуйте отключить временно `auth` в конфиге или наоборот, настроить и указать на клиенте.
   - Запустите браузер с чистым кэшем/DNS.

### Вариант 2: Кроссплатформенный (websocat напрямую)

Если у вас нет готовых Windows-утилит, можно использовать **websocat** и на стороне клиента (например, в Linux или WSL). При этом вы можете обойтись без connect2socks, если ваше приложение умеет напрямую работать с SOCKS5.

**Прямое использование SOCKS5 (Firefox, cURL и т.д.):**
Запустите на клиенте websocat, чтобы он открыл локальный TCP-сокет и связал его с WSS-туннелем:

```bash
websocat -b -E tcp-l:1080 wss://example.com/ws/YourSecretPath123
```

Эта команда откроет локально порт **1080** (без авторизации, просто TCP-listener) и при каждом соединении будет делать WSS-коннект к серверу, передавая все байты. По сути, это аналог работы wsclient, но без встроенного SOCKS5-прокси – websocat просто тупо перенаправляет. Однако, если приложение (например, Firefox) **само говорит на языке SOCKS5**, то ему не нужен специальный обработчик: мы просто на 1080 подадим всё на сервер. То есть:

- Настройте Firefox: **Manual proxy** – SOCKS5 прокси = `127.0.0.1` порт `1080`, опция "Proxy DNS when using SOCKS" = включена.
- Запустите websocat как выше.
- Теперь браузер будет делать SOCKS5 handshake к 127.0.0.1:1080, websocat отправит этот handshake по WSS на сервер, сервер его воспримет как обычный запрос и установит соединение. Всё прозрачно.

**Использование HTTP-прокси через websocat:**
Если нужно поддержать приложения, которые умеют только HTTP-прокси, то можно дополнительно поднять connect2socks (он есть под Linux в виде утилиты, или использовать аналог `ssh -L` + `nc` – но проще connect2socks). То есть схема будет та же: connect2socks -> локальный websocat. Например:

```bash
# Терминал 1: websocat соединяет локальный 1194 -> WSS -> сервер
websocat -b -E tcp-l:127.0.0.1:1194 wss://example.com/ws/YourSecretPath123

# Терминал 2: connect2socks слушает 3128 и шлёт всё на 1194
connect2socks -L 127.0.0.1:3128 -R 127.0.0.1:1194
```

(Синтаксис connect2socks может отличаться, в Linux возможно утилита называется иначе. Суть в том, что нужен HTTP CONNECT -> SOCKS5 переводчик.)

**Примечание по DNS:** Если приложение не умеет проксировать DNS (например, система может сама резолвить имена), рекомендуется вручную настроить DNS-сервер на стороне клиента на какой-то публичный (8.8.8.8) **и** разрешить DNS через туннель. Firefox умеет отправлять DNS через SOCKS5 (опция proxy DNS), а вот Chrome – нет, он резолвит до обращения к прокси. В случае Chrome это не критично, если сами сайты блокируются по IP – мы обходим через туннель. Но если блокируются по DNS – лучше в системе прописать безопасный DNS (или использовать **DoH**/**DoT**). В альтернативном сценарии можно поднять локальный DNS-сервер, отправляющий запросы через прокси.

## Автозапуск, мониторинг и обновление

**Автозапуск:** Мы уже выполнили `systemctl enable` для сервисов `socks5tun` и `ws-bridge`, так что они будут запускаться при загрузке. Проверьте их статус после перезагрузки, чтобы убедиться, что всё поднялось корректно.

**Логирование:** Логи сервисов сохраняются в journalctl. Чтобы посмотреть последние сообщения и продолжить слежение:

```bash
journalctl -u socks5tun.service -f -n 100
journalctl -u ws-bridge.service -f -n 50
```

При уровне `DEBUG` вы получите очень подробный лог, включая каждый SOCKS-запрос, решения ACL (ALLOW/DENY) и даже содержимое некоторых пакетов (например, hexdump ошибок). В режиме `INFO` логирует основные события: запуск/останов, подключения, ошибки соединений.

**Отладка проблем:** Если что-то не работает, используйте следующие советы:

- Запустите `socks5tun` вручную в терминале (как описано выше) – так вы сразу увидите traceback, если где-то исключение.
- Используйте утилиту `ss`/`netstat` на сервере, чтобы удостовериться, что порт 5000 слушается, 5001 слушается websocat, и что есть установленные ESTABLISHED соединения от Cloudflare на 80 и локальные от websocat на 5000.
- Посмотрите access-лог Nginx (`/var/log/nginx/ws_access.log`). Там должны быть записи при соединении клиента через Cloudflare: код 101 (Switching Protocols) для URL `/ws/YourSecretPath123`. Например:

  ```
  104.23.221.170 - - [13/Aug/2025:09:54:45 +0000] "GET /ws/2i43wj9hqO3alZaBaeiixHQJ HTTP/1.1" 101 0 "-" "Mozilla/5.0 ..."
  ```

  Если вы не видите 101, значит WebSocket не устанавливается – проверьте конфигурацию или правильность пути/домена.

- В логах Cloudflare (если Enterprise) или через `curl https://www.cloudflare.com/ips-v4` убедитесь, что все сети добавлены в UFW. Наш скрипт `update_cf_ufw.sh` автоматизирует это (его можно добавлять в cron).
- Если **UDP-трафик** не проходит: убедитесь, что на клиенте приложение действительно шлёт UDP через SOCKS (например, Firefox при proxy DNS), и что серверный tun0 поднят (`ip addr show tun0`), имеет указанные IP. Также проверьте `iptables -t nat -L -n` – должна быть правила MASQUERADE для исходящего трафика с 10.8.0.0/24. Наш сервис при старте выполняет это для IPv4 (в коде `run.py` добавляет правило) и `nat6_setup.sh` – для IPv6.

**Обновление сервера:** В репозитории есть скрипт `scripts/update_socks5tun.sh` для автоматического обновления. Он может скачивать новую версию (например, pull из git), пересобирать wheel и обновлять сервис. Если вы развернули всё вручную, можно обновиться так:

```bash
cd /opt/socks5tun
git pull
pip install .
sudo systemctl restart socks5tun.service
```

_(Предполагается, что у вас всё под контролем version control или вы знаете, что делаете.)_ Не забудьте после обновления при необходимости перезагрузить демона systemd (`daemon-reload`) если менялись .service файлы.

На этом настройка завершена. Вы получили работающую систему, где локальные приложения через прокси обмениваются трафиком с Интернетом, используя облачного посредника. Успешного вам использования!
