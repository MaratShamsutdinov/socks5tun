[32m[INFO] === MISC FILES ===(B[m

# --- ./help.txt ---
# Активировать окружение на сервере:
source /opt/venv-pyroute/bin/activate

# Архивировать папку tests
zip -r tests_with_ci.zip tests .github/workflows/test.yml

# Создать txt файл с содержимым test + ДЕРЕВО
./diagnostics/collect_tests.sh


### Запуск проекта:
## Запуска через автомат

# перезапуск systemd, если были обновления systemd
sudo systemctl daemon-reexec

# обновляет конфигурацию systemd (нужно после изменения .service файла)
sudo systemctl daemon-reload

# перезапуск проекта
sudo systemctl restart socks5tun.service

# логи он-лайн
sudo journalctl -fu socks5tun.service

## Запуск вручную
# Тестовый запуск проекта
python -m socks5tun.run -c config_dev.json

# Рабочий запуск
python -m socks5tun.run


### Прочее
# stunnel на сервере
sudo nano /etc/stunnel/stunnel.conf

# Запустить тесты
pytest -q

# Вернутся в проект
cd ~/socks5tun
# --- ./config_dev.json ---
{
    "tcp_host": "127.0.0.1",
    "tcp_port": 1080,
    "udp_host": "127.0.0.1",
    "udp_port": 1080,
    "tun_mode": "dummy",
    "log_level": "INFO",
    "auth": null,
    "allowed_clients": [
        "127.0.0.1/32"
    ],
    "blocked_destinations": [
        "0.0.0.0/8",
        "10.0.0.0/8",
        "127.0.0.0/8",
        "169.254.0.0/16",
        "172.16.0.0/12",
        "192.168.0.0/16",
        "240.0.0.0/4"
    ],
    "dns_resolver": "system"
}
# --- ./.github/workflows/test.yml ---
name: CI
on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  tests:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: [3.12]
    steps:
      - uses: actions/checkout@v3
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      - name: Run tests
        run: pytest

# --- ./config_prod.json ---
{
  "tcp_host": "0.0.0.0",
  "tcp_port": 5000,
  "udp_host": "0.0.0.0",
  "udp_port": 5000,
  "tun_mode": "linux",
  "log_level": "DEBUG",

  "tun": {
    "name": "tun0",
    "address": "10.8.0.1",
    "netmask": "255.255.255.0",
    "peer_address": "10.8.0.2",
    "mtu": 1500
  },

  "nat": {
    "out_iface": "eth0"
  },

  "auth": null,
  "allowed_clients": ["0.0.0.0/0"],
  "blocked_destinations": [
    "0.0.0.0/8", "10.0.0.0/8", "127.0.0.0/8",
    "169.254.0.0/16", "172.16.0.0/12", "192.168.0.0/16",
    "240.0.0.0/4"
  ],
  "dns_resolver": "system",
  "self_check": true
}

# --- ./build/lib/socks5tun/dummy_tun.py ---
"""
Dummy TUN interface for simulating a TUN device.
"""

import threading
import traceback
import logging
from collections import deque


class DummyTun:
    """
    A dummy TUN interface that mimics a TUN device for testing or environments
    where a real TUN device is not available.
    Data written to this dummy interface
    is stored, and data can be injected for reading.
    """

    def __init__(self):
        # Queues for incoming (to be read) and outgoing (written) data
        self._incoming_data = deque()
        self._outgoing_data = deque()
        self._lock = threading.Lock()
        # Conditions to wait for data availability
        self._incoming_cond = threading.Condition(self._lock)
        self._outgoing_cond = threading.Condition(self._lock)
        self.active = False

    def open(self):
        """
        Open/initialize the dummy TUN interface.
        (For a real TUN, this would create the TUN device.
        Here we just mark it active.)
        """
        with self._lock:
            self.active = True

    def read(self, size: int = 1500) -> bytes:
        """
        Read data from the dummy TUN interface
        (blocking until data is available or interface is closed).
        Returns bytes of data, or b'' if the interface is closed.
        """
        with self._incoming_cond:
            # Wait until data is available or the interface becomes inactive
            while not self._incoming_data and self.active:
                self._incoming_cond.wait()
            if not self.active and not self._incoming_data:
                # Interface closed and no data remaining
                return b""
            data = self._incoming_data.popleft()
        # Return up to 'size' bytes from the data (simulate reading a packet)
        if size and len(data) > size:
            remaining = data[size:]
            # Put the remaining back to be read next time
            with self._incoming_cond:
                self._incoming_data.appendleft(remaining)
            return data[:size]
        else:
            return data

    def write(self, data: bytes) -> int:
        """
        Write data to the dummy TUN interface.
        (For a real TUN, this would send the packet into the OS network stack.)
        Here we store it in an outgoing queue for inspection.
        Returns the number of bytes written.
        """
        if logging.getLogger().isEnabledFor(logging.DEBUG):
            print("🔄 DummyTun.write() called by:")
            traceback.print_stack(limit=5)
        traceback.print_stack(limit=5)
        with self._outgoing_cond:
            self._outgoing_data.append(data)
            # Notify any waiters for outgoing data (if used in tests)
            self._outgoing_cond.notify_all()
        return len(data)

    def inject(self, data: bytes):
        """
        Inject data into the dummy TUN interface as
        if it was received from the network.
        This data will be available to read() by the server.
        """
        with self._incoming_cond:
            self._incoming_data.append(data)
            # Notify any thread waiting for incoming data
            self._incoming_cond.notify_all()

    def close(self):
        """
        Close the dummy TUN interface.
        """
        with self._incoming_cond:
            self.active = False
            # Wake up any waiting readers so they can stop
            self._incoming_cond.notify_all()

# --- ./build/lib/socks5tun/config.py ---
"""
Configuration handling for Socks5 proxy server.
"""

import json
import ipaddress


class Config:
    """
    Holds configuration for the Socks5 server.
    """

    def __init__(self, data: dict):
        # TCP and UDP listening addresses and ports
        self.tcp_host: str = data.get("tcp_host", "127.0.0.1")
        self.tcp_port: int = data.get("tcp_port", 1080)
        self.udp_host: str = data.get("udp_host", "127.0.0.1")
        self.udp_port: int = data.get("udp_port", 1080)
        # Full tun/nat configs for easier access
        self.tun = data.get("tun", {})
        self.nat = data.get("nat", {})
        # TUN interface mode (default "dummy")
        self.tun_mode: str = data.get("tun_mode", "dummy")
        self.dns_resolver = data.get("dns_resolver", "system")
        # Logging level
        self.log_level: str = data.get("log_level", "INFO").upper()
        # Authentication credentials (if any)
        auth_data = data.get("auth")
        if (
            auth_data
            and isinstance(auth_data, dict)
            and "username" in auth_data
            and "password" in auth_data
        ):
            self.auth = {
                "username": auth_data["username"],
                "password": auth_data["password"],
            }
        else:
            self.auth = None
        # Allowed client networks
        allowed_list = data.get("allowed_clients", ["0.0.0.0/0"])
        self.allowed_clients = [ipaddress.ip_network(net) for net in allowed_list]
        # Blocked destination networks
        blocked_list = data.get("blocked_destinations", [])
        self.blocked_destinations = [ipaddress.ip_network(net) for net in blocked_list]
        # Backward compatibility
        self.forbidden_networks = data.get("forbidden_networks", [])
        self.blocked_destinations = [
            ipaddress.ip_network(net)
            for net in data.get(
                "blocked_destinations",
                [],
            )
        ]
        self.deny_rules = [(net, None) for net in self.blocked_destinations]
        self.allow_rules = []


def load_config(path: str) -> Config:
    """
    Load configuration from a JSON file and return a Config object.
    Raises FileNotFoundError if file is not found,
    or ValueError if JSON is invalid or contents are not as expected.
    """
    try:
        with open(path, "r") as f:
            data = json.load(f)
    except FileNotFoundError:
        raise
    except json.JSONDecodeError as e:
        raise ValueError(f"Invalid JSON configuration: {e}")

    # Backward compatibility for old keys
    if "tun" in data:
        if "tun_mode" not in data:
            data["tun_mode"] = "linux" if data["tun"] else "disabled"
        data.pop("tun", None)
    if "bind_host" in data or "bind_port" in data:
        raise ValueError(
            "Outdated config keys 'bind_host'/'bind_port' detected; "
            "use 'tcp_host'/'tcp_port' instead."
        )

    # Validate required field types and values
    if "tcp_host" in data and not isinstance(data["tcp_host"], str):
        raise ValueError("tcp_host must be a string")
    if "tcp_port" in data and not isinstance(data["tcp_port"], int):
        raise ValueError("tcp_port must be an integer")
    if "udp_host" in data and not isinstance(data["udp_host"], str):
        raise ValueError("udp_host must be a string")
    if "udp_port" in data and not isinstance(data["udp_port"], int):
        raise ValueError("udp_port must be an integer")
    if "tun_mode" in data:
        if not isinstance(data["tun_mode"], str):
            raise ValueError("tun_mode must be a string")
        if data["tun_mode"] not in {"dummy", "linux", "disabled"}:
            raise ValueError(
                "tun_mode must be one of: 'dummy', " "'linux', or 'disabled'"
            )
    if "log_level" in data and not isinstance(data["log_level"], str):
        raise ValueError("log_level must be a string")
    if "allowed_clients" in data and not isinstance(
        data["allowed_clients"],
        list,
    ):
        raise ValueError("allowed_clients must be a list of network strings")
    if "blocked_destinations" in data and not isinstance(
        data["blocked_destinations"], list
    ):
        raise ValueError(
            "blocked_destinations " "must be " "a list of network " "strings"
        )
    if "auth" in data:
        if data["auth"] is not None:
            if not (
                isinstance(data["auth"], dict)
                and "username" in data["auth"]
                and "password" in data["auth"]
            ):
                raise ValueError(
                    "auth must be an "
                    "object with 'username' "
                    "and 'password', or null"
                )

    # Create and return Config object
    return Config(data)

# --- ./build/lib/socks5tun/logger.py ---
"""
Logging configuration for Socks5 proxy server.
"""
import logging

def setup_logging(level: str):
    """
    Configure logging for the proxy server with the given level.
    """
    # Convert level name to numeric value (default to INFO if unrecognized)
    numeric_level = getattr(logging, level.upper(), logging.INFO)
    logging.basicConfig(
        level=numeric_level,
        format="%(asctime)s [%(levelname)s] [%(threadName)s] %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S"
    )
    # Optionally, adjust logging levels for third-party libraries if needed
    logging.getLogger("urllib3").setLevel(logging.WARNING)

# --- ./build/lib/socks5tun/__init__.py ---

# --- ./build/lib/socks5tun/run.py ---
# run.py
# !/usr/bin/env python3
"""
Entry point for the Socks5 proxy server.
"""
import argparse
import logging
import os
import sys
import threading
import subprocess
import json
import fcntl
import struct
from datetime import datetime

from socks5tun.config import load_config
from socks5tun.logger import setup_logging
from socks5tun.server import SocksServer

logger = logging.getLogger(__name__)


def main():
    parser = argparse.ArgumentParser(description="Socks5 Proxy Server")
    parser.add_argument(
        "-c",
        "--config",
        default="config_prod.json",
        help="Path to configuration JSON file",
    )
    args = parser.parse_args()
    try:
        cfg = load_config(args.config)

    except FileNotFoundError:
        logger.error("Configuration file not found: %s", args.config)
        sys.exit(1)
    except ValueError as e:
        logger.error("Error in configuration: %s", e)
        sys.exit(1)

    # Setup logging with level from config
    setup_logging(cfg.log_level)
    log = logging.getLogger("socks5-server")

    from ipaddress import ip_network

    cfg.allowed_clients = [ip_network(net) for net in cfg.allowed_clients]
    logger.debug(">> allowed_clients converted to: %s", cfg.allowed_clients)

    cfg.blocked_destinations = [ip_network(net) for net in cfg.blocked_destinations]

    if hasattr(cfg, "deny_rules"):
        cfg.deny_rules = [(ip_network(net), port) for net, port in cfg.deny_rules]
        log.debug(">> deny_rules converted to: %s", cfg.deny_rules)

    if hasattr(cfg, "allow_rules"):
        cfg.allow_rules = [(ip_network(net), port) for net, port in cfg.allow_rules]
        log.debug(">> allow_rules converted to: %s", cfg.allow_rules)

    log.info(
        "Starting Socks5 proxy server on %s:%d",
        cfg.tcp_host,
        cfg.tcp_port,
    )
    # If TUN interface is enabled in config, open it
    tun = None
    if cfg.tun_mode:
        try:
            if cfg.tun_mode == "dummy":
                from socks5tun.dummy_tun import DummyTun

                tun = DummyTun()
                tun.open()
                log.info(
                    "Dummy TUN interface opened "
                    "(not connected to "
                    "system network)",
                )
            elif cfg.tun_mode == "linux":

                TUNSETIFF = 0x400454CA
                IFF_TUN = 0x0001
                IFF_NO_PI = 0x1000
                tun_fd = os.open("/dev/net/tun", os.O_RDWR)
                ifs = fcntl.ioctl(
                    tun_fd,
                    TUNSETIFF,
                    struct.pack("16sH", b"tun%d", IFF_TUN | IFF_NO_PI),
                )
                tun_name = ifs[:16].strip(b"\x00").decode('utf-8')
                log.info("🔧 Created TUN interface with name: %s", tun_name)

                class LinuxTun:
                    def __init__(self, fd):
                        self.fd = fd

                    def read(self, size: int = 1500):
                        return os.read(self.fd, size)

                    def write(self, data: bytes):
                        return os.write(self.fd, data)

                    def close(self):
                        os.close(self.fd)

                tun = LinuxTun(tun_fd)
                log.info("Linux TUN interface %s opened", tun_name)

                # --- NEW: авто-конфигурация интерфейса и NAT ---

                if os.geteuid() == 0:
                    tun_ip = cfg.tun.get("address", "10.8.0.1")
                    tun_netmask = cfg.tun.get("netmask", "255.255.255.0")
                    peer_ip = cfg.tun.get("peer_address", "10.8.0.2")
                    mtu = cfg.tun.get("mtu", 1500)
                    out_iface = cfg.nat.get("out_iface")

                    try:
                        subprocess.run(
                            [
                                "ip",
                                "addr",
                                "add",
                                f"{tun_ip}/{tun_netmask}",
                                "peer",
                                peer_ip,
                                "dev",
                                tun_name,
                            ],
                            check=True,
                        )
                        subprocess.run(
                            ["ip", "link", "set", tun_name, "mtu", str(mtu)],
                            check=True,
                        )
                        subprocess.run(
                            ["ip", "link", "set", tun_name, "up"],
                            check=True,
                        )
                        log.info(
                            "Configured IP %s peer %s mtu %s on %s",
                            tun_ip,
                            peer_ip,
                            mtu,
                            tun_name,
                        )
                        # Включаем форвардинг
                        with open("/proc/sys/net/ipv4/ip_forward", "w") as f:
                            f.write("1\n")
                        if out_iface:
                            subprocess.run(
                                [
                                    "iptables",
                                    "-t",
                                    "nat",
                                    "-C",
                                    "POSTROUTING",
                                    "-s",
                                    f"{tun_ip}/{tun_netmask}",
                                    "-o",
                                    out_iface,
                                    "-j",
                                    "MASQUERADE",
                                ],
                                check=False,
                            )
                            subprocess.run(
                                [
                                    "iptables",
                                    "-t",
                                    "nat",
                                    "-A",
                                    "POSTROUTING",
                                    "-s",
                                    f"{tun_ip}/{tun_netmask}",
                                    "-o",
                                    out_iface,
                                    "-j",
                                    "MASQUERADE",
                                ],
                                check=False,
                            )
                            log.info(
                                "Added MASQUERADE rule for %s → %s", tun_name, out_iface
                            )
                    except subprocess.CalledProcessError as e:
                        log.error("Failed to configure TUN/NAT: %s", e)
                        if os.environ.get("ALLOW_CONTINUE_ON_TUN_ERROR") == "1":
                            return
                        else:
                            sys.exit(1)
                else:
                    log.warning(
                        "Skipping TUN/NAT auto-setup: not running as root (UID != 0)"
                    )

                # ------------------------------------------------

            else:
                tun = None
        except Exception as e:
            log.error("Failed to initialize TUN interface: %s", e)
            if os.environ.get("ALLOW_CONTINUE_ON_TUN_ERROR") == "1":
                return
            else:
                sys.exit(1)
    # Start the Socks5 server and UDP relay thread
    from socks5tun.udp_handler import start_udp_loop

    def udp_wrapper():
        try:
            start_udp_loop(cfg, tun)
        except Exception as e:
            log.exception("Exception in UDP thread: %s", e)

    threading.Thread(
        target=udp_wrapper,
        daemon=True,
    ).start()
    os.environ["DISABLE_SELF_CONNECT"] = "1"
    server = SocksServer(cfg, tun=tun)

    try:
        log.info(
            "✅ Starting server, patch is active at %s",
            datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        )
        server.start()
    except KeyboardInterrupt:
        log.info("Server interrupted by user, shutting down")
    finally:
        if tun:
            tun.close()

            if getattr(cfg, "tun_mode", None) == "linux":
                tun_name = cfg.tun.get("name", "tun0")

                # --- Удаляем NAT-правило ---
                try:
                    tun_ip = cfg.tun.get("address", "10.8.0.1")
                    tun_netmask = cfg.tun.get("netmask", "255.255.255.0")
                    out_iface = cfg.nat.get("out_iface")
                    if out_iface:
                        subprocess.run(
                            [
                                "iptables",
                                "-t",
                                "nat",
                                "-D",
                                "POSTROUTING",
                                "-s",
                                f"{tun_ip}/{tun_netmask}",
                                "-o",
                                out_iface,
                                "-j",
                                "MASQUERADE",
                            ],
                            stdout=subprocess.DEVNULL,
                            stderr=subprocess.DEVNULL,
                            check=False,
                        )
                        log.info(
                            "Removed MASQUERADE rule for %s → %s",
                            tun_name,
                            out_iface,
                        )
                except Exception as e:
                    log.warning(f"Failed to remove MASQUERADE rule: {e}")

                # --- Удаляем TUN при остановке ---
                log.info(f"Removing TUN interface: {tun_name}")
                try:
                    subprocess.run(
                        [
                            "ip",
                            "tuntap",
                            "del",
                            "dev",
                            tun_name,
                            "mode",
                            "tun",
                        ],
                        stdout=subprocess.DEVNULL,
                        stderr=subprocess.DEVNULL,
                        check=False,
                    )
                except Exception as e:
                    log.warning(f"Failed to delete tun {tun_name}: {e}")


if __name__ == "__main__":
    main()

# --- ./build/lib/socks5tun/server.py ---
# server.py
import os
import inspect
import psutil
import traceback
import socket
import threading
import select
import logging
import ipaddress

from socks5tun.config import Config

# SOCKS5 protocol constants and values
SOCKS_VERSION = 5
# Authentication methods
NO_AUTH = 0x00
USER_AUTH = 0x02
NO_ACCEPTABLE = 0xFF
# Command codes
CMD_CONNECT = 0x01
CMD_BIND = 0x02  # BIND not implemented
CMD_UDP_ASSOCIATE = 0x03
# Address types
ADDR_IPV4 = 0x01
ADDR_DOMAIN = 0x03
ADDR_IPV6 = 0x04
# Reply codes
REP_SUCCESS = 0x00
REP_GENERAL_FAILURE = 0x01
REP_CONN_NOT_ALLOWED = 0x02
REP_NETWORK_UNREACHABLE = 0x03
REP_HOST_UNREACHABLE = 0x04
REP_CONN_REFUSED = 0x05
REP_TTL_EXPIRED = 0x06
REP_CMD_NOT_SUPPORTED = 0x07
REP_ADDR_NOT_SUPPORTED = 0x08


# Порты, с которых мы ожидаем локальный форвардинг (stunnel, ssh -L, tun2socks и т.п.)
LOCAL_FORWARD_WHITELIST = {443, 1080, 1194}


def is_self_connection(
    client_ip: str, client_port: int, server_port: int
) -> tuple[str, str]:
    """
    Определяет тип соединения:
    - 'self' — loopback + клиентский порт = порт сервера (реальный self-connect)
    - 'local_forward' — loopback + порт клиента в whitelist (ожидаемый локальный форвардер)
    - 'local_other' — loopback всё остальное
    - 'other' — всё остальное
    """
    try:
        ip_obj = ipaddress.ip_address(client_ip)
    except ValueError:
        ip_obj = None

    if ip_obj and ip_obj.is_loopback:
        pname = "unknown"
        pid = None
        for conn in psutil.net_connections(kind='tcp'):
            if not conn.laddr or not conn.raddr:
                continue
            if (
                conn.laddr[1] == server_port
                and conn.raddr[0] == client_ip
                and conn.raddr[1] == client_port
            ):
                pid = conn.pid
                if pid:
                    try:
                        pname = psutil.Process(pid).name()
                    except Exception:
                        pass
                break

        # 1. Настоящий self-connect
        if client_port == server_port:
            return "self", f"{pid} {pname}"

        # 2. Локальный форвард (по whitelist портов)
        if client_port in LOCAL_FORWARD_WHITELIST:
            return "local_forward", f"{pid} {pname}"

        # 3. Остальное loopback
        return "local_other", f"{pid} {pname if pname else 'unknown'}"

    return "other", "unknown"


def recv_exact(conn, n):
    """Читает ровно n байт из сокета, иначе выбрасывает исключение."""
    data = b''
    while len(data) < n:
        chunk = conn.recv(n - len(data))
        if not chunk:
            raise IOError("Connection closed prematurely")
        data += chunk
    return data


class SocksServer:
    """
    A Socks5 proxy server that handles TCP CONNECT and UDP ASSOCIATE commands.
    """

    def __init__(self, config: Config, tun=None):
        self.config = config
        self.tun = tun  # DummyTun or real TUN interface if provided
        self._log = logging.getLogger("socks5-server")
        # Prepare allowed client networks
        self.allowed_nets = config.allowed_clients
        # Authentication setup
        self.auth_required = config.auth is not None
        self.auth_credentials = config.auth if config.auth else {}

    def start(self):
        """
        Start the Socks5 server: bind and listen for incoming connections,
        handle each in a new thread.
        """

        self._log.warning(
            "[DEBUG] Server started — stack:\n%s",
            ''.join(traceback.format_stack(limit=10)),
        )

        # Выбираем тип адреса
        family = socket.AF_INET6 if ':' in self.config.tcp_host else socket.AF_INET
        with socket.socket(family, socket.SOCK_STREAM) as server_sock:
            server_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            server_sock.bind((self.config.tcp_host, self.config.tcp_port))
            server_sock.listen()
            self._log.info(
                "Listening on %s:%d",
                self.config.tcp_host,
                self.config.tcp_port,
            )

            while True:
                try:
                    client_sock, client_addr = server_sock.accept()

                    # --- NEW: проверка IP клиента ---
                    if not self._is_client_allowed(client_addr[0]):
                        self._log.warning(
                            "Rejected connection from %s:%d "
                            "(not in allowed_clients)",
                            client_addr[0],
                            client_addr[1],
                        )
                        client_sock.close()
                        continue  # ждём следующий accept
                    # --------------------------------

                    # Определяем тип подключения и информацию о процессе
                    ctype, who = is_self_connection(
                        client_addr[0], client_addr[1], self.config.tcp_port
                    )

                    if ctype == "self":
                        # Настоящий self-test
                        self._log.info(
                            "[🧪 SELF-TEST] Accepted internal connection "
                            "from %s:%d (%s)",
                            client_addr[0],
                            client_addr[1],
                            who,
                        )
                        stack = inspect.stack()
                        self._log.debug(
                            "Top call: %s:%d in %s()",
                            stack[1].filename,
                            stack[1].lineno,
                            stack[1].function,
                        )

                    elif ctype == "local_stunnel":
                        # Локальный stunnel на loopback
                        self._log.info(
                            "[LOCAL STUNNEL] TCP connection from %s:%d (%s)",
                            client_addr[0],
                            client_addr[1],
                            who,
                        )

                    elif ctype == "local_other":
                        self._log.info(
                            "[LOCAL] TCP connection from %s:%d (%s)",
                            client_addr[0],
                            client_addr[1],
                            who,
                        )

                    elif ctype == "local_forward":
                        self._log.info(
                            "[LOCAL FORWARD] TCP connection from %s:%d (%s)",
                            client_addr[0],
                            client_addr[1],
                            who,
                        )

                    else:
                        # Любое другое подключение
                        self._log.info(
                            "[ACCEPT] TCP connection from %s:%d by %s",
                            client_addr[0],
                            client_addr[1],
                            who,
                        )
                        self._log.debug(
                            "[TRACE] Stack trace for connection from %s:%d:\n%s",
                            client_addr[0],
                            client_addr[1],
                            ''.join(traceback.format_stack(limit=8)),
                        )

                    # Запускаем обработчик клиента в отдельном потоке
                    threading.Thread(
                        target=self._handle_client,
                        args=(client_sock, client_addr),
                        daemon=True,
                    ).start()

                except OSError:
                    break

    def _is_client_allowed(self, client_ip: str) -> bool:
        """Check if the client IP is in allowed networks."""
        ip_obj = ipaddress.ip_address(client_ip)
        return any(ip_obj in net for net in self.allowed_nets)

    def _is_dest_allowed(self, dest_ip: str, dest_port: int) -> bool:
        """Check if the destination IP:
        port is permitted by allow/deny rules."""
        try:
            ip_obj = ipaddress.ip_address(dest_ip)
        except Exception:
            return False
        # Deny rules
        for net, port in getattr(self.config, "deny_rules", []):
            if ip_obj in net and (port is None or dest_port == port):
                return False
        # Allow rules
        allow_rules = getattr(self.config, "allow_rules", [])
        if allow_rules:
            allowed = False
            for net, port in allow_rules:
                if ip_obj in net and (port is None or dest_port == port):
                    allowed = True
                    break
            if not allowed:
                return False
        return True

    def _handle_client(self, conn: socket.socket, client_addr):
        if client_addr[0] == "127.0.0.1":
            self._log.warning(
                "👀 LOCAL connection from %s — likely self-initiated",
                client_addr[0],
            )

        try:
            # Для DummySocket в тестах отключаем setsockopt
            if hasattr(conn, "setsockopt"):
                conn.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)

            header = recv_exact(conn, 2)
            self._log.warning(
                "[SNIFF] First 2 bytes from %s:%d: hex=%s ascii=%r",
                client_addr[0],
                client_addr[1],
                header.hex(),
                header,
            )
            proto_guess = None
            if header.startswith(b"PO") or header.startswith(b"GE"):
                proto_guess = "HTTP"
            elif header.startswith(b"\x16\x03"):
                proto_guess = "TLS"
            elif header.startswith(b"CO"):
                proto_guess = "HTTPS proxy (CONNECT)"
            elif header[0] != 0x05:
                proto_guess = "Unknown non-SOCKS"

            if proto_guess:
                self._log.warning(
                    "[GUESS] %s:%d likely using %s instead of SOCKS5",
                    client_addr[0],
                    client_addr[1],
                    proto_guess,
                )
            ver, nmethods = header[0], header[1]
            self._log.info(
                "SOCKS5 handshake header from %s: %s", client_addr[0], header.hex()
            )

            if ver != SOCKS_VERSION:
                self._log.error(
                    "Unsupported SOCKS version %d from %s", ver, client_addr[0]
                )
                conn.close()
                return

            methods = recv_exact(conn, nmethods)
            self._log.info(
                "SOCKS5 methods from %s: %s",
                client_addr[0],
                methods.hex(),
            )

            self._log.debug(
                "[DEBUG] Waiting for SOCKS5 request from %s:%d...",
                client_addr[0],
                client_addr[1],
            )

            if self.auth_required:
                if USER_AUTH not in methods:
                    conn.sendall(bytes([SOCKS_VERSION, NO_ACCEPTABLE]))
                    conn.close()
                    return
                conn.sendall(bytes([SOCKS_VERSION, USER_AUTH]))

                ver_auth = recv_exact(conn, 1)
                if ver_auth[0] != 0x01:
                    conn.close()
                    return

                ulen = recv_exact(conn, 1)[0]
                username = recv_exact(conn, ulen).decode()

                plen = recv_exact(conn, 1)[0]
                password = recv_exact(conn, plen).decode()

                if username != self.auth_credentials.get(
                    "username"
                ) or password != self.auth_credentials.get("password"):
                    conn.sendall(bytes([0x01, 0x01]))
                    self._log.warning(
                        "Authentication failed for %s",
                        client_addr[0],
                    )
                    conn.close()
                    return
                else:
                    conn.sendall(bytes([0x01, 0x00]))
            else:
                if NO_AUTH in methods:
                    conn.sendall(bytes([SOCKS_VERSION, NO_AUTH]))
                else:
                    conn.sendall(bytes([SOCKS_VERSION, NO_ACCEPTABLE]))
                    conn.close()
                    return

            self._log.debug(
                "[DEBUG] Waiting for SOCKS5 request from %s:%d...",
                client_addr[0],
                client_addr[1],
            )

            # Добавь timeout через select (например, 3 секунды)
            ready, _, _ = select.select([conn], [], [], 3)
            if not ready:
                self._log.warning(
                    "[TIMEOUT] Client %s:%d did not send "
                    "SOCKS5 request after handshake",
                    client_addr[0],
                    client_addr[1],
                )
                conn.close()
                return
            request = recv_exact(conn, 4)

            self._log.info(
                "SOCKS5 request header from %s: %s",
                client_addr[0],
                request.hex(),
            )
            ver, cmd, _, atyp = request

            if ver != SOCKS_VERSION:
                self._log.error(
                    "Mismatched SOCKS version in request from %s",
                    client_addr[0],
                )
                conn.close()
                return

            if cmd == CMD_CONNECT:
                self._handle_connect(conn, atyp, client_addr)
            elif cmd == CMD_UDP_ASSOCIATE:
                self._handle_udp_associate(conn, atyp, client_addr)
            else:
                self._send_reply(
                    conn,
                    REP_CMD_NOT_SUPPORTED,
                    bind_ip="0.0.0.0",
                    bind_port=0,
                    atyp=ADDR_IPV4,
                )
                conn.close()

        except ConnectionResetError:
            self._log.warning(
                "Client %s forcibly closed the connection (RST)",
                client_addr[0],
            )
        except EOFError:
            self._log.warning(
                "Client %s closed connection with EOF",
                client_addr[0],
            )
        except Exception as e:
            is_self, who = is_self_connection(
                client_addr[0], client_addr[1], self.config.tcp_port
            )
            if is_self or client_addr[0] == "127.0.0.1":
                self._log.info(
                    "🔁 [LOCAL/SELF] "
                    "Connection from %s "
                    "closed prematurely "
                    "(%s)",
                    client_addr[0],
                    who if is_self else str(e),
                )
            else:
                self._log.error(
                    "Error handling client %s: %s",
                    client_addr[0],
                    e,
                )

        finally:
            try:
                conn.close()
            except Exception:
                pass

    def _handle_connect(self, conn: socket.socket, atyp: int, client_addr):
        """Handle SOCKS5 CONNECT (TCP forwarding)"""
        try:
            dest_addr, dest_port = self._read_dest_address(conn, atyp)
        except Exception as e:
            self._log.error(
                "Failed to parse destination address from %s: %s",
                client_addr[0],
                e,
            )
            rep = (
                REP_ADDR_NOT_SUPPORTED
                if isinstance(e, ValueError)
                else REP_GENERAL_FAILURE
            )
            self._send_reply(
                conn,
                rep,
                bind_ip="0.0.0.0",
                bind_port=0,
                atyp=ADDR_IPV4,
            )
            conn.close()
            return
        # Check against allow/deny rules
        if not self._is_dest_allowed(dest_addr, dest_port):
            self._log.info(
                "Blocked destination %s requested by %s",
                dest_addr,
                client_addr[0],
            )
            self._send_reply(
                conn,
                REP_CONN_NOT_ALLOWED,
                bind_ip="0.0.0.0",
                bind_port=0,
                atyp=ADDR_IPV4,
            )
            conn.close()
            return
        # Create remote socket to target
        remote_family = socket.AF_INET6 if ':' in dest_addr else socket.AF_INET
        try:
            remote_sock = socket.socket(remote_family, socket.SOCK_STREAM)
            remote_sock.connect((dest_addr, dest_port))
        except socket.error as e:
            err_no = getattr(e, 'errno', None)
            if err_no in (111, 61):
                rep = REP_CONN_REFUSED
            elif err_no in (113, 101):
                rep = REP_HOST_UNREACHABLE
            else:
                rep = REP_GENERAL_FAILURE
            self._log.error(
                "TCP Connect to %s:%d failed: %s",
                dest_addr,
                dest_port,
                e,
            )
            self._send_reply(
                conn,
                rep,
                bind_ip="0.0.0.0",
                bind_port=0,
                atyp=ADDR_IPV4,
            )
            conn.close()
            return
        # Connected successfully
        bind_ip, bind_port = remote_sock.getsockname()[:2]
        reply_atyp = ADDR_IPV6 if remote_family == socket.AF_INET6 else ADDR_IPV4
        self._send_reply(
            conn,
            REP_SUCCESS,
            bind_ip=bind_ip,
            bind_port=bind_port,
            atyp=reply_atyp,
        )
        self._log.info(
            "Established TCP tunnel from %s to %s:%d",
            client_addr[0],
            dest_addr,
            dest_port,
        )
        try:
            self._exchange_loop(conn, remote_sock)
        finally:
            remote_sock.close()
            conn.close()
            self._log.info("Closed TCP tunnel for %s", client_addr[0])

    def _handle_udp_associate(
        self,
        conn: socket.socket,
        atyp: int,
        client_addr,
    ):
        """Handle SOCKS5 UDP ASSOCIATE (UDP relay)"""
        try:
            client_ip, client_port = self._read_dest_address(conn, atyp)
        except Exception:
            client_ip, client_port = client_addr[0], 0
        # Determine address and port for UDP relay from config
        bind_ip = self.config.udp_host
        if bind_ip == "0.0.0.0":
            bind_ip = conn.getsockname()[0]
            if bind_ip == "0.0.0.0":
                bind_ip = "0.0.0.0"
        if bind_ip in ("::", "::0", "0:0:0:0:0:0:0:0"):
            local_ip = conn.getsockname()[0]
            if local_ip and local_ip != "::":
                bind_ip = local_ip
            else:
                bind_ip = "::"
        reply_atyp = ADDR_IPV6 if ':' in bind_ip else ADDR_IPV4
        self._send_reply(
            conn,
            REP_SUCCESS,
            bind_ip=bind_ip,
            bind_port=self.config.udp_port,
            atyp=reply_atyp,
        )
        self._log.info(
            "UDP association established with %s, UDP relay port %d",
            client_addr[0],
            self.config.udp_port,
        )
        try:
            conn.recv(1)
        except Exception:
            pass
        conn.close()
        self._log.info("Closed UDP association for %s", client_addr[0])

    def _exchange_loop(
        self,
        client_sock: socket.socket,
        remote_sock: socket.socket,
    ):
        """Relay data between client
        and remote sockets until one side closes."""
        while True:
            rlist, _, _ = select.select([client_sock, remote_sock], [], [])
            if client_sock in rlist:
                data = client_sock.recv(4096)
                if not data:
                    break
                remote_sock.sendall(data)
            if remote_sock in rlist:
                data = remote_sock.recv(4096)
                if not data:
                    break
                client_sock.sendall(data)

    def _send_reply(
        self,
        conn: socket.socket,
        rep: int,
        bind_ip: str,
        bind_port: int,
        atyp: int,
    ):
        """Send a SOCKS5 reply packet
        with given reply code and bind address/port."""
        try:
            if atyp == ADDR_IPV4:
                addr_bytes = socket.inet_aton(bind_ip)
            elif atyp == ADDR_IPV6:
                addr_bytes = socket.inet_pton(socket.AF_INET6, bind_ip)
            elif atyp == ADDR_DOMAIN:
                addr_bytes = bytes([len(bind_ip)]) + bind_ip.encode('utf-8')
            else:
                atyp = ADDR_IPV4
                addr_bytes = b"\x00\x00\x00\x00"
            port_bytes = int(bind_port).to_bytes(2, 'big')
            response = (
                bytes(
                    [
                        SOCKS_VERSION,
                        rep,
                        0x00,
                        atyp,
                    ]
                )
                + addr_bytes
                + port_bytes
            )
            conn.sendall(response)
        except Exception as e:
            self._log.error("Failed to send reply to client: %s", e)

    def _read_dest_address(self, conn: socket.socket, atyp: int):
        """
        Read destination address and port from the client request.
        Returns a tuple (dest_addr, dest_port).
        """
        if atyp == ADDR_IPV4:
            addr_bytes = conn.recv(4)
            if len(addr_bytes) < 4:
                raise IOError("Incomplete IPv4 address")
            dest_addr = socket.inet_ntoa(addr_bytes)
            port_bytes = conn.recv(2)
            if len(port_bytes) < 2:
                raise IOError("Incomplete port")
            dest_port = int.from_bytes(port_bytes, 'big')
            return dest_addr, dest_port
        elif atyp == ADDR_DOMAIN:
            length_byte = conn.recv(1)
            if not length_byte:
                raise IOError("Incomplete domain length")
            length = length_byte[0]
            domain_bytes = conn.recv(length)
            if len(domain_bytes) < length:
                raise IOError("Incomplete domain name")
            dest_domain = domain_bytes.decode('utf-8', 'ignore')
            port_bytes = conn.recv(2)
            if len(port_bytes) < 2:
                raise IOError("Incomplete port")
            dest_port = int.from_bytes(port_bytes, 'big')
            try:
                dest_addr = socket.gethostbyname(dest_domain)
            except Exception as e:
                self._log.warning(
                    "Failed to resolve domain %s: %s",
                    dest_domain,
                    e,
                )
                raise e
            return dest_addr, dest_port
        elif atyp == ADDR_IPV6:
            addr_bytes = conn.recv(16)
            if len(addr_bytes) < 16:
                raise IOError("Incomplete IPv6 address")
            dest_addr = socket.inet_ntop(socket.AF_INET6, addr_bytes)
            port_bytes = conn.recv(2)
            if len(port_bytes) < 2:
                raise IOError("Incomplete port")
            dest_port = int.from_bytes(port_bytes, 'big')
            return dest_addr, dest_port
        else:
            raise ValueError("Unsupported address type %d" % atyp)

# --- ./build/lib/socks5tun/udp_handler.py ---
# udp_handler.py
import socket
import logging
import struct
import threading
from ipaddress import ip_address, ip_network

logger = logging.getLogger("socks5-server")


class UDPHandler:
    def __init__(self, cfg, tun):
        self.cfg = cfg
        self.tun = tun
        self.remote_map = {}
        # Load legacy forbidden networks if present (for compatibility)
        self.forbidden_networks = []
        if hasattr(cfg, "forbidden_networks"):
            for net in cfg.forbidden_networks:
                try:
                    self.forbidden_networks.append(ip_network(net))
                except ValueError:
                    continue

    def _ip_checksum(self, data: bytes) -> int:
        """Calculate IPv4 header checksum."""
        if len(data) % 2 == 1:
            data += b'\x00'
        total = 0
        for i in range(0, len(data), 2):
            word = data[i] << 8 | data[i + 1]
            total += word
        total = (total >> 16) + (total & 0xFFFF)
        total = ~total & 0xFFFF
        return total

    def handle_client_packet(self, data: bytes, client_addr):
        """
        Handle a UDP packet from client (SOCKS5 UDP ASSOCIATE).
        data: raw UDP datagram from client (including SOCKS5 UDP header).
        client_addr: tuple (src_ip, src_port) of the client.
        """
        # Minimum UDP header length is 4 bytes
        if len(data) < 4:
            return
        # Check reserved bytes and fragmentation field
        if data[0] != 0x00 or data[1] != 0x00:
            return  # Invalid reserved field
        frag = data[2]
        if frag != 0x00:
            logger.warning(
                f"Received fragmented UDP packet from {client_addr}, dropping"
            )
            return
        atyp = data[3]
        offset = 4
        dest_addr = None
        dest_port = None
        # Parse destination based on ATYP
        if atyp == 0x01:  # IPv4
            if len(data) < offset + 6:
                return
            dest_addr = socket.inet_ntoa(data[offset : offset + 4])
            offset += 4
            dest_port = struct.unpack("!H", data[offset : offset + 2])[0]
            offset += 2
        elif atyp == 0x03:  # Domain name
            if len(data) < offset + 1:
                return
            name_len = data[offset]
            offset += 1
            if len(data) < offset + name_len + 2:
                return
            dest_name = data[offset : offset + name_len].decode(
                'ascii', errors='ignore'
            )
            offset += name_len
            dest_port = struct.unpack("!H", data[offset : offset + 2])[0]
            offset += 2
            # Resolve domain to IP
            if getattr(self.cfg, "dns_resolver", "system") == "system":
                try:
                    addrs = socket.getaddrinfo(
                        dest_name, dest_port, proto=socket.IPPROTO_UDP
                    )
                except Exception:
                    logger.warning(
                        f"[UDP-DENY ] {client_addr[0]}:{client_addr[1]}"
                        f" → {dest_name}:{dest_port} reason=resolve_fail"
                    )
                    return
            else:
                try:
                    addrs = socket.getaddrinfo(
                        dest_name, dest_port, proto=socket.IPPROTO_UDP
                    )
                except Exception:
                    logger.warning(
                        f"[UDP-DENY ] {client_addr[0]}:{client_addr[1]}"
                        f" → {dest_name}:{dest_port} reason=resolve_fail"
                    )
                    return
            if not addrs:
                logger.warning(
                    f"[UDP-DENY ] {client_addr[0]}:{client_addr[1]}"
                    f" → {dest_name}:{dest_port} reason=resolve_fail"
                )
                return
            dest_addr = addrs[0][4][0]
        elif atyp == 0x04:  # IPv6
            if len(data) < offset + 18:
                return
            try:
                dest_addr = socket.inet_ntop(
                    socket.AF_INET6, data[offset : offset + 16]
                )
            except OSError:
                return
            offset += 16
            dest_port = struct.unpack("!H", data[offset : offset + 2])[0]
            offset += 2
        else:
            return
        payload = data[offset:]
        if dest_addr is None:
            return
        # Apply allow/deny filtering
        allowed = True
        reason = "deny_rule"
        try:
            ip_obj = ip_address(dest_addr)
        except ValueError:
            ip_obj = None
        if ip_obj:
            # Check deny rules
            for net, port in getattr(self.cfg, "deny_rules", []):
                if ip_obj in net and (port is None or dest_port == port):
                    allowed = False
                    break

            # Check legacy forbidden networks if no explicit deny rules
            if allowed and not getattr(self.cfg, "deny_rules", []):
                for net in self.forbidden_networks:
                    if ip_obj in net:
                        allowed = False
                        break

            # Check allow rules
            if allowed and getattr(self.cfg, "allow_rules", []):
                matched = False
                for net, port in self.cfg.allow_rules:
                    if ip_obj in net and (port is None or dest_port == port):
                        matched = True
                        break
                if not matched:
                    allowed = False
        else:
            allowed = False
        if not allowed:
            logger.warning(
                f"[UDP-DENY ] {client_addr[0]}:{client_addr[1]}"
                f" → {dest_addr}:{dest_port} reason={reason}"
            )
            return
        # Build packet and forward to TUN (IPv4 only)
        ip_obj = ip_address(dest_addr)
        if ip_obj.version == 4:
            src_ip = client_addr[0]
            src_port = client_addr[1] & 0xFFFF
            dst_ip = dest_addr
            # IPv4 header
            version = 4
            ihl = 5
            ver_ihl = (version << 4) + ihl
            tos = 0
            total_length = 20 + 8 + len(payload)
            identification = 0
            flags_offset = 0
            ttl = 64
            protocol = socket.IPPROTO_UDP
            src_ip_bytes = socket.inet_aton(src_ip)
            dst_ip_bytes = socket.inet_aton(dst_ip)
            # Initial header with zero checksum
            ip_header = struct.pack(
                "!BBHHHBBH4s4s",
                ver_ihl,
                tos,
                total_length,
                identification,
                flags_offset,
                ttl,
                protocol,
                0,
                src_ip_bytes,
                dst_ip_bytes,
            )
            checksum = self._ip_checksum(ip_header)
            # Final IP header with checksum
            ip_header = struct.pack(
                "!BBHHHBBH4s4s",
                ver_ihl,
                tos,
                total_length,
                identification,
                flags_offset,
                ttl,
                protocol,
                checksum,
                src_ip_bytes,
                dst_ip_bytes,
            )
            # UDP header
            dst_port_net = dest_port & 0xFFFF
            udp_length = 8 + len(payload)
            udp_header = struct.pack(
                "!HHHH",
                src_port,
                dst_port_net,
                udp_length,
                0,
            )
            packet = ip_header + udp_header + payload
            self.tun.write(packet)
            self.remote_map[(dest_addr, dest_port)] = client_addr
        elif ip_obj.version == 6:
            logger.warning(
                f"Cannot forward UDP to IPv6 address"
                f" {dest_addr} "
                f"(not supported)"
            )
            return
        else:
            return
        # Log forwarded packet as allowed
        logger.info(
            f"[UDP-ALLOW] {client_addr[0]}:{client_addr[1]}"
            f" → {dest_addr}:{dest_port} len={len(payload)}"
        )


def start_udp_loop(cfg, tun):
    """
    Start a loop to handle global UDP relay.
    Listens on cfg.udp_host:cfg.udp_port for UDP traffic.
    """
    family = socket.AF_INET6 if ':' in cfg.udp_host else socket.AF_INET
    udp_sock = socket.socket(family, socket.SOCK_DGRAM)
    logger.debug("[BOOT] Entered start_udp_loop()")
    try:
        udp_sock.bind((cfg.udp_host, cfg.udp_port))
    except OSError as e:
        logger.error(
            "Failed to bind UDP socket on %s:%d — %s",
            cfg.udp_host,
            cfg.udp_port,
            e,
        )
        return

    logger.info(
        "[DEBUG] Bound UDP socket on %s:%d",
        cfg.udp_host,
        cfg.udp_port,
    )
    logger.info(f"UDP relay socket listening on {cfg.udp_host}:{cfg.udp_port}")
    # Mapping for direct UDP mode (dest -> client)
    remote_map = {}
    # Handler for client packets
    handler = UDPHandler(cfg, tun)
    handler.remote_map = remote_map
    # If TUN interface is available, start thread to handle incoming packets from TUN
    if tun:

        def tun_reader():
            while True:
                try:
                    packet = tun.read()
                except Exception as e:
                    logger.error("UDP tun read error: %s", e)
                    break
                if not packet:
                    break
                # Only handle IPv4 UDP packets from tun
                if len(packet) < 20:
                    continue
                version = packet[0] >> 4
                if version != 4:
                    # Only IPv4 supported for now
                    continue
                proto = packet[9]
                if proto != socket.IPPROTO_UDP:
                    continue
                src_ip = socket.inet_ntoa(packet[12:16])
                dst_ip = socket.inet_ntoa(packet[16:20])
                src_port = int.from_bytes(packet[20:22], 'big')
                dst_port = int.from_bytes(packet[22:24], 'big')
                payload = packet[28:]
                client_key = (src_ip, src_port)
                # If we have a client for this dest, forward to it
                if client_key in remote_map:
                    client_addr = remote_map[client_key]
                else:
                    # No mapping, drop
                    logger.warning(
                        f"Received UDP packet from {src_ip}:{src_port} with "
                        "no client mapping for {dst_ip}:{dst_port}"
                    )
                    continue
                # Build SOCKS UDP response
                try:
                    if ':' in src_ip:
                        addr_bytes = socket.inet_pton(socket.AF_INET6, src_ip)
                        resp_atyp = 0x04
                    else:
                        addr_bytes = socket.inet_aton(src_ip)
                        resp_atyp = 0x01
                    port_bytes = src_port.to_bytes(2, 'big')
                    resp_header = (
                        b"\x00\x00\x00" + bytes([resp_atyp]) + addr_bytes + port_bytes
                    )
                except Exception as e:
                    logger.error(
                        "Failed to build UDP response header for %s: %s", src_ip, e
                    )
                    continue
                response_data = resp_header + payload
                try:
                    udp_sock.sendto(response_data, client_addr)
                except Exception as e:
                    logger.error(
                        "Failed to send UDP packet to client %s:%d - %s",
                        client_addr[0],
                        client_addr[1],
                        e,
                    )

        threading.Thread(target=tun_reader, daemon=True).start()
    # Main loop to handle incoming UDP datagrams on socket
    logger.debug("[BOOT] Entering UDP receive loop...")

    while True:
        try:
            logger.debug("[LOOP] Waiting for UDP packet...")
            data, addr = udp_sock.recvfrom(65535)
            logger.debug(
                "[TRACE] --- UDP packet received from %s:%d ---",
                addr[0],
                addr[1],
            )

            logger.debug(
                "[DEBUG] Got UDP from %s:%d, len=%d",
                addr[0],
                addr[1],
                len(data),
            )
            client_ip, client_port = addr[0], addr[1]
            try:
                ip_obj = ip_address(client_ip)
            except ValueError:
                ip_obj = None
            is_client = ip_obj is not None and any(
                ip_obj in net for net in cfg.allowed_clients
            )

            # ✅ ДОПОЛНИТЕЛЬНЫЕ ЛОГИ
            logger.debug("[TRACE] UDP packet from: %s:%d", client_ip, client_port)
            logger.debug("[TRACE] Evaluated ip_obj: %s", ip_obj)
            logger.debug("[TRACE] allowed_clients: %s", cfg.allowed_clients)
            logger.debug("[TRACE] is_client: %s", is_client)

        except Exception as e:
            logger.error("UDP socket error: %s", e)
            break
        client_ip, client_port = addr[0], addr[1]
        try:
            ip_obj = ip_address(client_ip)
        except ValueError:
            ip_obj = None
        is_client = ip_obj is not None and any(
            ip_obj in net for net in cfg.allowed_clients
        )
        logger.debug("[CHECK] Incoming UDP from %s:%d", client_ip, client_port)
        logger.debug("[CHECK] allowed_clients = %s", cfg.allowed_clients)
        logger.debug("[CHECK] ip_obj = %s", ip_obj)
        logger.debug("[CHECK] is_client = %s", is_client)

        if is_client:
            # UDP datagram from an allowed client
            if tun:
                logger.debug(
                    "[DEBUG] handle_client_packet from %s:%d, raw: %s",
                    addr[0],
                    addr[1],
                    data.hex(),
                )
                try:
                    handler.handle_client_packet(data, addr)
                except Exception as e:
                    logger.error("Exception in handle_client_packet: %s", e)

            else:
                # Handle direct UDP forward (no TUN)

                if len(data) < 4:
                    continue
                if data[0] != 0x00 or data[1] != 0x00:
                    continue
                frag = data[2]
                if frag != 0x00:
                    continue
                atyp = data[3]
                off = 4
                dest_addr = None
                dest_port = None
                if atyp == 0x01:
                    if len(data) < off + 6:
                        continue
                    dest_addr = socket.inet_ntoa(data[off : off + 4])
                    off += 4
                    dest_port = int.from_bytes(data[off : off + 2], 'big')
                    off += 2
                elif atyp == 0x03:
                    if len(data) < off + 1:
                        continue
                    name_len = data[off]
                    off += 1
                    if len(data) < off + name_len + 2:
                        continue
                    dest_name = data[off : off + name_len].decode(
                        'ascii', errors='ignore'
                    )
                    off += name_len
                    dest_port = int.from_bytes(data[off : off + 2], 'big')
                    off += 2
                    try:
                        dest_addr = socket.gethostbyname(dest_name)
                    except Exception as e:
                        logger.warning(
                            f"[UDP-DENY ] {client_ip}:{client_port}"
                            f" → {dest_name}:{dest_port} reason=resolve_fail"
                        )
                        continue
                elif atyp == 0x04:
                    if len(data) < off + 18:
                        continue
                    try:
                        dest_addr = socket.inet_ntop(
                            socket.AF_INET6, data[off : off + 16]
                        )
                    except OSError:
                        continue
                    off += 16
                    dest_port = int.from_bytes(data[off : off + 2], 'big')
                    off += 2
                else:
                    continue
                payload = data[off:]
                if dest_addr is None:
                    continue
                # Filtering
                allowed = True
                reason = "deny_rule"
                try:
                    dest_ip_obj = ip_address(dest_addr)
                except ValueError:
                    dest_ip_obj = None
                if dest_ip_obj:
                    for net, port in getattr(cfg, "deny_rules", []):
                        if dest_ip_obj in net and (port is None or dest_port == port):
                            allowed = False
                            break
                    if allowed and getattr(cfg, "allow_rules", []):
                        match = False
                        for net, port in cfg.allow_rules:
                            if dest_ip_obj in net and (
                                port is None or dest_port == port
                            ):
                                match = True
                                break
                        if not match:
                            allowed = False
                else:
                    allowed = False
                if not allowed:
                    logger.warning(
                        f"[UDP-DENY ] {client_ip}:{client_port}"
                        f" → {dest_addr}:{dest_port} reason={reason}"
                    )
                    continue
                # Forward to remote
                try:
                    logger.debug(
                        "[SEND] Sending UDP to %s:%d (payload %d bytes): %s",
                        dest_addr,
                        dest_port,
                        len(payload),
                        payload.hex(),
                    )
                    udp_sock.sendto(payload, (dest_addr, dest_port))
                except Exception as e:
                    logger.error(
                        "Failed to relay UDP to %s:%d - %s",
                        dest_addr,
                        dest_port,
                        e,
                    )
                    continue
                # Update mapping for return traffic
                remote_map[(dest_addr, dest_port)] = addr
                logger.info(
                    f"[UDP-ALLOW] {client_ip}:{client_port}"
                    f" → {dest_addr}:{dest_port} len={len(payload)}"
                )
        else:
            # UDP datagram from remote host
            logger.debug(
                "[REJECT] UDP from %s:%d rejected: not in allowed_clients",
                client_ip,
                client_port,
            )
            if tun:
                # Should not happen (remote replies handled via tun), ignore
                continue
            # Direct mode: relay back to client if known
            remote_ip, remote_port = client_ip, client_port
            if (remote_ip, remote_port) not in remote_map:
                continue
            client_addr = remote_map[(remote_ip, remote_port)]
            # Build SOCKS UDP response
            try:
                if ':' in remote_ip:
                    addr_bytes = socket.inet_pton(socket.AF_INET6, remote_ip)
                    resp_atyp = 0x04
                else:
                    addr_bytes = socket.inet_aton(remote_ip)
                    resp_atyp = 0x01
                port_bytes = remote_port.to_bytes(2, 'big')
                resp_header = (
                    b"\x00\x00\x00" + bytes([resp_atyp]) + addr_bytes + port_bytes
                )
            except Exception as e:
                logger.error(
                    "Failed to build UDP response header for %s: %s",
                    remote_ip,
                    e,
                )
                continue
            response_data = resp_header + data
            udp_sock.sendto(response_data, client_addr)

# --- ./README.md ---
## Логирование UDP-трафика

По умолчанию приложение логирует весь UDP-трафик — как **разрешённый**, так и **заблокированный**.

- Разрешённые UDP-пакеты записываются в журнал уровня INFO с префиксом `[UDP-ALLOW]`. В сообщении указываются исходный адрес:порт клиента, адрес:порт назначения и размер переданных данных.
- Заблокированные UDP-пакеты записываются в журнал уровня WARNING с префиксом `[UDP-DENY ]`. В сообщении указываются исходный адрес:порт клиента, адрес:порт назначения и причина блокировки (например, `reason=deny_rule`).

Пример фрагмента журнала UDP-трафика:

```text
[UDP-ALLOW] 192.0.2.10:39522 → 8.8.8.8:53 len=42
[UDP-DENY ] 10.0.0.5:60234 → 192.168.0.1:80 reason=deny_rule
```

---

## Автосетап TUN/NAT

Если в конфигурационном файле (`config.json`) заданы параметры блоков:

```json
"tun": {
  "name": "tun0",
  "address": "10.8.0.1",
  "netmask": "255.255.255.0",
  "peer_address": "10.8.0.2",
  "mtu": 1500
},
"nat": {
  "out_iface": "eth0"
}
```

то при старте сервера **TUN‑интерфейс** и **NAT‑правила** будут настраиваться автоматически.

- Автосетап выполняется **только**, если процесс запущен с правами `root` (`UID 0`).
- В тестовом или CI‑окружении, где нет root‑доступа, авто‑сетап будет пропущен, и в логах появится предупреждение:

```text
[WARNING] Skipping TUN/NAT auto-setup: not running as root (UID != 0)
```

---

## Базовая настройка брандмауэра (UFW)

Для ограничения внешнего доступа рекомендуется разрешить только необходимые порты:

```bash
ufw default deny incoming
ufw default allow outgoing
ufw allow 22/tcp comment "SSH"
ufw allow 443/tcp comment "TLS (stunnel)"
ufw enable
```

- Это закроет все входящие соединения, кроме SSH и TLS‑порта, используемого stunnel.
- Порт SOCKS5 (например, 5000/tcp), на котором слушает Python‑сервер, при этом будет доступен **только локально** (127.0.0.1) и через stunnel.
- Если требуется прямой внешний доступ к SOCKS5, добавьте правило:

```bash
ufw allow 5000/tcp comment "SOCKS5 direct"
```

---

## Мини-бэкап конфигураций `/etc`

Для автоматического отслеживания и возможности отката изменений в системных конфигурациях `/etc` рекомендуется установить:

```bash
sudo apt install -y etckeeper
cd /etc
sudo etckeeper init
sudo etckeeper commit -m "Initial server snapshot"
```

Теперь изменения `/etc` будут отслеживаться с помощью Git. Это удобно при ручной настройке `ufw`, `ssh`, `resolv.conf`, и т.д.

---

## Потенциальное улучшение: базовая защита SSH

Для повышения безопасности SSH можно добавить отдельный файл настроек `/etc/ssh/sshd_config.d/hardening.conf`:

```conf
PermitRootLogin no
PasswordAuthentication no
ClientAliveInterval 300
ClientAliveCountMax 2
```

- **PermitRootLogin no** — запрет входа под root по SSH.
- **PasswordAuthentication no** — отключение входа по паролю (только по SSH-ключу).
- **ClientAliveInterval** и **ClientAliveCountMax** — автоматическое завершение сессий при отсутствии активности.

> ⚠️ Перед применением убедитесь, что у вас есть рабочая учётная запись с ключом SSH и правами `sudo`.
> Рекомендуется сначала протестировать вход в новой сессии, и только потом закрывать текущую.

## Потенциальное улучшение: максимальная изоляция `stunnel`

В будущем возможно реализовать запуск `stunnel` с усиленной безопасностью. Это актуально при открытом или публичном VPN-сервисе с несколькими пользователями.

### ✅ Отдельный системный пользователь

```bash
sudo adduser --system --group --no-create-home stunnel
sudo chown root:stunnel /etc/stunnel
sudo chmod 750 /etc/stunnel
sudo chown root:stunnel /etc/stunnel/stunnel.pem
sudo chmod 640 /etc/stunnel/stunnel.pem
```

### ✅ Вынос PID-файла в безопасное место

```ini
pid = /run/stunnel/stunnel.pid
```

### ✅ Создание каталога и прав на него

```bash
sudo mkdir -p /run/stunnel
sudo chown stunnel:stunnel /run/stunnel
```

### ✅ Выдача capability для портов < 1024

```bash
sudo setcap 'cap_net_bind_service=+ep' /usr/bin/stunnel
```

### ✅ Защита через systemd (в unit-файле)

```ini
NoNewPrivileges=true
ProtectSystem=full
ReadOnlyPaths=/etc/stunnel
```

### 🧱 (опционально) chroot

Если требуется полная изоляция файловой системы (FS), возможно использование `chroot` — но это требует ручной подготовки окружения (библиотек, /dev/null и т.п.).

> Эти меры изолируют `stunnel` от остальной системы, даже если произойдёт взлом или утечка ключей.

Применить изменения:

```bash
sudo systemctl restart ssh
```

---

## Обновление и управление сервисом SOCKS5TUN

Проект включает встроенную систему обновления и перезапуска через связку:

- `update_socks5tun` — исполняемый скрипт/модуль, отвечающий за загрузку, установку или замену кода проекта.
- `socks5tun-update.service` — вспомогательный systemd-сервис, выполняющий `update_socks5tun` перед запуском основного прокси.
- `socks5tun.service` — основной сервис, запускающий SOCKS5-прокси сервер.

### Схема запуска

1. При запуске `socks5tun.service` автоматически **выполняется `socks5tun-update.service`**, если он указан как `Requires` + `After` в `Unit`-блоке.
2. Только **после успешного завершения обновления** стартует основной сервер.

Такой подход гарантирует, что при перезапуске системы или сервиса будет использоваться **актуальная версия** кода.

### Вручную

Для ручного запуска без обновления:

```bash
sudo systemctl start socks5tun.service
```

Для запуска только обновления (без старта прокси):

```bash
sudo systemctl start socks5tun-update.service
```

Для выполнения обновления вручную (если `update_socks5tun` — исполняемый файл):

```bash
sudo /usr/local/bin/update_socks5tun
```

---

## Работа с systemd

После изменения `.service`‑файлов **не забудьте перезагрузить systemd**:

```bash
sudo systemctl daemon-reload
```

Перезапуск сервиса:

```bash
sudo systemctl restart socks5tun.service
```

Просмотр логов:

```bash
journalctl -u socks5tun.service -f
```

Если вы изменили только Python‑код (`*.py`) — `daemon-reload` **не требуется**, достаточно `restart`.

---

## Размещение файлов

- `update_socks5tun` должен быть исполняемым (`chmod +x`) и доступным в PATH или по абсолютному пути (например, `/usr/local/bin/`).
- Юнит‑файлы systemd обычно размещаются в `/etc/systemd/system/`:

```bash
/etc/systemd/system/socks5tun.service
/etc/systemd/system/socks5tun-update.service
```

Проверь, чтобы они были включены в автозагрузку:

```bash
sudo systemctl enable socks5tun.service
```

> Обновление не выполняется, если сервис запускается напрямую (`python run.py`) — только через systemd.

# --- ./setup.py ---
from setuptools import setup, find_packages

setup(
    name="socks5tun",
    version="0.1",
    packages=find_packages(),  # автоматически найдёт socks5tun/
    include_package_data=True,
    python_requires=">=3.8",
)
[32m[INFO] === MISC FILES ===(B[m

# --- ./help.txt ---
# Активировать окружение на сервере:
source /opt/venv-pyroute/bin/activate

# Архивировать папку tests
zip -r tests_with_ci.zip tests .github/workflows/test.yml

# Создать txt файл с содержимым test + ДЕРЕВО
./diagnostics/collect_tests.sh


### Запуск проекта:
## Запуска через автомат

# перезапуск systemd, если были обновления systemd
sudo systemctl daemon-reexec

# обновляет конфигурацию systemd (нужно после изменения .service файла)
sudo systemctl daemon-reload

# перезапуск проекта
sudo systemctl restart socks5tun.service

# логи он-лайн
sudo journalctl -fu socks5tun.service

## Запуск вручную
# Тестовый запуск проекта
python -m socks5tun.run -c config_dev.json

# Рабочий запуск
python -m socks5tun.run


### Прочее
# stunnel на сервере
sudo nano /etc/stunnel/stunnel.conf

# Запустить тесты
pytest -q

# Вернутся в проект
cd ~/socks5tun
# --- ./config_dev.json ---
{
    "tcp_host": "127.0.0.1",
    "tcp_port": 1080,
    "udp_host": "127.0.0.1",
    "udp_port": 1080,
    "tun_mode": "dummy",
    "log_level": "INFO",
    "auth": null,
    "allowed_clients": [
        "127.0.0.1/32"
    ],
    "blocked_destinations": [
        "0.0.0.0/8",
        "10.0.0.0/8",
        "127.0.0.0/8",
        "169.254.0.0/16",
        "172.16.0.0/12",
        "192.168.0.0/16",
        "240.0.0.0/4"
    ],
    "dns_resolver": "system"
}
# --- ./.github/workflows/test.yml ---
name: CI
on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  tests:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: [3.12]
    steps:
      - uses: actions/checkout@v3
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      - name: Run tests
        run: pytest

# --- ./config_prod.json ---
{
  "tcp_host": "0.0.0.0",
  "tcp_port": 5000,
  "udp_host": "0.0.0.0",
  "udp_port": 5000,
  "tun_mode": "linux",
  "log_level": "DEBUG",

  "tun": {
    "name": "tun0",
    "address": "10.8.0.1",
    "netmask": "255.255.255.0",
    "peer_address": "10.8.0.2",
    "mtu": 1500
  },

  "nat": {
    "out_iface": "eth0"
  },

  "auth": null,
  "allowed_clients": ["0.0.0.0/0"],
  "blocked_destinations": [
    "0.0.0.0/8", "10.0.0.0/8", "127.0.0.0/8",
    "169.254.0.0/16", "172.16.0.0/12", "192.168.0.0/16",
    "240.0.0.0/4"
  ],
  "dns_resolver": "system",
  "self_check": true
}

# --- ./build/lib/socks5tun/dummy_tun.py ---
"""
Dummy TUN interface for simulating a TUN device.
"""

import threading
import traceback
import logging
from collections import deque


class DummyTun:
    """
    A dummy TUN interface that mimics a TUN device for testing or environments
    where a real TUN device is not available.
    Data written to this dummy interface
    is stored, and data can be injected for reading.
    """

    def __init__(self):
        # Queues for incoming (to be read) and outgoing (written) data
        self._incoming_data = deque()
        self._outgoing_data = deque()
        self._lock = threading.Lock()
        # Conditions to wait for data availability
        self._incoming_cond = threading.Condition(self._lock)
        self._outgoing_cond = threading.Condition(self._lock)
        self.active = False

    def open(self):
        """
        Open/initialize the dummy TUN interface.
        (For a real TUN, this would create the TUN device.
        Here we just mark it active.)
        """
        with self._lock:
            self.active = True

    def read(self, size: int = 1500) -> bytes:
        """
        Read data from the dummy TUN interface
        (blocking until data is available or interface is closed).
        Returns bytes of data, or b'' if the interface is closed.
        """
        with self._incoming_cond:
            # Wait until data is available or the interface becomes inactive
            while not self._incoming_data and self.active:
                self._incoming_cond.wait()
            if not self.active and not self._incoming_data:
                # Interface closed and no data remaining
                return b""
            data = self._incoming_data.popleft()
        # Return up to 'size' bytes from the data (simulate reading a packet)
        if size and len(data) > size:
            remaining = data[size:]
            # Put the remaining back to be read next time
            with self._incoming_cond:
                self._incoming_data.appendleft(remaining)
            return data[:size]
        else:
            return data

    def write(self, data: bytes) -> int:
        """
        Write data to the dummy TUN interface.
        (For a real TUN, this would send the packet into the OS network stack.)
        Here we store it in an outgoing queue for inspection.
        Returns the number of bytes written.
        """
        if logging.getLogger().isEnabledFor(logging.DEBUG):
            print("🔄 DummyTun.write() called by:")
            traceback.print_stack(limit=5)
        traceback.print_stack(limit=5)
        with self._outgoing_cond:
            self._outgoing_data.append(data)
            # Notify any waiters for outgoing data (if used in tests)
            self._outgoing_cond.notify_all()
        return len(data)

    def inject(self, data: bytes):
        """
        Inject data into the dummy TUN interface as
        if it was received from the network.
        This data will be available to read() by the server.
        """
        with self._incoming_cond:
            self._incoming_data.append(data)
            # Notify any thread waiting for incoming data
            self._incoming_cond.notify_all()

    def close(self):
        """
        Close the dummy TUN interface.
        """
        with self._incoming_cond:
            self.active = False
            # Wake up any waiting readers so they can stop
            self._incoming_cond.notify_all()

# --- ./build/lib/socks5tun/config.py ---
"""
Configuration handling for Socks5 proxy server.
"""

import json
import ipaddress


class Config:
    """
    Holds configuration for the Socks5 server.
    """

    def __init__(self, data: dict):
        # TCP and UDP listening addresses and ports
        self.tcp_host: str = data.get("tcp_host", "127.0.0.1")
        self.tcp_port: int = data.get("tcp_port", 1080)
        self.udp_host: str = data.get("udp_host", "127.0.0.1")
        self.udp_port: int = data.get("udp_port", 1080)
        # Full tun/nat configs for easier access
        self.tun = data.get("tun", {})
        self.nat = data.get("nat", {})
        # TUN interface mode (default "dummy")
        self.tun_mode: str = data.get("tun_mode", "dummy")
        self.dns_resolver = data.get("dns_resolver", "system")
        # Logging level
        self.log_level: str = data.get("log_level", "INFO").upper()
        # Authentication credentials (if any)
        auth_data = data.get("auth")
        if (
            auth_data
            and isinstance(auth_data, dict)
            and "username" in auth_data
            and "password" in auth_data
        ):
            self.auth = {
                "username": auth_data["username"],
                "password": auth_data["password"],
            }
        else:
            self.auth = None
        # Allowed client networks
        allowed_list = data.get("allowed_clients", ["0.0.0.0/0"])
        self.allowed_clients = [ipaddress.ip_network(net) for net in allowed_list]
        # Blocked destination networks
        blocked_list = data.get("blocked_destinations", [])
        self.blocked_destinations = [ipaddress.ip_network(net) for net in blocked_list]
        # Backward compatibility
        self.forbidden_networks = data.get("forbidden_networks", [])
        self.blocked_destinations = [
            ipaddress.ip_network(net)
            for net in data.get(
                "blocked_destinations",
                [],
            )
        ]
        self.deny_rules = [(net, None) for net in self.blocked_destinations]
        self.allow_rules = []


def load_config(path: str) -> Config:
    """
    Load configuration from a JSON file and return a Config object.
    Raises FileNotFoundError if file is not found,
    or ValueError if JSON is invalid or contents are not as expected.
    """
    try:
        with open(path, "r") as f:
            data = json.load(f)
    except FileNotFoundError:
        raise
    except json.JSONDecodeError as e:
        raise ValueError(f"Invalid JSON configuration: {e}")

    # Backward compatibility for old keys
    if "tun" in data:
        if "tun_mode" not in data:
            data["tun_mode"] = "linux" if data["tun"] else "disabled"
        data.pop("tun", None)
    if "bind_host" in data or "bind_port" in data:
        raise ValueError(
            "Outdated config keys 'bind_host'/'bind_port' detected; "
            "use 'tcp_host'/'tcp_port' instead."
        )

    # Validate required field types and values
    if "tcp_host" in data and not isinstance(data["tcp_host"], str):
        raise ValueError("tcp_host must be a string")
    if "tcp_port" in data and not isinstance(data["tcp_port"], int):
        raise ValueError("tcp_port must be an integer")
    if "udp_host" in data and not isinstance(data["udp_host"], str):
        raise ValueError("udp_host must be a string")
    if "udp_port" in data and not isinstance(data["udp_port"], int):
        raise ValueError("udp_port must be an integer")
    if "tun_mode" in data:
        if not isinstance(data["tun_mode"], str):
            raise ValueError("tun_mode must be a string")
        if data["tun_mode"] not in {"dummy", "linux", "disabled"}:
            raise ValueError(
                "tun_mode must be one of: 'dummy', " "'linux', or 'disabled'"
            )
    if "log_level" in data and not isinstance(data["log_level"], str):
        raise ValueError("log_level must be a string")
    if "allowed_clients" in data and not isinstance(
        data["allowed_clients"],
        list,
    ):
        raise ValueError("allowed_clients must be a list of network strings")
    if "blocked_destinations" in data and not isinstance(
        data["blocked_destinations"], list
    ):
        raise ValueError(
            "blocked_destinations " "must be " "a list of network " "strings"
        )
    if "auth" in data:
        if data["auth"] is not None:
            if not (
                isinstance(data["auth"], dict)
                and "username" in data["auth"]
                and "password" in data["auth"]
            ):
                raise ValueError(
                    "auth must be an "
                    "object with 'username' "
                    "and 'password', or null"
                )

    # Create and return Config object
    return Config(data)

# --- ./build/lib/socks5tun/logger.py ---
"""
Logging configuration for Socks5 proxy server.
"""
import logging

def setup_logging(level: str):
    """
    Configure logging for the proxy server with the given level.
    """
    # Convert level name to numeric value (default to INFO if unrecognized)
    numeric_level = getattr(logging, level.upper(), logging.INFO)
    logging.basicConfig(
        level=numeric_level,
        format="%(asctime)s [%(levelname)s] [%(threadName)s] %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S"
    )
    # Optionally, adjust logging levels for third-party libraries if needed
    logging.getLogger("urllib3").setLevel(logging.WARNING)

# --- ./build/lib/socks5tun/__init__.py ---

# --- ./build/lib/socks5tun/run.py ---
# run.py
# !/usr/bin/env python3
"""
Entry point for the Socks5 proxy server.
"""
import argparse
import logging
import os
import sys
import threading
import subprocess
import json
import fcntl
import struct
from datetime import datetime

from socks5tun.config import load_config
from socks5tun.logger import setup_logging
from socks5tun.server import SocksServer

logger = logging.getLogger(__name__)


def main():
    parser = argparse.ArgumentParser(description="Socks5 Proxy Server")
    parser.add_argument(
        "-c",
        "--config",
        default="config_prod.json",
        help="Path to configuration JSON file",
    )
    args = parser.parse_args()
    try:
        cfg = load_config(args.config)

    except FileNotFoundError:
        logger.error("Configuration file not found: %s", args.config)
        sys.exit(1)
    except ValueError as e:
        logger.error("Error in configuration: %s", e)
        sys.exit(1)

    # Setup logging with level from config
    setup_logging(cfg.log_level)
    log = logging.getLogger("socks5-server")

    from ipaddress import ip_network

    cfg.allowed_clients = [ip_network(net) for net in cfg.allowed_clients]
    logger.debug(">> allowed_clients converted to: %s", cfg.allowed_clients)

    cfg.blocked_destinations = [ip_network(net) for net in cfg.blocked_destinations]

    if hasattr(cfg, "deny_rules"):
        cfg.deny_rules = [(ip_network(net), port) for net, port in cfg.deny_rules]
        log.debug(">> deny_rules converted to: %s", cfg.deny_rules)

    if hasattr(cfg, "allow_rules"):
        cfg.allow_rules = [(ip_network(net), port) for net, port in cfg.allow_rules]
        log.debug(">> allow_rules converted to: %s", cfg.allow_rules)

    log.info(
        "Starting Socks5 proxy server on %s:%d",
        cfg.tcp_host,
        cfg.tcp_port,
    )
    # If TUN interface is enabled in config, open it
    tun = None
    if cfg.tun_mode:
        try:
            if cfg.tun_mode == "dummy":
                from socks5tun.dummy_tun import DummyTun

                tun = DummyTun()
                tun.open()
                log.info(
                    "Dummy TUN interface opened "
                    "(not connected to "
                    "system network)",
                )
            elif cfg.tun_mode == "linux":

                TUNSETIFF = 0x400454CA
                IFF_TUN = 0x0001
                IFF_NO_PI = 0x1000
                tun_fd = os.open("/dev/net/tun", os.O_RDWR)
                ifs = fcntl.ioctl(
                    tun_fd,
                    TUNSETIFF,
                    struct.pack("16sH", b"tun%d", IFF_TUN | IFF_NO_PI),
                )
                tun_name = ifs[:16].strip(b"\x00").decode('utf-8')
                log.info("🔧 Created TUN interface with name: %s", tun_name)

                class LinuxTun:
                    def __init__(self, fd):
                        self.fd = fd

                    def read(self, size: int = 1500):
                        return os.read(self.fd, size)

                    def write(self, data: bytes):
                        return os.write(self.fd, data)

                    def close(self):
                        os.close(self.fd)

                tun = LinuxTun(tun_fd)
                log.info("Linux TUN interface %s opened", tun_name)

                # --- NEW: авто-конфигурация интерфейса и NAT ---

                if os.geteuid() == 0:
                    tun_ip = cfg.tun.get("address", "10.8.0.1")
                    tun_netmask = cfg.tun.get("netmask", "255.255.255.0")
                    peer_ip = cfg.tun.get("peer_address", "10.8.0.2")
                    mtu = cfg.tun.get("mtu", 1500)
                    out_iface = cfg.nat.get("out_iface")

                    try:
                        subprocess.run(
                            [
                                "ip",
                                "addr",
                                "add",
                                f"{tun_ip}/{tun_netmask}",
                                "peer",
                                peer_ip,
                                "dev",
                                tun_name,
                            ],
                            check=True,
                        )
                        subprocess.run(
                            ["ip", "link", "set", tun_name, "mtu", str(mtu)],
                            check=True,
                        )
                        subprocess.run(
                            ["ip", "link", "set", tun_name, "up"],
                            check=True,
                        )
                        log.info(
                            "Configured IP %s peer %s mtu %s on %s",
                            tun_ip,
                            peer_ip,
                            mtu,
                            tun_name,
                        )
                        # Включаем форвардинг
                        with open("/proc/sys/net/ipv4/ip_forward", "w") as f:
                            f.write("1\n")
                        if out_iface:
                            subprocess.run(
                                [
                                    "iptables",
                                    "-t",
                                    "nat",
                                    "-C",
                                    "POSTROUTING",
                                    "-s",
                                    f"{tun_ip}/{tun_netmask}",
                                    "-o",
                                    out_iface,
                                    "-j",
                                    "MASQUERADE",
                                ],
                                check=False,
                            )
                            subprocess.run(
                                [
                                    "iptables",
                                    "-t",
                                    "nat",
                                    "-A",
                                    "POSTROUTING",
                                    "-s",
                                    f"{tun_ip}/{tun_netmask}",
                                    "-o",
                                    out_iface,
                                    "-j",
                                    "MASQUERADE",
                                ],
                                check=False,
                            )
                            log.info(
                                "Added MASQUERADE rule for %s → %s", tun_name, out_iface
                            )
                    except subprocess.CalledProcessError as e:
                        log.error("Failed to configure TUN/NAT: %s", e)
                        if os.environ.get("ALLOW_CONTINUE_ON_TUN_ERROR") == "1":
                            return
                        else:
                            sys.exit(1)
                else:
                    log.warning(
                        "Skipping TUN/NAT auto-setup: not running as root (UID != 0)"
                    )

                # ------------------------------------------------

            else:
                tun = None
        except Exception as e:
            log.error("Failed to initialize TUN interface: %s", e)
            if os.environ.get("ALLOW_CONTINUE_ON_TUN_ERROR") == "1":
                return
            else:
                sys.exit(1)
    # Start the Socks5 server and UDP relay thread
    from socks5tun.udp_handler import start_udp_loop

    def udp_wrapper():
        try:
            start_udp_loop(cfg, tun)
        except Exception as e:
            log.exception("Exception in UDP thread: %s", e)

    threading.Thread(
        target=udp_wrapper,
        daemon=True,
    ).start()
    os.environ["DISABLE_SELF_CONNECT"] = "1"
    server = SocksServer(cfg, tun=tun)

    try:
        log.info(
            "✅ Starting server, patch is active at %s",
            datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        )
        server.start()
    except KeyboardInterrupt:
        log.info("Server interrupted by user, shutting down")
    finally:
        if tun:
            tun.close()

            if getattr(cfg, "tun_mode", None) == "linux":
                tun_name = cfg.tun.get("name", "tun0")

                # --- Удаляем NAT-правило ---
                try:
                    tun_ip = cfg.tun.get("address", "10.8.0.1")
                    tun_netmask = cfg.tun.get("netmask", "255.255.255.0")
                    out_iface = cfg.nat.get("out_iface")
                    if out_iface:
                        subprocess.run(
                            [
                                "iptables",
                                "-t",
                                "nat",
                                "-D",
                                "POSTROUTING",
                                "-s",
                                f"{tun_ip}/{tun_netmask}",
                                "-o",
                                out_iface,
                                "-j",
                                "MASQUERADE",
                            ],
                            stdout=subprocess.DEVNULL,
                            stderr=subprocess.DEVNULL,
                            check=False,
                        )
                        log.info(
                            "Removed MASQUERADE rule for %s → %s",
                            tun_name,
                            out_iface,
                        )
                except Exception as e:
                    log.warning(f"Failed to remove MASQUERADE rule: {e}")

                # --- Удаляем TUN при остановке ---
                log.info(f"Removing TUN interface: {tun_name}")
                try:
                    subprocess.run(
                        [
                            "ip",
                            "tuntap",
                            "del",
                            "dev",
                            tun_name,
                            "mode",
                            "tun",
                        ],
                        stdout=subprocess.DEVNULL,
                        stderr=subprocess.DEVNULL,
                        check=False,
                    )
                except Exception as e:
                    log.warning(f"Failed to delete tun {tun_name}: {e}")


if __name__ == "__main__":
    main()

# --- ./build/lib/socks5tun/server.py ---
# server.py
import os
import inspect
import psutil
import traceback
import socket
import threading
import select
import logging
import ipaddress

from socks5tun.config import Config

# SOCKS5 protocol constants and values
SOCKS_VERSION = 5
# Authentication methods
NO_AUTH = 0x00
USER_AUTH = 0x02
NO_ACCEPTABLE = 0xFF
# Command codes
CMD_CONNECT = 0x01
CMD_BIND = 0x02  # BIND not implemented
CMD_UDP_ASSOCIATE = 0x03
# Address types
ADDR_IPV4 = 0x01
ADDR_DOMAIN = 0x03
ADDR_IPV6 = 0x04
# Reply codes
REP_SUCCESS = 0x00
REP_GENERAL_FAILURE = 0x01
REP_CONN_NOT_ALLOWED = 0x02
REP_NETWORK_UNREACHABLE = 0x03
REP_HOST_UNREACHABLE = 0x04
REP_CONN_REFUSED = 0x05
REP_TTL_EXPIRED = 0x06
REP_CMD_NOT_SUPPORTED = 0x07
REP_ADDR_NOT_SUPPORTED = 0x08


# Порты, с которых мы ожидаем локальный форвардинг (stunnel, ssh -L, tun2socks и т.п.)
LOCAL_FORWARD_WHITELIST = {443, 1080, 1194}


def is_self_connection(
    client_ip: str, client_port: int, server_port: int
) -> tuple[str, str]:
    """
    Определяет тип соединения:
    - 'self' — loopback + клиентский порт = порт сервера (реальный self-connect)
    - 'local_forward' — loopback + порт клиента в whitelist (ожидаемый локальный форвардер)
    - 'local_other' — loopback всё остальное
    - 'other' — всё остальное
    """
    try:
        ip_obj = ipaddress.ip_address(client_ip)
    except ValueError:
        ip_obj = None

    if ip_obj and ip_obj.is_loopback:
        pname = "unknown"
        pid = None
        for conn in psutil.net_connections(kind='tcp'):
            if not conn.laddr or not conn.raddr:
                continue
            if (
                conn.laddr[1] == server_port
                and conn.raddr[0] == client_ip
                and conn.raddr[1] == client_port
            ):
                pid = conn.pid
                if pid:
                    try:
                        pname = psutil.Process(pid).name()
                    except Exception:
                        pass
                break

        # 1. Настоящий self-connect
        if client_port == server_port:
            return "self", f"{pid} {pname}"

        # 2. Локальный форвард (по whitelist портов)
        if client_port in LOCAL_FORWARD_WHITELIST:
            return "local_forward", f"{pid} {pname}"

        # 3. Остальное loopback
        return "local_other", f"{pid} {pname if pname else 'unknown'}"

    return "other", "unknown"


def recv_exact(conn, n):
    """Читает ровно n байт из сокета, иначе выбрасывает исключение."""
    data = b''
    while len(data) < n:
        chunk = conn.recv(n - len(data))
        if not chunk:
            raise IOError("Connection closed prematurely")
        data += chunk
    return data


class SocksServer:
    """
    A Socks5 proxy server that handles TCP CONNECT and UDP ASSOCIATE commands.
    """

    def __init__(self, config: Config, tun=None):
        self.config = config
        self.tun = tun  # DummyTun or real TUN interface if provided
        self._log = logging.getLogger("socks5-server")
        # Prepare allowed client networks
        self.allowed_nets = config.allowed_clients
        # Authentication setup
        self.auth_required = config.auth is not None
        self.auth_credentials = config.auth if config.auth else {}

    def start(self):
        """
        Start the Socks5 server: bind and listen for incoming connections,
        handle each in a new thread.
        """

        self._log.warning(
            "[DEBUG] Server started — stack:\n%s",
            ''.join(traceback.format_stack(limit=10)),
        )

        # Выбираем тип адреса
        family = socket.AF_INET6 if ':' in self.config.tcp_host else socket.AF_INET
        with socket.socket(family, socket.SOCK_STREAM) as server_sock:
            server_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            server_sock.bind((self.config.tcp_host, self.config.tcp_port))
            server_sock.listen()
            self._log.info(
                "Listening on %s:%d",
                self.config.tcp_host,
                self.config.tcp_port,
            )

            while True:
                try:
                    client_sock, client_addr = server_sock.accept()

                    # --- NEW: проверка IP клиента ---
                    if not self._is_client_allowed(client_addr[0]):
                        self._log.warning(
                            "Rejected connection from %s:%d "
                            "(not in allowed_clients)",
                            client_addr[0],
                            client_addr[1],
                        )
                        client_sock.close()
                        continue  # ждём следующий accept
                    # --------------------------------

                    # Определяем тип подключения и информацию о процессе
                    ctype, who = is_self_connection(
                        client_addr[0], client_addr[1], self.config.tcp_port
                    )

                    if ctype == "self":
                        # Настоящий self-test
                        self._log.info(
                            "[🧪 SELF-TEST] Accepted internal connection "
                            "from %s:%d (%s)",
                            client_addr[0],
                            client_addr[1],
                            who,
                        )
                        stack = inspect.stack()
                        self._log.debug(
                            "Top call: %s:%d in %s()",
                            stack[1].filename,
                            stack[1].lineno,
                            stack[1].function,
                        )

                    elif ctype == "local_stunnel":
                        # Локальный stunnel на loopback
                        self._log.info(
                            "[LOCAL STUNNEL] TCP connection from %s:%d (%s)",
                            client_addr[0],
                            client_addr[1],
                            who,
                        )

                    elif ctype == "local_other":
                        self._log.info(
                            "[LOCAL] TCP connection from %s:%d (%s)",
                            client_addr[0],
                            client_addr[1],
                            who,
                        )

                    elif ctype == "local_forward":
                        self._log.info(
                            "[LOCAL FORWARD] TCP connection from %s:%d (%s)",
                            client_addr[0],
                            client_addr[1],
                            who,
                        )

                    else:
                        # Любое другое подключение
                        self._log.info(
                            "[ACCEPT] TCP connection from %s:%d by %s",
                            client_addr[0],
                            client_addr[1],
                            who,
                        )
                        self._log.debug(
                            "[TRACE] Stack trace for connection from %s:%d:\n%s",
                            client_addr[0],
                            client_addr[1],
                            ''.join(traceback.format_stack(limit=8)),
                        )

                    # Запускаем обработчик клиента в отдельном потоке
                    threading.Thread(
                        target=self._handle_client,
                        args=(client_sock, client_addr),
                        daemon=True,
                    ).start()

                except OSError:
                    break

    def _is_client_allowed(self, client_ip: str) -> bool:
        """Check if the client IP is in allowed networks."""
        ip_obj = ipaddress.ip_address(client_ip)
        return any(ip_obj in net for net in self.allowed_nets)

    def _is_dest_allowed(self, dest_ip: str, dest_port: int) -> bool:
        """Check if the destination IP:
        port is permitted by allow/deny rules."""
        try:
            ip_obj = ipaddress.ip_address(dest_ip)
        except Exception:
            return False
        # Deny rules
        for net, port in getattr(self.config, "deny_rules", []):
            if ip_obj in net and (port is None or dest_port == port):
                return False
        # Allow rules
        allow_rules = getattr(self.config, "allow_rules", [])
        if allow_rules:
            allowed = False
            for net, port in allow_rules:
                if ip_obj in net and (port is None or dest_port == port):
                    allowed = True
                    break
            if not allowed:
                return False
        return True

    def _handle_client(self, conn: socket.socket, client_addr):
        if client_addr[0] == "127.0.0.1":
            self._log.warning(
                "👀 LOCAL connection from %s — likely self-initiated",
                client_addr[0],
            )

        try:
            # Для DummySocket в тестах отключаем setsockopt
            if hasattr(conn, "setsockopt"):
                conn.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)

            header = recv_exact(conn, 2)
            self._log.warning(
                "[SNIFF] First 2 bytes from %s:%d: hex=%s ascii=%r",
                client_addr[0],
                client_addr[1],
                header.hex(),
                header,
            )
            proto_guess = None
            if header.startswith(b"PO") or header.startswith(b"GE"):
                proto_guess = "HTTP"
            elif header.startswith(b"\x16\x03"):
                proto_guess = "TLS"
            elif header.startswith(b"CO"):
                proto_guess = "HTTPS proxy (CONNECT)"
            elif header[0] != 0x05:
                proto_guess = "Unknown non-SOCKS"

            if proto_guess:
                self._log.warning(
                    "[GUESS] %s:%d likely using %s instead of SOCKS5",
                    client_addr[0],
                    client_addr[1],
                    proto_guess,
                )
            ver, nmethods = header[0], header[1]
            self._log.info(
                "SOCKS5 handshake header from %s: %s", client_addr[0], header.hex()
            )

            if ver != SOCKS_VERSION:
                self._log.error(
                    "Unsupported SOCKS version %d from %s", ver, client_addr[0]
                )
                conn.close()
                return

            methods = recv_exact(conn, nmethods)
            self._log.info(
                "SOCKS5 methods from %s: %s",
                client_addr[0],
                methods.hex(),
            )

            self._log.debug(
                "[DEBUG] Waiting for SOCKS5 request from %s:%d...",
                client_addr[0],
                client_addr[1],
            )

            if self.auth_required:
                if USER_AUTH not in methods:
                    conn.sendall(bytes([SOCKS_VERSION, NO_ACCEPTABLE]))
                    conn.close()
                    return
                conn.sendall(bytes([SOCKS_VERSION, USER_AUTH]))

                ver_auth = recv_exact(conn, 1)
                if ver_auth[0] != 0x01:
                    conn.close()
                    return

                ulen = recv_exact(conn, 1)[0]
                username = recv_exact(conn, ulen).decode()

                plen = recv_exact(conn, 1)[0]
                password = recv_exact(conn, plen).decode()

                if username != self.auth_credentials.get(
                    "username"
                ) or password != self.auth_credentials.get("password"):
                    conn.sendall(bytes([0x01, 0x01]))
                    self._log.warning(
                        "Authentication failed for %s",
                        client_addr[0],
                    )
                    conn.close()
                    return
                else:
                    conn.sendall(bytes([0x01, 0x00]))
            else:
                if NO_AUTH in methods:
                    conn.sendall(bytes([SOCKS_VERSION, NO_AUTH]))
                else:
                    conn.sendall(bytes([SOCKS_VERSION, NO_ACCEPTABLE]))
                    conn.close()
                    return

            self._log.debug(
                "[DEBUG] Waiting for SOCKS5 request from %s:%d...",
                client_addr[0],
                client_addr[1],
            )

            # Добавь timeout через select (например, 3 секунды)
            ready, _, _ = select.select([conn], [], [], 3)
            if not ready:
                self._log.warning(
                    "[TIMEOUT] Client %s:%d did not send "
                    "SOCKS5 request after handshake",
                    client_addr[0],
                    client_addr[1],
                )
                conn.close()
                return
            request = recv_exact(conn, 4)

            self._log.info(
                "SOCKS5 request header from %s: %s",
                client_addr[0],
                request.hex(),
            )
            ver, cmd, _, atyp = request

            if ver != SOCKS_VERSION:
                self._log.error(
                    "Mismatched SOCKS version in request from %s",
                    client_addr[0],
                )
                conn.close()
                return

            if cmd == CMD_CONNECT:
                self._handle_connect(conn, atyp, client_addr)
            elif cmd == CMD_UDP_ASSOCIATE:
                self._handle_udp_associate(conn, atyp, client_addr)
            else:
                self._send_reply(
                    conn,
                    REP_CMD_NOT_SUPPORTED,
                    bind_ip="0.0.0.0",
                    bind_port=0,
                    atyp=ADDR_IPV4,
                )
                conn.close()

        except ConnectionResetError:
            self._log.warning(
                "Client %s forcibly closed the connection (RST)",
                client_addr[0],
            )
        except EOFError:
            self._log.warning(
                "Client %s closed connection with EOF",
                client_addr[0],
            )
        except Exception as e:
            is_self, who = is_self_connection(
                client_addr[0], client_addr[1], self.config.tcp_port
            )
            if is_self or client_addr[0] == "127.0.0.1":
                self._log.info(
                    "🔁 [LOCAL/SELF] "
                    "Connection from %s "
                    "closed prematurely "
                    "(%s)",
                    client_addr[0],
                    who if is_self else str(e),
                )
            else:
                self._log.error(
                    "Error handling client %s: %s",
                    client_addr[0],
                    e,
                )

        finally:
            try:
                conn.close()
            except Exception:
                pass

    def _handle_connect(self, conn: socket.socket, atyp: int, client_addr):
        """Handle SOCKS5 CONNECT (TCP forwarding)"""
        try:
            dest_addr, dest_port = self._read_dest_address(conn, atyp)
        except Exception as e:
            self._log.error(
                "Failed to parse destination address from %s: %s",
                client_addr[0],
                e,
            )
            rep = (
                REP_ADDR_NOT_SUPPORTED
                if isinstance(e, ValueError)
                else REP_GENERAL_FAILURE
            )
            self._send_reply(
                conn,
                rep,
                bind_ip="0.0.0.0",
                bind_port=0,
                atyp=ADDR_IPV4,
            )
            conn.close()
            return
        # Check against allow/deny rules
        if not self._is_dest_allowed(dest_addr, dest_port):
            self._log.info(
                "Blocked destination %s requested by %s",
                dest_addr,
                client_addr[0],
            )
            self._send_reply(
                conn,
                REP_CONN_NOT_ALLOWED,
                bind_ip="0.0.0.0",
                bind_port=0,
                atyp=ADDR_IPV4,
            )
            conn.close()
            return
        # Create remote socket to target
        remote_family = socket.AF_INET6 if ':' in dest_addr else socket.AF_INET
        try:
            remote_sock = socket.socket(remote_family, socket.SOCK_STREAM)
            remote_sock.connect((dest_addr, dest_port))
        except socket.error as e:
            err_no = getattr(e, 'errno', None)
            if err_no in (111, 61):
                rep = REP_CONN_REFUSED
            elif err_no in (113, 101):
                rep = REP_HOST_UNREACHABLE
            else:
                rep = REP_GENERAL_FAILURE
            self._log.error(
                "TCP Connect to %s:%d failed: %s",
                dest_addr,
                dest_port,
                e,
            )
            self._send_reply(
                conn,
                rep,
                bind_ip="0.0.0.0",
                bind_port=0,
                atyp=ADDR_IPV4,
            )
            conn.close()
            return
        # Connected successfully
        bind_ip, bind_port = remote_sock.getsockname()[:2]
        reply_atyp = ADDR_IPV6 if remote_family == socket.AF_INET6 else ADDR_IPV4
        self._send_reply(
            conn,
            REP_SUCCESS,
            bind_ip=bind_ip,
            bind_port=bind_port,
            atyp=reply_atyp,
        )
        self._log.info(
            "Established TCP tunnel from %s to %s:%d",
            client_addr[0],
            dest_addr,
            dest_port,
        )
        try:
            self._exchange_loop(conn, remote_sock)
        finally:
            remote_sock.close()
            conn.close()
            self._log.info("Closed TCP tunnel for %s", client_addr[0])

    def _handle_udp_associate(
        self,
        conn: socket.socket,
        atyp: int,
        client_addr,
    ):
        """Handle SOCKS5 UDP ASSOCIATE (UDP relay)"""
        try:
            client_ip, client_port = self._read_dest_address(conn, atyp)
        except Exception:
            client_ip, client_port = client_addr[0], 0
        # Determine address and port for UDP relay from config
        bind_ip = self.config.udp_host
        if bind_ip == "0.0.0.0":
            bind_ip = conn.getsockname()[0]
            if bind_ip == "0.0.0.0":
                bind_ip = "0.0.0.0"
        if bind_ip in ("::", "::0", "0:0:0:0:0:0:0:0"):
            local_ip = conn.getsockname()[0]
            if local_ip and local_ip != "::":
                bind_ip = local_ip
            else:
                bind_ip = "::"
        reply_atyp = ADDR_IPV6 if ':' in bind_ip else ADDR_IPV4
        self._send_reply(
            conn,
            REP_SUCCESS,
            bind_ip=bind_ip,
            bind_port=self.config.udp_port,
            atyp=reply_atyp,
        )
        self._log.info(
            "UDP association established with %s, UDP relay port %d",
            client_addr[0],
            self.config.udp_port,
        )
        try:
            conn.recv(1)
        except Exception:
            pass
        conn.close()
        self._log.info("Closed UDP association for %s", client_addr[0])

    def _exchange_loop(
        self,
        client_sock: socket.socket,
        remote_sock: socket.socket,
    ):
        """Relay data between client
        and remote sockets until one side closes."""
        while True:
            rlist, _, _ = select.select([client_sock, remote_sock], [], [])
            if client_sock in rlist:
                data = client_sock.recv(4096)
                if not data:
                    break
                remote_sock.sendall(data)
            if remote_sock in rlist:
                data = remote_sock.recv(4096)
                if not data:
                    break
                client_sock.sendall(data)

    def _send_reply(
        self,
        conn: socket.socket,
        rep: int,
        bind_ip: str,
        bind_port: int,
        atyp: int,
    ):
        """Send a SOCKS5 reply packet
        with given reply code and bind address/port."""
        try:
            if atyp == ADDR_IPV4:
                addr_bytes = socket.inet_aton(bind_ip)
            elif atyp == ADDR_IPV6:
                addr_bytes = socket.inet_pton(socket.AF_INET6, bind_ip)
            elif atyp == ADDR_DOMAIN:
                addr_bytes = bytes([len(bind_ip)]) + bind_ip.encode('utf-8')
            else:
                atyp = ADDR_IPV4
                addr_bytes = b"\x00\x00\x00\x00"
            port_bytes = int(bind_port).to_bytes(2, 'big')
            response = (
                bytes(
                    [
                        SOCKS_VERSION,
                        rep,
                        0x00,
                        atyp,
                    ]
                )
                + addr_bytes
                + port_bytes
            )
            conn.sendall(response)
        except Exception as e:
            self._log.error("Failed to send reply to client: %s", e)

    def _read_dest_address(self, conn: socket.socket, atyp: int):
        """
        Read destination address and port from the client request.
        Returns a tuple (dest_addr, dest_port).
        """
        if atyp == ADDR_IPV4:
            addr_bytes = conn.recv(4)
            if len(addr_bytes) < 4:
                raise IOError("Incomplete IPv4 address")
            dest_addr = socket.inet_ntoa(addr_bytes)
            port_bytes = conn.recv(2)
            if len(port_bytes) < 2:
                raise IOError("Incomplete port")
            dest_port = int.from_bytes(port_bytes, 'big')
            return dest_addr, dest_port
        elif atyp == ADDR_DOMAIN:
            length_byte = conn.recv(1)
            if not length_byte:
                raise IOError("Incomplete domain length")
            length = length_byte[0]
            domain_bytes = conn.recv(length)
            if len(domain_bytes) < length:
                raise IOError("Incomplete domain name")
            dest_domain = domain_bytes.decode('utf-8', 'ignore')
            port_bytes = conn.recv(2)
            if len(port_bytes) < 2:
                raise IOError("Incomplete port")
            dest_port = int.from_bytes(port_bytes, 'big')
            try:
                dest_addr = socket.gethostbyname(dest_domain)
            except Exception as e:
                self._log.warning(
                    "Failed to resolve domain %s: %s",
                    dest_domain,
                    e,
                )
                raise e
            return dest_addr, dest_port
        elif atyp == ADDR_IPV6:
            addr_bytes = conn.recv(16)
            if len(addr_bytes) < 16:
                raise IOError("Incomplete IPv6 address")
            dest_addr = socket.inet_ntop(socket.AF_INET6, addr_bytes)
            port_bytes = conn.recv(2)
            if len(port_bytes) < 2:
                raise IOError("Incomplete port")
            dest_port = int.from_bytes(port_bytes, 'big')
            return dest_addr, dest_port
        else:
            raise ValueError("Unsupported address type %d" % atyp)

# --- ./build/lib/socks5tun/udp_handler.py ---
# udp_handler.py
import socket
import logging
import struct
import threading
from ipaddress import ip_address, ip_network

logger = logging.getLogger("socks5-server")


class UDPHandler:
    def __init__(self, cfg, tun):
        self.cfg = cfg
        self.tun = tun
        self.remote_map = {}
        # Load legacy forbidden networks if present (for compatibility)
        self.forbidden_networks = []
        if hasattr(cfg, "forbidden_networks"):
            for net in cfg.forbidden_networks:
                try:
                    self.forbidden_networks.append(ip_network(net))
                except ValueError:
                    continue

    def _ip_checksum(self, data: bytes) -> int:
        """Calculate IPv4 header checksum."""
        if len(data) % 2 == 1:
            data += b'\x00'
        total = 0
        for i in range(0, len(data), 2):
            word = data[i] << 8 | data[i + 1]
            total += word
        total = (total >> 16) + (total & 0xFFFF)
        total = ~total & 0xFFFF
        return total

    def handle_client_packet(self, data: bytes, client_addr):
        """
        Handle a UDP packet from client (SOCKS5 UDP ASSOCIATE).
        data: raw UDP datagram from client (including SOCKS5 UDP header).
        client_addr: tuple (src_ip, src_port) of the client.
        """
        # Minimum UDP header length is 4 bytes
        if len(data) < 4:
            return
        # Check reserved bytes and fragmentation field
        if data[0] != 0x00 or data[1] != 0x00:
            return  # Invalid reserved field
        frag = data[2]
        if frag != 0x00:
            logger.warning(
                f"Received fragmented UDP packet from {client_addr}, dropping"
            )
            return
        atyp = data[3]
        offset = 4
        dest_addr = None
        dest_port = None
        # Parse destination based on ATYP
        if atyp == 0x01:  # IPv4
            if len(data) < offset + 6:
                return
            dest_addr = socket.inet_ntoa(data[offset : offset + 4])
            offset += 4
            dest_port = struct.unpack("!H", data[offset : offset + 2])[0]
            offset += 2
        elif atyp == 0x03:  # Domain name
            if len(data) < offset + 1:
                return
            name_len = data[offset]
            offset += 1
            if len(data) < offset + name_len + 2:
                return
            dest_name = data[offset : offset + name_len].decode(
                'ascii', errors='ignore'
            )
            offset += name_len
            dest_port = struct.unpack("!H", data[offset : offset + 2])[0]
            offset += 2
            # Resolve domain to IP
            if getattr(self.cfg, "dns_resolver", "system") == "system":
                try:
                    addrs = socket.getaddrinfo(
                        dest_name, dest_port, proto=socket.IPPROTO_UDP
                    )
                except Exception:
                    logger.warning(
                        f"[UDP-DENY ] {client_addr[0]}:{client_addr[1]}"
                        f" → {dest_name}:{dest_port} reason=resolve_fail"
                    )
                    return
            else:
                try:
                    addrs = socket.getaddrinfo(
                        dest_name, dest_port, proto=socket.IPPROTO_UDP
                    )
                except Exception:
                    logger.warning(
                        f"[UDP-DENY ] {client_addr[0]}:{client_addr[1]}"
                        f" → {dest_name}:{dest_port} reason=resolve_fail"
                    )
                    return
            if not addrs:
                logger.warning(
                    f"[UDP-DENY ] {client_addr[0]}:{client_addr[1]}"
                    f" → {dest_name}:{dest_port} reason=resolve_fail"
                )
                return
            dest_addr = addrs[0][4][0]
        elif atyp == 0x04:  # IPv6
            if len(data) < offset + 18:
                return
            try:
                dest_addr = socket.inet_ntop(
                    socket.AF_INET6, data[offset : offset + 16]
                )
            except OSError:
                return
            offset += 16
            dest_port = struct.unpack("!H", data[offset : offset + 2])[0]
            offset += 2
        else:
            return
        payload = data[offset:]
        if dest_addr is None:
            return
        # Apply allow/deny filtering
        allowed = True
        reason = "deny_rule"
        try:
            ip_obj = ip_address(dest_addr)
        except ValueError:
            ip_obj = None
        if ip_obj:
            # Check deny rules
            for net, port in getattr(self.cfg, "deny_rules", []):
                if ip_obj in net and (port is None or dest_port == port):
                    allowed = False
                    break

            # Check legacy forbidden networks if no explicit deny rules
            if allowed and not getattr(self.cfg, "deny_rules", []):
                for net in self.forbidden_networks:
                    if ip_obj in net:
                        allowed = False
                        break

            # Check allow rules
            if allowed and getattr(self.cfg, "allow_rules", []):
                matched = False
                for net, port in self.cfg.allow_rules:
                    if ip_obj in net and (port is None or dest_port == port):
                        matched = True
                        break
                if not matched:
                    allowed = False
        else:
            allowed = False
        if not allowed:
            logger.warning(
                f"[UDP-DENY ] {client_addr[0]}:{client_addr[1]}"
                f" → {dest_addr}:{dest_port} reason={reason}"
            )
            return
        # Build packet and forward to TUN (IPv4 only)
        ip_obj = ip_address(dest_addr)
        if ip_obj.version == 4:
            src_ip = client_addr[0]
            src_port = client_addr[1] & 0xFFFF
            dst_ip = dest_addr
            # IPv4 header
            version = 4
            ihl = 5
            ver_ihl = (version << 4) + ihl
            tos = 0
            total_length = 20 + 8 + len(payload)
            identification = 0
            flags_offset = 0
            ttl = 64
            protocol = socket.IPPROTO_UDP
            src_ip_bytes = socket.inet_aton(src_ip)
            dst_ip_bytes = socket.inet_aton(dst_ip)
            # Initial header with zero checksum
            ip_header = struct.pack(
                "!BBHHHBBH4s4s",
                ver_ihl,
                tos,
                total_length,
                identification,
                flags_offset,
                ttl,
                protocol,
                0,
                src_ip_bytes,
                dst_ip_bytes,
            )
            checksum = self._ip_checksum(ip_header)
            # Final IP header with checksum
            ip_header = struct.pack(
                "!BBHHHBBH4s4s",
                ver_ihl,
                tos,
                total_length,
                identification,
                flags_offset,
                ttl,
                protocol,
                checksum,
                src_ip_bytes,
                dst_ip_bytes,
            )
            # UDP header
            dst_port_net = dest_port & 0xFFFF
            udp_length = 8 + len(payload)
            udp_header = struct.pack(
                "!HHHH",
                src_port,
                dst_port_net,
                udp_length,
                0,
            )
            packet = ip_header + udp_header + payload
            self.tun.write(packet)
            self.remote_map[(dest_addr, dest_port)] = client_addr
        elif ip_obj.version == 6:
            logger.warning(
                f"Cannot forward UDP to IPv6 address"
                f" {dest_addr} "
                f"(not supported)"
            )
            return
        else:
            return
        # Log forwarded packet as allowed
        logger.info(
            f"[UDP-ALLOW] {client_addr[0]}:{client_addr[1]}"
            f" → {dest_addr}:{dest_port} len={len(payload)}"
        )


def start_udp_loop(cfg, tun):
    """
    Start a loop to handle global UDP relay.
    Listens on cfg.udp_host:cfg.udp_port for UDP traffic.
    """
    family = socket.AF_INET6 if ':' in cfg.udp_host else socket.AF_INET
    udp_sock = socket.socket(family, socket.SOCK_DGRAM)
    logger.debug("[BOOT] Entered start_udp_loop()")
    try:
        udp_sock.bind((cfg.udp_host, cfg.udp_port))
    except OSError as e:
        logger.error(
            "Failed to bind UDP socket on %s:%d — %s",
            cfg.udp_host,
            cfg.udp_port,
            e,
        )
        return

    logger.info(
        "[DEBUG] Bound UDP socket on %s:%d",
        cfg.udp_host,
        cfg.udp_port,
    )
    logger.info(f"UDP relay socket listening on {cfg.udp_host}:{cfg.udp_port}")
    # Mapping for direct UDP mode (dest -> client)
    remote_map = {}
    # Handler for client packets
    handler = UDPHandler(cfg, tun)
    handler.remote_map = remote_map
    # If TUN interface is available, start thread to handle incoming packets from TUN
    if tun:

        def tun_reader():
            while True:
                try:
                    packet = tun.read()
                except Exception as e:
                    logger.error("UDP tun read error: %s", e)
                    break
                if not packet:
                    break
                # Only handle IPv4 UDP packets from tun
                if len(packet) < 20:
                    continue
                version = packet[0] >> 4
                if version != 4:
                    # Only IPv4 supported for now
                    continue
                proto = packet[9]
                if proto != socket.IPPROTO_UDP:
                    continue
                src_ip = socket.inet_ntoa(packet[12:16])
                dst_ip = socket.inet_ntoa(packet[16:20])
                src_port = int.from_bytes(packet[20:22], 'big')
                dst_port = int.from_bytes(packet[22:24], 'big')
                payload = packet[28:]
                client_key = (src_ip, src_port)
                # If we have a client for this dest, forward to it
                if client_key in remote_map:
                    client_addr = remote_map[client_key]
                else:
                    # No mapping, drop
                    logger.warning(
                        f"Received UDP packet from {src_ip}:{src_port} with "
                        "no client mapping for {dst_ip}:{dst_port}"
                    )
                    continue
                # Build SOCKS UDP response
                try:
                    if ':' in src_ip:
                        addr_bytes = socket.inet_pton(socket.AF_INET6, src_ip)
                        resp_atyp = 0x04
                    else:
                        addr_bytes = socket.inet_aton(src_ip)
                        resp_atyp = 0x01
                    port_bytes = src_port.to_bytes(2, 'big')
                    resp_header = (
                        b"\x00\x00\x00" + bytes([resp_atyp]) + addr_bytes + port_bytes
                    )
                except Exception as e:
                    logger.error(
                        "Failed to build UDP response header for %s: %s", src_ip, e
                    )
                    continue
                response_data = resp_header + payload
                try:
                    udp_sock.sendto(response_data, client_addr)
                except Exception as e:
                    logger.error(
                        "Failed to send UDP packet to client %s:%d - %s",
                        client_addr[0],
                        client_addr[1],
                        e,
                    )

        threading.Thread(target=tun_reader, daemon=True).start()
    # Main loop to handle incoming UDP datagrams on socket
    logger.debug("[BOOT] Entering UDP receive loop...")

    while True:
        try:
            logger.debug("[LOOP] Waiting for UDP packet...")
            data, addr = udp_sock.recvfrom(65535)
            logger.debug(
                "[TRACE] --- UDP packet received from %s:%d ---",
                addr[0],
                addr[1],
            )

            logger.debug(
                "[DEBUG] Got UDP from %s:%d, len=%d",
                addr[0],
                addr[1],
                len(data),
            )
            client_ip, client_port = addr[0], addr[1]
            try:
                ip_obj = ip_address(client_ip)
            except ValueError:
                ip_obj = None
            is_client = ip_obj is not None and any(
                ip_obj in net for net in cfg.allowed_clients
            )

            # ✅ ДОПОЛНИТЕЛЬНЫЕ ЛОГИ
            logger.debug("[TRACE] UDP packet from: %s:%d", client_ip, client_port)
            logger.debug("[TRACE] Evaluated ip_obj: %s", ip_obj)
            logger.debug("[TRACE] allowed_clients: %s", cfg.allowed_clients)
            logger.debug("[TRACE] is_client: %s", is_client)

        except Exception as e:
            logger.error("UDP socket error: %s", e)
            break
        client_ip, client_port = addr[0], addr[1]
        try:
            ip_obj = ip_address(client_ip)
        except ValueError:
            ip_obj = None
        is_client = ip_obj is not None and any(
            ip_obj in net for net in cfg.allowed_clients
        )
        logger.debug("[CHECK] Incoming UDP from %s:%d", client_ip, client_port)
        logger.debug("[CHECK] allowed_clients = %s", cfg.allowed_clients)
        logger.debug("[CHECK] ip_obj = %s", ip_obj)
        logger.debug("[CHECK] is_client = %s", is_client)

        if is_client:
            # UDP datagram from an allowed client
            if tun:
                logger.debug(
                    "[DEBUG] handle_client_packet from %s:%d, raw: %s",
                    addr[0],
                    addr[1],
                    data.hex(),
                )
                try:
                    handler.handle_client_packet(data, addr)
                except Exception as e:
                    logger.error("Exception in handle_client_packet: %s", e)

            else:
                # Handle direct UDP forward (no TUN)

                if len(data) < 4:
                    continue
                if data[0] != 0x00 or data[1] != 0x00:
                    continue
                frag = data[2]
                if frag != 0x00:
                    continue
                atyp = data[3]
                off = 4
                dest_addr = None
                dest_port = None
                if atyp == 0x01:
                    if len(data) < off + 6:
                        continue
                    dest_addr = socket.inet_ntoa(data[off : off + 4])
                    off += 4
                    dest_port = int.from_bytes(data[off : off + 2], 'big')
                    off += 2
                elif atyp == 0x03:
                    if len(data) < off + 1:
                        continue
                    name_len = data[off]
                    off += 1
                    if len(data) < off + name_len + 2:
                        continue
                    dest_name = data[off : off + name_len].decode(
                        'ascii', errors='ignore'
                    )
                    off += name_len
                    dest_port = int.from_bytes(data[off : off + 2], 'big')
                    off += 2
                    try:
                        dest_addr = socket.gethostbyname(dest_name)
                    except Exception as e:
                        logger.warning(
                            f"[UDP-DENY ] {client_ip}:{client_port}"
                            f" → {dest_name}:{dest_port} reason=resolve_fail"
                        )
                        continue
                elif atyp == 0x04:
                    if len(data) < off + 18:
                        continue
                    try:
                        dest_addr = socket.inet_ntop(
                            socket.AF_INET6, data[off : off + 16]
                        )
                    except OSError:
                        continue
                    off += 16
                    dest_port = int.from_bytes(data[off : off + 2], 'big')
                    off += 2
                else:
                    continue
                payload = data[off:]
                if dest_addr is None:
                    continue
                # Filtering
                allowed = True
                reason = "deny_rule"
                try:
                    dest_ip_obj = ip_address(dest_addr)
                except ValueError:
                    dest_ip_obj = None
                if dest_ip_obj:
                    for net, port in getattr(cfg, "deny_rules", []):
                        if dest_ip_obj in net and (port is None or dest_port == port):
                            allowed = False
                            break
                    if allowed and getattr(cfg, "allow_rules", []):
                        match = False
                        for net, port in cfg.allow_rules:
                            if dest_ip_obj in net and (
                                port is None or dest_port == port
                            ):
                                match = True
                                break
                        if not match:
                            allowed = False
                else:
                    allowed = False
                if not allowed:
                    logger.warning(
                        f"[UDP-DENY ] {client_ip}:{client_port}"
                        f" → {dest_addr}:{dest_port} reason={reason}"
                    )
                    continue
                # Forward to remote
                try:
                    logger.debug(
                        "[SEND] Sending UDP to %s:%d (payload %d bytes): %s",
                        dest_addr,
                        dest_port,
                        len(payload),
                        payload.hex(),
                    )
                    udp_sock.sendto(payload, (dest_addr, dest_port))
                except Exception as e:
                    logger.error(
                        "Failed to relay UDP to %s:%d - %s",
                        dest_addr,
                        dest_port,
                        e,
                    )
                    continue
                # Update mapping for return traffic
                remote_map[(dest_addr, dest_port)] = addr
                logger.info(
                    f"[UDP-ALLOW] {client_ip}:{client_port}"
                    f" → {dest_addr}:{dest_port} len={len(payload)}"
                )
        else:
            # UDP datagram from remote host
            logger.debug(
                "[REJECT] UDP from %s:%d rejected: not in allowed_clients",
                client_ip,
                client_port,
            )
            if tun:
                # Should not happen (remote replies handled via tun), ignore
                continue
            # Direct mode: relay back to client if known
            remote_ip, remote_port = client_ip, client_port
            if (remote_ip, remote_port) not in remote_map:
                continue
            client_addr = remote_map[(remote_ip, remote_port)]
            # Build SOCKS UDP response
            try:
                if ':' in remote_ip:
                    addr_bytes = socket.inet_pton(socket.AF_INET6, remote_ip)
                    resp_atyp = 0x04
                else:
                    addr_bytes = socket.inet_aton(remote_ip)
                    resp_atyp = 0x01
                port_bytes = remote_port.to_bytes(2, 'big')
                resp_header = (
                    b"\x00\x00\x00" + bytes([resp_atyp]) + addr_bytes + port_bytes
                )
            except Exception as e:
                logger.error(
                    "Failed to build UDP response header for %s: %s",
                    remote_ip,
                    e,
                )
                continue
            response_data = resp_header + data
            udp_sock.sendto(response_data, client_addr)

# --- ./README.md ---
## Логирование UDP-трафика

По умолчанию приложение логирует весь UDP-трафик — как **разрешённый**, так и **заблокированный**.

- Разрешённые UDP-пакеты записываются в журнал уровня INFO с префиксом `[UDP-ALLOW]`. В сообщении указываются исходный адрес:порт клиента, адрес:порт назначения и размер переданных данных.
- Заблокированные UDP-пакеты записываются в журнал уровня WARNING с префиксом `[UDP-DENY ]`. В сообщении указываются исходный адрес:порт клиента, адрес:порт назначения и причина блокировки (например, `reason=deny_rule`).

Пример фрагмента журнала UDP-трафика:

```text
[UDP-ALLOW] 192.0.2.10:39522 → 8.8.8.8:53 len=42
[UDP-DENY ] 10.0.0.5:60234 → 192.168.0.1:80 reason=deny_rule
```

---

## Автосетап TUN/NAT

Если в конфигурационном файле (`config.json`) заданы параметры блоков:

```json
"tun": {
  "name": "tun0",
  "address": "10.8.0.1",
  "netmask": "255.255.255.0",
  "peer_address": "10.8.0.2",
  "mtu": 1500
},
"nat": {
  "out_iface": "eth0"
}
```

то при старте сервера **TUN‑интерфейс** и **NAT‑правила** будут настраиваться автоматически.

- Автосетап выполняется **только**, если процесс запущен с правами `root` (`UID 0`).
- В тестовом или CI‑окружении, где нет root‑доступа, авто‑сетап будет пропущен, и в логах появится предупреждение:

```text
[WARNING] Skipping TUN/NAT auto-setup: not running as root (UID != 0)
```

---

## Базовая настройка брандмауэра (UFW)

Для ограничения внешнего доступа рекомендуется разрешить только необходимые порты:

```bash
ufw default deny incoming
ufw default allow outgoing
ufw allow 22/tcp comment "SSH"
ufw allow 443/tcp comment "TLS (stunnel)"
ufw enable
```

- Это закроет все входящие соединения, кроме SSH и TLS‑порта, используемого stunnel.
- Порт SOCKS5 (например, 5000/tcp), на котором слушает Python‑сервер, при этом будет доступен **только локально** (127.0.0.1) и через stunnel.
- Если требуется прямой внешний доступ к SOCKS5, добавьте правило:

```bash
ufw allow 5000/tcp comment "SOCKS5 direct"
```

---

## Мини-бэкап конфигураций `/etc`

Для автоматического отслеживания и возможности отката изменений в системных конфигурациях `/etc` рекомендуется установить:

```bash
sudo apt install -y etckeeper
cd /etc
sudo etckeeper init
sudo etckeeper commit -m "Initial server snapshot"
```

Теперь изменения `/etc` будут отслеживаться с помощью Git. Это удобно при ручной настройке `ufw`, `ssh`, `resolv.conf`, и т.д.

---

## Потенциальное улучшение: базовая защита SSH

Для повышения безопасности SSH можно добавить отдельный файл настроек `/etc/ssh/sshd_config.d/hardening.conf`:

```conf
PermitRootLogin no
PasswordAuthentication no
ClientAliveInterval 300
ClientAliveCountMax 2
```

- **PermitRootLogin no** — запрет входа под root по SSH.
- **PasswordAuthentication no** — отключение входа по паролю (только по SSH-ключу).
- **ClientAliveInterval** и **ClientAliveCountMax** — автоматическое завершение сессий при отсутствии активности.

> ⚠️ Перед применением убедитесь, что у вас есть рабочая учётная запись с ключом SSH и правами `sudo`.
> Рекомендуется сначала протестировать вход в новой сессии, и только потом закрывать текущую.

## Потенциальное улучшение: максимальная изоляция `stunnel`

В будущем возможно реализовать запуск `stunnel` с усиленной безопасностью. Это актуально при открытом или публичном VPN-сервисе с несколькими пользователями.

### ✅ Отдельный системный пользователь

```bash
sudo adduser --system --group --no-create-home stunnel
sudo chown root:stunnel /etc/stunnel
sudo chmod 750 /etc/stunnel
sudo chown root:stunnel /etc/stunnel/stunnel.pem
sudo chmod 640 /etc/stunnel/stunnel.pem
```

### ✅ Вынос PID-файла в безопасное место

```ini
pid = /run/stunnel/stunnel.pid
```

### ✅ Создание каталога и прав на него

```bash
sudo mkdir -p /run/stunnel
sudo chown stunnel:stunnel /run/stunnel
```

### ✅ Выдача capability для портов < 1024

```bash
sudo setcap 'cap_net_bind_service=+ep' /usr/bin/stunnel
```

### ✅ Защита через systemd (в unit-файле)

```ini
NoNewPrivileges=true
ProtectSystem=full
ReadOnlyPaths=/etc/stunnel
```

### 🧱 (опционально) chroot

Если требуется полная изоляция файловой системы (FS), возможно использование `chroot` — но это требует ручной подготовки окружения (библиотек, /dev/null и т.п.).

> Эти меры изолируют `stunnel` от остальной системы, даже если произойдёт взлом или утечка ключей.

Применить изменения:

```bash
sudo systemctl restart ssh
```

---

## Обновление и управление сервисом SOCKS5TUN

Проект включает встроенную систему обновления и перезапуска через связку:

- `update_socks5tun` — исполняемый скрипт/модуль, отвечающий за загрузку, установку или замену кода проекта.
- `socks5tun-update.service` — вспомогательный systemd-сервис, выполняющий `update_socks5tun` перед запуском основного прокси.
- `socks5tun.service` — основной сервис, запускающий SOCKS5-прокси сервер.

### Схема запуска

1. При запуске `socks5tun.service` автоматически **выполняется `socks5tun-update.service`**, если он указан как `Requires` + `After` в `Unit`-блоке.
2. Только **после успешного завершения обновления** стартует основной сервер.

Такой подход гарантирует, что при перезапуске системы или сервиса будет использоваться **актуальная версия** кода.

### Вручную

Для ручного запуска без обновления:

```bash
sudo systemctl start socks5tun.service
```

Для запуска только обновления (без старта прокси):

```bash
sudo systemctl start socks5tun-update.service
```

Для выполнения обновления вручную (если `update_socks5tun` — исполняемый файл):

```bash
sudo /usr/local/bin/update_socks5tun
```

---

## Работа с systemd

После изменения `.service`‑файлов **не забудьте перезагрузить systemd**:

```bash
sudo systemctl daemon-reload
```

Перезапуск сервиса:

```bash
sudo systemctl restart socks5tun.service
```

Просмотр логов:

```bash
journalctl -u socks5tun.service -f
```

Если вы изменили только Python‑код (`*.py`) — `daemon-reload` **не требуется**, достаточно `restart`.

---

## Размещение файлов

- `update_socks5tun` должен быть исполняемым (`chmod +x`) и доступным в PATH или по абсолютному пути (например, `/usr/local/bin/`).
- Юнит‑файлы systemd обычно размещаются в `/etc/systemd/system/`:

```bash
/etc/systemd/system/socks5tun.service
/etc/systemd/system/socks5tun-update.service
```

Проверь, чтобы они были включены в автозагрузку:

```bash
sudo systemctl enable socks5tun.service
```

> Обновление не выполняется, если сервис запускается напрямую (`python run.py`) — только через systemd.

# --- ./setup.py ---
from setuptools import setup, find_packages

setup(
    name="socks5tun",
    version="0.1",
    packages=find_packages(),  # автоматически найдёт socks5tun/
    include_package_data=True,
    python_requires=">=3.8",
)
