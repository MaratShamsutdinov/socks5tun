[32m[INFO] === MISC FILES ===(B[m

# --- ./help.txt ---
# Активировать окружение на сервере:
source /opt/venv-pyroute/bin/activate

# Архивировать папку tests
zip -r tests_with_ci.zip tests .github/workflows/test.yml

# Создать txt файл с содержимым test + ДЕРЕВО
./diagnostics/collect_tests.sh


### Запуск проекта:
## Запуска через автомат

# перезапуск systemd, если были обновления systemd
sudo systemctl daemon-reexec

# обновляет конфигурацию systemd (нужно после изменения .service файла)
sudo systemctl daemon-reload

# перезапуск проекта
sudo systemctl restart socks5tun.service

# логи он-лайн
sudo journalctl -fu socks5tun.service

## Запуск вручную
# Тестовый запуск проекта
python -m socks5tun.run -c config_dev.json

# Рабочий запуск
python -m socks5tun.run


### Прочее
# stunnel на сервере
sudo nano /etc/stunnel/stunnel.conf

# Запустить тесты
pytest -q

# Вернутся в проект
cd ~/socks5tun
# --- ./config_dev.json ---
{
    "tcp_host": "127.0.0.1",
    "tcp_port": 1080,
    "udp_host": "127.0.0.1",
    "udp_port": 1080,
    "tun_mode": "dummy",
    "log_level": "INFO",
    "auth": null,
    "allowed_clients": [
        "127.0.0.1/32"
    ],
    "blocked_destinations": [
        "0.0.0.0/8",
        "10.0.0.0/8",
        "127.0.0.0/8",
        "169.254.0.0/16",
        "172.16.0.0/12",
        "192.168.0.0/16",
        "240.0.0.0/4"
    ],
    "dns_resolver": "system"
}
# --- ./.github/workflows/test.yml ---
name: CI
on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  tests:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: [3.12]
    steps:
      - uses: actions/checkout@v3
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      - name: Run tests
        run: pytest

# --- ./config_prod.json ---
{
  "tcp_host": "0.0.0.0",
  "tcp_port": 5000,
  "udp_host": "0.0.0.0",
  "udp_port": 5000,
  "tun_mode": "linux",
  "log_level": "DEBUG",

  "tun": {
    "name": "tun0",
    "address": "10.8.0.1",
    "netmask": "255.255.255.0",
    "peer_address": "10.8.0.2",
    "mtu": 1500
  },

  "nat": {
    "out_iface": "eth0"
  },

  "auth": null,
  "allowed_clients": ["0.0.0.0/0"],
  "blocked_destinations": [
    "0.0.0.0/8", "10.0.0.0/8", "127.0.0.0/8",
    "169.254.0.0/16", "172.16.0.0/12", "192.168.0.0/16",
    "240.0.0.0/4"
  ],
  "dns_resolver": "system",
  "self_check": true
}

# --- ./build/lib/socks5tun/dummy_tun.py ---
"""
Dummy TUN interface for simulating a TUN device.
"""

import threading
import traceback
import logging
from collections import deque


class DummyTun:
    """
    A dummy TUN interface that mimics a TUN device for testing or environments
    where a real TUN device is not available.
    Data written to this dummy interface
    is stored, and data can be injected for reading.
    """

    def __init__(self):
        # Queues for incoming (to be read) and outgoing (written) data
        self._incoming_data = deque()
        self._outgoing_data = deque()
        self._lock = threading.Lock()
        # Conditions to wait for data availability
        self._incoming_cond = threading.Condition(self._lock)
        self._outgoing_cond = threading.Condition(self._lock)
        self.active = False

    def open(self):
        """
        Open/initialize the dummy TUN interface.
        (For a real TUN, this would create the TUN device.
        Here we just mark it active.)
        """
        with self._lock:
            self.active = True

    def read(self, size: int = 1500) -> bytes:
        """
        Read data from the dummy TUN interface
        (blocking until data is available or interface is closed).
        Returns bytes of data, or b'' if the interface is closed.
        """
        with self._incoming_cond:
            # Wait until data is available or the interface becomes inactive
            while not self._incoming_data and self.active:
                self._incoming_cond.wait()
            if not self.active and not self._incoming_data:
                # Interface closed and no data remaining
                return b""
            data = self._incoming_data.popleft()
        # Return up to 'size' bytes from the data (simulate reading a packet)
        if size and len(data) > size:
            remaining = data[size:]
            # Put the remaining back to be read next time
            with self._incoming_cond:
                self._incoming_data.appendleft(remaining)
            return data[:size]
        else:
            return data

    def write(self, data: bytes) -> int:
        """
        Write data to the dummy TUN interface.
        (For a real TUN, this would send the packet into the OS network stack.)
        Here we store it in an outgoing queue for inspection.
        Returns the number of bytes written.
        """
        if logging.getLogger().isEnabledFor(logging.DEBUG):
            print("🔄 DummyTun.write() called by:")
            traceback.print_stack(limit=5)
        traceback.print_stack(limit=5)
        with self._outgoing_cond:
            self._outgoing_data.append(data)
            # Notify any waiters for outgoing data (if used in tests)
            self._outgoing_cond.notify_all()
        return len(data)

    def inject(self, data: bytes):
        """
        Inject data into the dummy TUN interface as
        if it was received from the network.
        This data will be available to read() by the server.
        """
        with self._incoming_cond:
            self._incoming_data.append(data)
            # Notify any thread waiting for incoming data
            self._incoming_cond.notify_all()

    def close(self):
        """
        Close the dummy TUN interface.
        """
        with self._incoming_cond:
            self.active = False
            # Wake up any waiting readers so they can stop
            self._incoming_cond.notify_all()

# --- ./build/lib/socks5tun/config.py ---
"""
Configuration handling for Socks5 proxy server.
"""

import json
import ipaddress


class Config:
    """
    Holds configuration for the Socks5 server.
    """

    def __init__(self, data: dict):
        # TCP and UDP listening addresses and ports
        self.tcp_host: str = data.get("tcp_host", "127.0.0.1")
        self.tcp_port: int = data.get("tcp_port", 1080)
        self.udp_host: str = data.get("udp_host", "127.0.0.1")
        self.udp_port: int = data.get("udp_port", 1080)
        # Full tun/nat configs for easier access
        self.tun = data.get("tun", {})
        self.nat = data.get("nat", {})
        # TUN interface mode (default "dummy")
        self.tun_mode: str = data.get("tun_mode", "dummy")
        self.dns_resolver = data.get("dns_resolver", "system")
        # Logging level
        self.log_level: str = data.get("log_level", "INFO").upper()
        # Authentication credentials (if any)
        auth_data = data.get("auth")
        if (
            auth_data
            and isinstance(auth_data, dict)
            and "username" in auth_data
            and "password" in auth_data
        ):
            self.auth = {
                "username": auth_data["username"],
                "password": auth_data["password"],
            }
        else:
            self.auth = None
        # Allowed client networks
        allowed_list = data.get("allowed_clients", ["0.0.0.0/0"])
        self.allowed_clients = [ipaddress.ip_network(net) for net in allowed_list]
        # Blocked destination networks
        blocked_list = data.get("blocked_destinations", [])
        self.blocked_destinations = [ipaddress.ip_network(net) for net in blocked_list]
        # Backward compatibility
        self.forbidden_networks = data.get("forbidden_networks", [])
        self.blocked_destinations = [
            ipaddress.ip_network(net)
            for net in data.get(
                "blocked_destinations",
                [],
            )
        ]
        self.deny_rules = [(net, None) for net in self.blocked_destinations]
        self.allow_rules = []


def load_config(path: str) -> Config:
    """
    Load configuration from a JSON file and return a Config object.
    Raises FileNotFoundError if file is not found,
    or ValueError if JSON is invalid or contents are not as expected.
    """
    try:
        with open(path, "r") as f:
            data = json.load(f)
    except FileNotFoundError:
        raise
    except json.JSONDecodeError as e:
        raise ValueError(f"Invalid JSON configuration: {e}")

    # Backward compatibility for old keys
    if "tun" in data:
        if "tun_mode" not in data:
            data["tun_mode"] = "linux" if data["tun"] else "disabled"
        data.pop("tun", None)
    if "bind_host" in data or "bind_port" in data:
        raise ValueError(
            "Outdated config keys 'bind_host'/'bind_port' detected; "
            "use 'tcp_host'/'tcp_port' instead."
        )

    # Validate required field types and values
    if "tcp_host" in data and not isinstance(data["tcp_host"], str):
        raise ValueError("tcp_host must be a string")
    if "tcp_port" in data and not isinstance(data["tcp_port"], int):
        raise ValueError("tcp_port must be an integer")
    if "udp_host" in data and not isinstance(data["udp_host"], str):
        raise ValueError("udp_host must be a string")
    if "udp_port" in data and not isinstance(data["udp_port"], int):
        raise ValueError("udp_port must be an integer")
    if "tun_mode" in data:
        if not isinstance(data["tun_mode"], str):
            raise ValueError("tun_mode must be a string")
        if data["tun_mode"] not in {"dummy", "linux", "disabled"}:
            raise ValueError(
                "tun_mode must be one of: 'dummy', " "'linux', or 'disabled'"
            )
    if "log_level" in data and not isinstance(data["log_level"], str):
        raise ValueError("log_level must be a string")
    if "allowed_clients" in data and not isinstance(
        data["allowed_clients"],
        list,
    ):
        raise ValueError("allowed_clients must be a list of network strings")
    if "blocked_destinations" in data and not isinstance(
        data["blocked_destinations"], list
    ):
        raise ValueError(
            "blocked_destinations " "must be " "a list of network " "strings"
        )
    if "auth" in data:
        if data["auth"] is not None:
            if not (
                isinstance(data["auth"], dict)
                and "username" in data["auth"]
                and "password" in data["auth"]
            ):
                raise ValueError(
                    "auth must be an "
                    "object with 'username' "
                    "and 'password', or null"
                )

    # Create and return Config object
    return Config(data)

# --- ./build/lib/socks5tun/logger.py ---
"""
Logging configuration for Socks5 proxy server.
"""
import logging

def setup_logging(level: str):
    """
    Configure logging for the proxy server with the given level.
    """
    # Convert level name to numeric value (default to INFO if unrecognized)
    numeric_level = getattr(logging, level.upper(), logging.INFO)
    logging.basicConfig(
        level=numeric_level,
        format="%(asctime)s [%(levelname)s] [%(threadName)s] %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S"
    )
    # Optionally, adjust logging levels for third-party libraries if needed
    logging.getLogger("urllib3").setLevel(logging.WARNING)

# --- ./build/lib/socks5tun/__init__.py ---

# --- ./build/lib/socks5tun/run.py ---
# run.py
# !/usr/bin/env python3
"""
Entry point for the Socks5 proxy server.
"""
import argparse
import logging
import os
import sys
import threading
import subprocess
import json
import fcntl
import struct
from datetime import datetime

from socks5tun.config import load_config
from socks5tun.logger import setup_logging
from socks5tun.server import SocksServer

logger = logging.getLogger(__name__)


def main():
    parser = argparse.ArgumentParser(description="Socks5 Proxy Server")
    parser.add_argument(
        "-c",
        "--config",
        default="config_prod.json",
        help="Path to configuration JSON file",
    )
    args = parser.parse_args()
    try:
        cfg = load_config(args.config)

    except FileNotFoundError:
        logger.error("Configuration file not found: %s", args.config)
        sys.exit(1)
    except ValueError as e:
        logger.error("Error in configuration: %s", e)
        sys.exit(1)

    # Setup logging with level from config
    setup_logging(cfg.log_level)
    log = logging.getLogger("socks5-server")

    from ipaddress import ip_network

    cfg.allowed_clients = [ip_network(net) for net in cfg.allowed_clients]
    logger.debug(">> allowed_clients converted to: %s", cfg.allowed_clients)

    cfg.blocked_destinations = [ip_network(net) for net in cfg.blocked_destinations]

    if hasattr(cfg, "deny_rules"):
        cfg.deny_rules = [(ip_network(net), port) for net, port in cfg.deny_rules]
        log.debug(">> deny_rules converted to: %s", cfg.deny_rules)

    if hasattr(cfg, "allow_rules"):
        cfg.allow_rules = [(ip_network(net), port) for net, port in cfg.allow_rules]
        log.debug(">> allow_rules converted to: %s", cfg.allow_rules)

    log.info(
        "Starting Socks5 proxy server on %s:%d",
        cfg.tcp_host,
        cfg.tcp_port,
    )
    # If TUN interface is enabled in config, open it
    tun = None
    if cfg.tun_mode:
        try:
            if cfg.tun_mode == "dummy":
                from socks5tun.dummy_tun import DummyTun

                tun = DummyTun()
                tun.open()
                log.info(
                    "Dummy TUN interface opened "
                    "(not connected to "
                    "system network)",
                )
            elif cfg.tun_mode == "linux":

                TUNSETIFF = 0x400454CA
                IFF_TUN = 0x0001
                IFF_NO_PI = 0x1000
                tun_fd = os.open("/dev/net/tun", os.O_RDWR)
                ifs = fcntl.ioctl(
                    tun_fd,
                    TUNSETIFF,
                    struct.pack("16sH", b"tun%d", IFF_TUN | IFF_NO_PI),
                )
                tun_name = ifs[:16].strip(b"\x00").decode('utf-8')
                log.info("🔧 Created TUN interface with name: %s", tun_name)

                class LinuxTun:
                    def __init__(self, fd):
                        self.fd = fd

                    def read(self, size: int = 1500):
                        return os.read(self.fd, size)

                    def write(self, data: bytes):
                        return os.write(self.fd, data)

                    def close(self):
                        os.close(self.fd)

                tun = LinuxTun(tun_fd)
                log.info("Linux TUN interface %s opened", tun_name)

                # --- NEW: авто-конфигурация интерфейса и NAT ---

                if os.geteuid() == 0:
                    tun_ip = cfg.tun.get("address", "10.8.0.1")
                    tun_netmask = cfg.tun.get("netmask", "255.255.255.0")
                    peer_ip = cfg.tun.get("peer_address", "10.8.0.2")
                    mtu = cfg.tun.get("mtu", 1500)
                    out_iface = cfg.nat.get("out_iface")

                    try:
                        subprocess.run(
                            [
                                "ip",
                                "addr",
                                "add",
                                f"{tun_ip}/{tun_netmask}",
                                "peer",
                                peer_ip,
                                "dev",
                                tun_name,
                            ],
                            check=True,
                        )
                        subprocess.run(
                            ["ip", "link", "set", tun_name, "mtu", str(mtu)],
                            check=True,
                        )
                        subprocess.run(
                            ["ip", "link", "set", tun_name, "up"],
                            check=True,
                        )
                        log.info(
                            "Configured IP %s peer %s mtu %s on %s",
                            tun_ip,
                            peer_ip,
                            mtu,
                            tun_name,
                        )
                        # Включаем форвардинг
                        with open("/proc/sys/net/ipv4/ip_forward", "w") as f:
                            f.write("1\n")
                        if out_iface:
                            subprocess.run(
                                [
                                    "iptables",
                                    "-t",
                                    "nat",
                                    "-C",
                                    "POSTROUTING",
                                    "-s",
                                    f"{tun_ip}/{tun_netmask}",
                                    "-o",
                                    out_iface,
                                    "-j",
                                    "MASQUERADE",
                                ],
                                check=False,
                            )
                            subprocess.run(
                                [
                                    "iptables",
                                    "-t",
                                    "nat",
                                    "-A",
                                    "POSTROUTING",
                                    "-s",
                                    f"{tun_ip}/{tun_netmask}",
                                    "-o",
                                    out_iface,
                                    "-j",
                                    "MASQUERADE",
                                ],
                                check=False,
                            )
                            log.info(
                                "Added MASQUERADE rule for %s → %s", tun_name, out_iface
                            )
                    except subprocess.CalledProcessError as e:
                        log.error("Failed to configure TUN/NAT: %s", e)
                        if os.environ.get("ALLOW_CONTINUE_ON_TUN_ERROR") == "1":
                            return
                        else:
                            sys.exit(1)
                else:
                    log.warning(
                        "Skipping TUN/NAT auto-setup: not running as root (UID != 0)"
                    )

                # ------------------------------------------------

            else:
                tun = None
        except Exception as e:
            log.error("Failed to initialize TUN interface: %s", e)
            if os.environ.get("ALLOW_CONTINUE_ON_TUN_ERROR") == "1":
                return
            else:
                sys.exit(1)
    # Start the Socks5 server and UDP relay thread
    from socks5tun.udp_handler import start_udp_loop

    def udp_wrapper():
        try:
            start_udp_loop(cfg, tun)
        except Exception as e:
            log.exception("Exception in UDP thread: %s", e)

    threading.Thread(
        target=udp_wrapper,
        daemon=True,
    ).start()
    os.environ["DISABLE_SELF_CONNECT"] = "1"
    server = SocksServer(cfg, tun=tun)

    try:
        log.info(
            "✅ Starting server, patch is active at %s",
            datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        )
        server.start()
    except KeyboardInterrupt:
        log.info("Server interrupted by user, shutting down")
    finally:
        if tun:
            tun.close()

            if getattr(cfg, "tun_mode", None) == "linux":
                tun_name = cfg.tun.get("name", "tun0")

                # --- Удаляем NAT-правило ---
                try:
                    tun_ip = cfg.tun.get("address", "10.8.0.1")
                    tun_netmask = cfg.tun.get("netmask", "255.255.255.0")
                    out_iface = cfg.nat.get("out_iface")
                    if out_iface:
                        subprocess.run(
                            [
                                "iptables",
                                "-t",
                                "nat",
                                "-D",
                                "POSTROUTING",
                                "-s",
                                f"{tun_ip}/{tun_netmask}",
                                "-o",
                                out_iface,
                                "-j",
                                "MASQUERADE",
                            ],
                            stdout=subprocess.DEVNULL,
                            stderr=subprocess.DEVNULL,
                            check=False,
                        )
                        log.info(
                            "Removed MASQUERADE rule for %s → %s",
                            tun_name,
                            out_iface,
                        )
                except Exception as e:
                    log.warning(f"Failed to remove MASQUERADE rule: {e}")

                # --- Удаляем TUN при остановке ---
                log.info(f"Removing TUN interface: {tun_name}")
                try:
                    subprocess.run(
                        [
                            "ip",
                            "tuntap",
                            "del",
                            "dev",
                            tun_name,
                            "mode",
                            "tun",
                        ],
                        stdout=subprocess.DEVNULL,
                        stderr=subprocess.DEVNULL,
                        check=False,
                    )
                except Exception as e:
                    log.warning(f"Failed to delete tun {tun_name}: {e}")


if __name__ == "__main__":
    main()

# --- ./build/lib/socks5tun/server.py ---
# server.py
import os
import inspect
import psutil
import traceback
import socket
import threading
import select
import logging
import ipaddress

from socks5tun.config import Config

# SOCKS5 protocol constants and values
SOCKS_VERSION = 5
# Authentication methods
NO_AUTH = 0x00
USER_AUTH = 0x02
NO_ACCEPTABLE = 0xFF
# Command codes
CMD_CONNECT = 0x01
CMD_BIND = 0x02  # BIND not implemented
CMD_UDP_ASSOCIATE = 0x03
# Address types
ADDR_IPV4 = 0x01
ADDR_DOMAIN = 0x03
ADDR_IPV6 = 0x04
# Reply codes
REP_SUCCESS = 0x00
REP_GENERAL_FAILURE = 0x01
REP_CONN_NOT_ALLOWED = 0x02
REP_NETWORK_UNREACHABLE = 0x03
REP_HOST_UNREACHABLE = 0x04
REP_CONN_REFUSED = 0x05
REP_TTL_EXPIRED = 0x06
REP_CMD_NOT_SUPPORTED = 0x07
REP_ADDR_NOT_SUPPORTED = 0x08


# Порты, с которых мы ожидаем локальный форвардинг (stunnel, ssh -L, tun2socks и т.п.)
LOCAL_FORWARD_WHITELIST = {443, 1080, 1194}


def is_self_connection(
    client_ip: str, client_port: int, server_port: int
) -> tuple[str, str]:
    """
    Определяет тип соединения:
    - 'self' — loopback + клиентский порт = порт сервера (реальный self-connect)
    - 'local_forward' — loopback + порт клиента в whitelist (ожидаемый локальный форвардер)
    - 'local_other' — loopback всё остальное
    - 'other' — всё остальное
    """
    try:
        ip_obj = ipaddress.ip_address(client_ip)
    except ValueError:
        ip_obj = None

    if ip_obj and ip_obj.is_loopback:
        pname = "unknown"
        pid = None
        for conn in psutil.net_connections(kind='tcp'):
            if not conn.laddr or not conn.raddr:
                continue
            if (
                conn.laddr[1] == server_port
                and conn.raddr[0] == client_ip
                and conn.raddr[1] == client_port
            ):
                pid = conn.pid
                if pid:
                    try:
                        pname = psutil.Process(pid).name()
                    except Exception:
                        pass
                break

        # 1. Настоящий self-connect
        if client_port == server_port:
            return "self", f"{pid} {pname}"

        # 2. Локальный форвард (по whitelist портов)
        if client_port in LOCAL_FORWARD_WHITELIST:
            return "local_forward", f"{pid} {pname}"

        # 3. Остальное loopback
        return "local_other", f"{pid} {pname if pname else 'unknown'}"

    return "other", "unknown"


def recv_exact(conn, n):
    """Читает ровно n байт из сокета, иначе выбрасывает исключение."""
    data = b''
    while len(data) < n:
        chunk = conn.recv(n - len(data))
        if not chunk:
            raise IOError("Connection closed prematurely")
        data += chunk
    return data


class SocksServer:
    """
    A Socks5 proxy server that handles TCP CONNECT and UDP ASSOCIATE commands.
    """

    def __init__(self, config: Config, tun=None):
        self.config = config
        self.tun = tun  # DummyTun or real TUN interface if provided
        self._log = logging.getLogger("socks5-server")
        # Prepare allowed client networks
        self.allowed_nets = config.allowed_clients
        # Authentication setup
        self.auth_required = config.auth is not None
        self.auth_credentials = config.auth if config.auth else {}

    def start(self):
        """
        Start the Socks5 server: bind and listen for incoming connections,
        handle each in a new thread.
        """

        self._log.warning(
            "[DEBUG] Server started — stack:\n%s",
            ''.join(traceback.format_stack(limit=10)),
        )

        # Выбираем тип адреса
        family = socket.AF_INET6 if ':' in self.config.tcp_host else socket.AF_INET
        with socket.socket(family, socket.SOCK_STREAM) as server_sock:
            server_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            server_sock.bind((self.config.tcp_host, self.config.tcp_port))
            server_sock.listen()
            self._log.info(
                "Listening on %s:%d",
                self.config.tcp_host,
                self.config.tcp_port,
            )

            while True:
                try:
                    client_sock, client_addr = server_sock.accept()

                    # --- NEW: проверка IP клиента ---
                    if not self._is_client_allowed(client_addr[0]):
                        self._log.warning(
                            "Rejected connection from %s:%d "
                            "(not in allowed_clients)",
                            client_addr[0],
                            client_addr[1],
                        )
                        client_sock.close()
                        continue  # ждём следующий accept
                    # --------------------------------

                    # Определяем тип подключения и информацию о процессе
                    ctype, who = is_self_connection(
                        client_addr[0], client_addr[1], self.config.tcp_port
                    )

                    if ctype == "self":
                        # Настоящий self-test
                        self._log.info(
                            "[🧪 SELF-TEST] Accepted internal connection "
                            "from %s:%d (%s)",
                            client_addr[0],
                            client_addr[1],
                            who,
                        )
                        stack = inspect.stack()
                        self._log.debug(
                            "Top call: %s:%d in %s()",
                            stack[1].filename,
                            stack[1].lineno,
                            stack[1].function,
                        )

                    elif ctype == "local_stunnel":
                        # Локальный stunnel на loopback
                        self._log.info(
                            "[LOCAL STUNNEL] TCP connection from %s:%d (%s)",
                            client_addr[0],
                            client_addr[1],
                            who,
                        )

                    elif ctype == "local_other":
                        self._log.info(
                            "[LOCAL] TCP connection from %s:%d (%s)",
                            client_addr[0],
                            client_addr[1],
                            who,
                        )

                    elif ctype == "local_forward":
                        self._log.info(
                            "[LOCAL FORWARD] TCP connection from %s:%d (%s)",
                            client_addr[0],
                            client_addr[1],
                            who,
                        )

                    else:
                        # Любое другое подключение
                        self._log.info(
                            "[ACCEPT] TCP connection from %s:%d by %s",
                            client_addr[0],
                            client_addr[1],
                            who,
                        )
                        self._log.debug(
                            "[TRACE] Stack trace for connection from %s:%d:\n%s",
                            client_addr[0],
                            client_addr[1],
                            ''.join(traceback.format_stack(limit=8)),
                        )

                    # Запускаем обработчик клиента в отдельном потоке
                    threading.Thread(
                        target=self._handle_client,
                        args=(client_sock, client_addr),
                        daemon=True,
                    ).start()

                except OSError:
                    break

    def _is_client_allowed(self, client_ip: str) -> bool:
        """Check if the client IP is in allowed networks."""
        ip_obj = ipaddress.ip_address(client_ip)
        return any(ip_obj in net for net in self.allowed_nets)

    def _is_dest_allowed(self, dest_ip: str, dest_port: int) -> bool:
        """Check if the destination IP:
        port is permitted by allow/deny rules."""
        try:
            ip_obj = ipaddress.ip_address(dest_ip)
        except Exception:
            return False
        # Deny rules
        for net, port in getattr(self.config, "deny_rules", []):
            if ip_obj in net and (port is None or dest_port == port):
                return False
        # Allow rules
        allow_rules = getattr(self.config, "allow_rules", [])
        if allow_rules:
            allowed = False
            for net, port in allow_rules:
                if ip_obj in net and (port is None or dest_port == port):
                    allowed = True
                    break
            if not allowed:
                return False
        return True

    def _handle_client(self, conn: socket.socket, client_addr):
        if client_addr[0] == "127.0.0.1":
            self._log.warning(
                "👀 LOCAL connection from %s — likely self-initiated",
                client_addr[0],
            )

        try:
            # Для DummySocket в тестах отключаем setsockopt
            if hasattr(conn, "setsockopt"):
                conn.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)

            header = recv_exact(conn, 2)
            self._log.warning(
                "[SNIFF] First 2 bytes from %s:%d: hex=%s ascii=%r",
                client_addr[0],
                client_addr[1],
                header.hex(),
                header,
            )
            proto_guess = None
            if header.startswith(b"PO") or header.startswith(b"GE"):
                proto_guess = "HTTP"
            elif header.startswith(b"\x16\x03"):
                proto_guess = "TLS"
            elif header.startswith(b"CO"):
                proto_guess = "HTTPS proxy (CONNECT)"
            elif header[0] != 0x05:
                proto_guess = "Unknown non-SOCKS"

            if proto_guess:
                self._log.warning(
                    "[GUESS] %s:%d likely using %s instead of SOCKS5",
                    client_addr[0],
                    client_addr[1],
                    proto_guess,
                )
            ver, nmethods = header[0], header[1]
            self._log.info(
                "SOCKS5 handshake header from %s: %s", client_addr[0], header.hex()
            )

            if ver != SOCKS_VERSION:
                self._log.error(
                    "Unsupported SOCKS version %d from %s", ver, client_addr[0]
                )
                conn.close()
                return

            methods = recv_exact(conn, nmethods)
            self._log.info(
                "SOCKS5 methods from %s: %s",
                client_addr[0],
                methods.hex(),
            )

            self._log.debug(
                "[DEBUG] Waiting for SOCKS5 request from %s:%d...",
                client_addr[0],
                client_addr[1],
            )

            if self.auth_required:
                if USER_AUTH not in methods:
                    conn.sendall(bytes([SOCKS_VERSION, NO_ACCEPTABLE]))
                    conn.close()
                    return
                conn.sendall(bytes([SOCKS_VERSION, USER_AUTH]))

                ver_auth = recv_exact(conn, 1)
                if ver_auth[0] != 0x01:
                    conn.close()
                    return

                ulen = recv_exact(conn, 1)[0]
                username = recv_exact(conn, ulen).decode()

                plen = recv_exact(conn, 1)[0]
                password = recv_exact(conn, plen).decode()

                if username != self.auth_credentials.get(
                    "username"
                ) or password != self.auth_credentials.get("password"):
                    conn.sendall(bytes([0x01, 0x01]))
                    self._log.warning(
                        "Authentication failed for %s",
                        client_addr[0],
                    )
                    conn.close()
                    return
                else:
                    conn.sendall(bytes([0x01, 0x00]))
            else:
                if NO_AUTH in methods:
                    conn.sendall(bytes([SOCKS_VERSION, NO_AUTH]))
                else:
                    conn.sendall(bytes([SOCKS_VERSION, NO_ACCEPTABLE]))
                    conn.close()
                    return

            self._log.debug(
                "[DEBUG] Waiting for SOCKS5 request from %s:%d...",
                client_addr[0],
                client_addr[1],
            )

            # Добавь timeout через select (например, 3 секунды)
            ready, _, _ = select.select([conn], [], [], 3)
            if not ready:
                self._log.warning(
                    "[TIMEOUT] Client %s:%d did not send "
                    "SOCKS5 request after handshake",
                    client_addr[0],
                    client_addr[1],
                )
                conn.close()
                return
            request = recv_exact(conn, 4)

            self._log.info(
                "SOCKS5 request header from %s: %s",
                client_addr[0],
                request.hex(),
            )
            ver, cmd, _, atyp = request

            if ver != SOCKS_VERSION:
                self._log.error(
                    "Mismatched SOCKS version in request from %s",
                    client_addr[0],
                )
                conn.close()
                return

            if cmd == CMD_CONNECT:
                self._handle_connect(conn, atyp, client_addr)
            elif cmd == CMD_UDP_ASSOCIATE:
                self._handle_udp_associate(conn, atyp, client_addr)
            else:
                self._send_reply(
                    conn,
                    REP_CMD_NOT_SUPPORTED,
                    bind_ip="0.0.0.0",
                    bind_port=0,
                    atyp=ADDR_IPV4,
                )
                conn.close()

        except ConnectionResetError:
            self._log.warning(
                "Client %s forcibly closed the connection (RST)",
                client_addr[0],
            )
        except EOFError:
            self._log.warning(
                "Client %s closed connection with EOF",
                client_addr[0],
            )
        except Exception as e:
            is_self, who = is_self_connection(
                client_addr[0], client_addr[1], self.config.tcp_port
            )
            if is_self or client_addr[0] == "127.0.0.1":
                self._log.info(
                    "🔁 [LOCAL/SELF] "
                    "Connection from %s "
                    "closed prematurely "
                    "(%s)",
                    client_addr[0],
                    who if is_self else str(e),
                )
            else:
                self._log.error(
                    "Error handling client %s: %s",
                    client_addr[0],
                    e,
                )

        finally:
            try:
                conn.close()
            except Exception:
                pass

    def _handle_connect(self, conn: socket.socket, atyp: int, client_addr):
        """Handle SOCKS5 CONNECT (TCP forwarding)"""
        try:
            dest_addr, dest_port = self._read_dest_address(conn, atyp)
        except Exception as e:
            self._log.error(
                "Failed to parse destination address from %s: %s",
                client_addr[0],
                e,
            )
            rep = (
                REP_ADDR_NOT_SUPPORTED
                if isinstance(e, ValueError)
                else REP_GENERAL_FAILURE
            )
            self._send_reply(
                conn,
                rep,
                bind_ip="0.0.0.0",
                bind_port=0,
                atyp=ADDR_IPV4,
            )
            conn.close()
            return
        # Check against allow/deny rules
        if not self._is_dest_allowed(dest_addr, dest_port):
            self._log.info(
                "Blocked destination %s requested by %s",
                dest_addr,
                client_addr[0],
            )
            self._send_reply(
                conn,
                REP_CONN_NOT_ALLOWED,
                bind_ip="0.0.0.0",
                bind_port=0,
                atyp=ADDR_IPV4,
            )
            conn.close()
            return
        # Create remote socket to target
        remote_family = socket.AF_INET6 if ':' in dest_addr else socket.AF_INET
        try:
            remote_sock = socket.socket(remote_family, socket.SOCK_STREAM)
            remote_sock.connect((dest_addr, dest_port))
        except socket.error as e:
            err_no = getattr(e, 'errno', None)
            if err_no in (111, 61):
                rep = REP_CONN_REFUSED
            elif err_no in (113, 101):
                rep = REP_HOST_UNREACHABLE
            else:
                rep = REP_GENERAL_FAILURE
            self._log.error(
                "TCP Connect to %s:%d failed: %s",
                dest_addr,
                dest_port,
                e,
            )
            self._send_reply(
                conn,
                rep,
                bind_ip="0.0.0.0",
                bind_port=0,
                atyp=ADDR_IPV4,
            )
            conn.close()
            return
        # Connected successfully
        bind_ip, bind_port = remote_sock.getsockname()[:2]
        reply_atyp = ADDR_IPV6 if remote_family == socket.AF_INET6 else ADDR_IPV4
        self._send_reply(
            conn,
            REP_SUCCESS,
            bind_ip=bind_ip,
            bind_port=bind_port,
            atyp=reply_atyp,
        )
        self._log.info(
            "Established TCP tunnel from %s to %s:%d",
            client_addr[0],
            dest_addr,
            dest_port,
        )
        try:
            self._exchange_loop(conn, remote_sock)
        finally:
            remote_sock.close()
            conn.close()
            self._log.info("Closed TCP tunnel for %s", client_addr[0])

    def _handle_udp_associate(
        self,
        conn: socket.socket,
        atyp: int,
        client_addr,
    ):
        """Handle SOCKS5 UDP ASSOCIATE (UDP relay)"""
        try:
            client_ip, client_port = self._read_dest_address(conn, atyp)
        except Exception:
            client_ip, client_port = client_addr[0], 0
        # Determine address and port for UDP relay from config
        bind_ip = self.config.udp_host
        if bind_ip == "0.0.0.0":
            bind_ip = conn.getsockname()[0]
            if bind_ip == "0.0.0.0":
                bind_ip = "0.0.0.0"
        if bind_ip in ("::", "::0", "0:0:0:0:0:0:0:0"):
            local_ip = conn.getsockname()[0]
            if local_ip and local_ip != "::":
                bind_ip = local_ip
            else:
                bind_ip = "::"
        reply_atyp = ADDR_IPV6 if ':' in bind_ip else ADDR_IPV4
        self._send_reply(
            conn,
            REP_SUCCESS,
            bind_ip=bind_ip,
            bind_port=self.config.udp_port,
            atyp=reply_atyp,
        )
        self._log.info(
            "UDP association established with %s, UDP relay port %d",
            client_addr[0],
            self.config.udp_port,
        )
        try:
            conn.recv(1)
        except Exception:
            pass
        conn.close()
        self._log.info("Closed UDP association for %s", client_addr[0])

    def _exchange_loop(
        self,
        client_sock: socket.socket,
        remote_sock: socket.socket,
    ):
        """Relay data between client
        and remote sockets until one side closes."""
        while True:
            rlist, _, _ = select.select([client_sock, remote_sock], [], [])
            if client_sock in rlist:
                data = client_sock.recv(4096)
                if not data:
                    break
                remote_sock.sendall(data)
            if remote_sock in rlist:
                data = remote_sock.recv(4096)
                if not data:
                    break
                client_sock.sendall(data)

    def _send_reply(
        self,
        conn: socket.socket,
        rep: int,
        bind_ip: str,
        bind_port: int,
        atyp: int,
    ):
        """Send a SOCKS5 reply packet
        with given reply code and bind address/port."""
        try:
            if atyp == ADDR_IPV4:
                addr_bytes = socket.inet_aton(bind_ip)
            elif atyp == ADDR_IPV6:
                addr_bytes = socket.inet_pton(socket.AF_INET6, bind_ip)
            elif atyp == ADDR_DOMAIN:
                addr_bytes = bytes([len(bind_ip)]) + bind_ip.encode('utf-8')
            else:
                atyp = ADDR_IPV4
                addr_bytes = b"\x00\x00\x00\x00"
            port_bytes = int(bind_port).to_bytes(2, 'big')
            response = (
                bytes(
                    [
                        SOCKS_VERSION,
                        rep,
                        0x00,
                        atyp,
                    ]
                )
                + addr_bytes
                + port_bytes
            )
            conn.sendall(response)
        except Exception as e:
            self._log.error("Failed to send reply to client: %s", e)

    def _read_dest_address(self, conn: socket.socket, atyp: int):
        """
        Read destination address and port from the client request.
        Returns a tuple (dest_addr, dest_port).
        """
        if atyp == ADDR_IPV4:
            addr_bytes = conn.recv(4)
            if len(addr_bytes) < 4:
                raise IOError("Incomplete IPv4 address")
            dest_addr = socket.inet_ntoa(addr_bytes)
            port_bytes = conn.recv(2)
            if len(port_bytes) < 2:
                raise IOError("Incomplete port")
            dest_port = int.from_bytes(port_bytes, 'big')
            return dest_addr, dest_port
        elif atyp == ADDR_DOMAIN:
            length_byte = conn.recv(1)
            if not length_byte:
                raise IOError("Incomplete domain length")
            length = length_byte[0]
            domain_bytes = conn.recv(length)
            if len(domain_bytes) < length:
                raise IOError("Incomplete domain name")
            dest_domain = domain_bytes.decode('utf-8', 'ignore')
            port_bytes = conn.recv(2)
            if len(port_bytes) < 2:
                raise IOError("Incomplete port")
            dest_port = int.from_bytes(port_bytes, 'big')
            try:
                dest_addr = socket.gethostbyname(dest_domain)
            except Exception as e:
                self._log.warning(
                    "Failed to resolve domain %s: %s",
                    dest_domain,
                    e,
                )
                raise e
            return dest_addr, dest_port
        elif atyp == ADDR_IPV6:
            addr_bytes = conn.recv(16)
            if len(addr_bytes) < 16:
                raise IOError("Incomplete IPv6 address")
            dest_addr = socket.inet_ntop(socket.AF_INET6, addr_bytes)
            port_bytes = conn.recv(2)
            if len(port_bytes) < 2:
                raise IOError("Incomplete port")
            dest_port = int.from_bytes(port_bytes, 'big')
            return dest_addr, dest_port
        else:
            raise ValueError("Unsupported address type %d" % atyp)

# --- ./build/lib/socks5tun/udp_handler.py ---
# udp_handler.py
import socket
import logging
import struct
import threading
from ipaddress import ip_address, ip_network

logger = logging.getLogger("socks5-server")


class UDPHandler:
    def __init__(self, cfg, tun):
        self.cfg = cfg
        self.tun = tun
        self.remote_map = {}
        # Load legacy forbidden networks if present (for compatibility)
        self.forbidden_networks = []
        if hasattr(cfg, "forbidden_networks"):
            for net in cfg.forbidden_networks:
                try:
                    self.forbidden_networks.append(ip_network(net))
                except ValueError:
                    continue

    def _ip_checksum(self, data: bytes) -> int:
        """Calculate IPv4 header checksum."""
        if len(data) % 2 == 1:
            data += b'\x00'
        total = 0
        for i in range(0, len(data), 2):
            word = data[i] << 8 | data[i + 1]
            total += word
        total = (total >> 16) + (total & 0xFFFF)
        total = ~total & 0xFFFF
        return total

    def handle_client_packet(self, data: bytes, client_addr):
        """
        Handle a UDP packet from client (SOCKS5 UDP ASSOCIATE).
        data: raw UDP datagram from client (including SOCKS5 UDP header).
        client_addr: tuple (src_ip, src_port) of the client.
        """
        # Minimum UDP header length is 4 bytes
        if len(data) < 4:
            return
        # Check reserved bytes and fragmentation field
        if data[0] != 0x00 or data[1] != 0x00:
            return  # Invalid reserved field
        frag = data[2]
        if frag != 0x00:
            logger.warning(
                f"Received fragmented UDP packet from {client_addr}, dropping"
            )
            return
        atyp = data[3]
        offset = 4
        dest_addr = None
        dest_port = None
        # Parse destination based on ATYP
        if atyp == 0x01:  # IPv4
            if len(data) < offset + 6:
                return
            dest_addr = socket.inet_ntoa(data[offset : offset + 4])
            offset += 4
            dest_port = struct.unpack("!H", data[offset : offset + 2])[0]
            offset += 2
        elif atyp == 0x03:  # Domain name
            if len(data) < offset + 1:
                return
            name_len = data[offset]
            offset += 1
            if len(data) < offset + name_len + 2:
                return
            dest_name = data[offset : offset + name_len].decode(
                'ascii', errors='ignore'
            )
            offset += name_len
            dest_port = struct.unpack("!H", data[offset : offset + 2])[0]
            offset += 2
            # Resolve domain to IP
            if getattr(self.cfg, "dns_resolver", "system") == "system":
                try:
                    addrs = socket.getaddrinfo(
                        dest_name, dest_port, proto=socket.IPPROTO_UDP
                    )
                except Exception:
                    logger.warning(
                        f"[UDP-DENY ] {client_addr[0]}:{client_addr[1]}"
                        f" → {dest_name}:{dest_port} reason=resolve_fail"
                    )
                    return
            else:
                try:
                    addrs = socket.getaddrinfo(
                        dest_name, dest_port, proto=socket.IPPROTO_UDP
                    )
                except Exception:
                    logger.warning(
                        f"[UDP-DENY ] {client_addr[0]}:{client_addr[1]}"
                        f" → {dest_name}:{dest_port} reason=resolve_fail"
                    )
                    return
            if not addrs:
                logger.warning(
                    f"[UDP-DENY ] {client_addr[0]}:{client_addr[1]}"
                    f" → {dest_name}:{dest_port} reason=resolve_fail"
                )
                return
            dest_addr = addrs[0][4][0]
        elif atyp == 0x04:  # IPv6
            if len(data) < offset + 18:
                return
            try:
                dest_addr = socket.inet_ntop(
                    socket.AF_INET6, data[offset : offset + 16]
                )
            except OSError:
                return
            offset += 16
            dest_port = struct.unpack("!H", data[offset : offset + 2])[0]
            offset += 2
        else:
            return
        payload = data[offset:]
        if dest_addr is None:
            return
        # Apply allow/deny filtering
        allowed = True
        reason = "deny_rule"
        try:
            ip_obj = ip_address(dest_addr)
        except ValueError:
            ip_obj = None
        if ip_obj:
            # Check deny rules
            for net, port in getattr(self.cfg, "deny_rules", []):
                if ip_obj in net and (port is None or dest_port == port):
                    allowed = False
                    break

            # Check legacy forbidden networks if no explicit deny rules
            if allowed and not getattr(self.cfg, "deny_rules", []):
                for net in self.forbidden_networks:
                    if ip_obj in net:
                        allowed = False
                        break

            # Check allow rules
            if allowed and getattr(self.cfg, "allow_rules", []):
                matched = False
                for net, port in self.cfg.allow_rules:
                    if ip_obj in net and (port is None or dest_port == port):
                        matched = True
                        break
                if not matched:
                    allowed = False
        else:
            allowed = False
        if not allowed:
            logger.warning(
                f"[UDP-DENY ] {client_addr[0]}:{client_addr[1]}"
                f" → {dest_addr}:{dest_port} reason={reason}"
            )
            return
        # Build packet and forward to TUN (IPv4 only)
        ip_obj = ip_address(dest_addr)
        if ip_obj.version == 4:
            src_ip = client_addr[0]
            src_port = client_addr[1] & 0xFFFF
            dst_ip = dest_addr
            # IPv4 header
            version = 4
            ihl = 5
            ver_ihl = (version << 4) + ihl
            tos = 0
            total_length = 20 + 8 + len(payload)
            identification = 0
            flags_offset = 0
            ttl = 64
            protocol = socket.IPPROTO_UDP
            src_ip_bytes = socket.inet_aton(src_ip)
            dst_ip_bytes = socket.inet_aton(dst_ip)
            # Initial header with zero checksum
            ip_header = struct.pack(
                "!BBHHHBBH4s4s",
                ver_ihl,
                tos,
                total_length,
                identification,
                flags_offset,
                ttl,
                protocol,
                0,
                src_ip_bytes,
                dst_ip_bytes,
            )
            checksum = self._ip_checksum(ip_header)
            # Final IP header with checksum
            ip_header = struct.pack(
                "!BBHHHBBH4s4s",
                ver_ihl,
                tos,
                total_length,
                identification,
                flags_offset,
                ttl,
                protocol,
                checksum,
                src_ip_bytes,
                dst_ip_bytes,
            )
            # UDP header
            dst_port_net = dest_port & 0xFFFF
            udp_length = 8 + len(payload)
            udp_header = struct.pack(
                "!HHHH",
                src_port,
                dst_port_net,
                udp_length,
                0,
            )
            packet = ip_header + udp_header + payload
            self.tun.write(packet)
            self.remote_map[(dest_addr, dest_port)] = client_addr
        elif ip_obj.version == 6:
            logger.warning(
                f"Cannot forward UDP to IPv6 address"
                f" {dest_addr} "
                f"(not supported)"
            )
            return
        else:
            return
        # Log forwarded packet as allowed
        logger.info(
            f"[UDP-ALLOW] {client_addr[0]}:{client_addr[1]}"
            f" → {dest_addr}:{dest_port} len={len(payload)}"
        )


def start_udp_loop(cfg, tun):
    """
    Start a loop to handle global UDP relay.
    Listens on cfg.udp_host:cfg.udp_port for UDP traffic.
    """
    family = socket.AF_INET6 if ':' in cfg.udp_host else socket.AF_INET
    udp_sock = socket.socket(family, socket.SOCK_DGRAM)
    logger.debug("[BOOT] Entered start_udp_loop()")
    try:
        udp_sock.bind((cfg.udp_host, cfg.udp_port))
    except OSError as e:
        logger.error(
            "Failed to bind UDP socket on %s:%d — %s",
            cfg.udp_host,
            cfg.udp_port,
            e,
        )
        return

    logger.info(
        "[DEBUG] Bound UDP socket on %s:%d",
        cfg.udp_host,
        cfg.udp_port,
    )
    logger.info(f"UDP relay socket listening on {cfg.udp_host}:{cfg.udp_port}")
    # Mapping for direct UDP mode (dest -> client)
    remote_map = {}
    # Handler for client packets
    handler = UDPHandler(cfg, tun)
    handler.remote_map = remote_map
    # If TUN interface is available, start thread to handle incoming packets from TUN
    if tun:

        def tun_reader():
            while True:
                try:
                    packet = tun.read()
                except Exception as e:
                    logger.error("UDP tun read error: %s", e)
                    break
                if not packet:
                    break
                # Only handle IPv4 UDP packets from tun
                if len(packet) < 20:
                    continue
                version = packet[0] >> 4
                if version != 4:
                    # Only IPv4 supported for now
                    continue
                proto = packet[9]
                if proto != socket.IPPROTO_UDP:
                    continue
                src_ip = socket.inet_ntoa(packet[12:16])
                dst_ip = socket.inet_ntoa(packet[16:20])
                src_port = int.from_bytes(packet[20:22], 'big')
                dst_port = int.from_bytes(packet[22:24], 'big')
                payload = packet[28:]
                client_key = (src_ip, src_port)
                # If we have a client for this dest, forward to it
                if client_key in remote_map:
                    client_addr = remote_map[client_key]
                else:
                    # No mapping, drop
                    logger.warning(
                        f"Received UDP packet from {src_ip}:{src_port} with "
                        "no client mapping for {dst_ip}:{dst_port}"
                    )
                    continue
                # Build SOCKS UDP response
                try:
                    if ':' in src_ip:
                        addr_bytes = socket.inet_pton(socket.AF_INET6, src_ip)
                        resp_atyp = 0x04
                    else:
                        addr_bytes = socket.inet_aton(src_ip)
                        resp_atyp = 0x01
                    port_bytes = src_port.to_bytes(2, 'big')
                    resp_header = (
                        b"\x00\x00\x00" + bytes([resp_atyp]) + addr_bytes + port_bytes
                    )
                except Exception as e:
                    logger.error(
                        "Failed to build UDP response header for %s: %s", src_ip, e
                    )
                    continue
                response_data = resp_header + payload
                try:
                    udp_sock.sendto(response_data, client_addr)
                except Exception as e:
                    logger.error(
                        "Failed to send UDP packet to client %s:%d - %s",
                        client_addr[0],
                        client_addr[1],
                        e,
                    )

        threading.Thread(target=tun_reader, daemon=True).start()
    # Main loop to handle incoming UDP datagrams on socket
    logger.debug("[BOOT] Entering UDP receive loop...")

    while True:
        try:
            logger.debug("[LOOP] Waiting for UDP packet...")
            data, addr = udp_sock.recvfrom(65535)
            logger.debug(
                "[TRACE] --- UDP packet received from %s:%d ---",
                addr[0],
                addr[1],
            )

            logger.debug(
                "[DEBUG] Got UDP from %s:%d, len=%d",
                addr[0],
                addr[1],
                len(data),
            )
            client_ip, client_port = addr[0], addr[1]
            try:
                ip_obj = ip_address(client_ip)
            except ValueError:
                ip_obj = None
            is_client = ip_obj is not None and any(
                ip_obj in net for net in cfg.allowed_clients
            )

            # ✅ ДОПОЛНИТЕЛЬНЫЕ ЛОГИ
            logger.debug("[TRACE] UDP packet from: %s:%d", client_ip, client_port)
            logger.debug("[TRACE] Evaluated ip_obj: %s", ip_obj)
            logger.debug("[TRACE] allowed_clients: %s", cfg.allowed_clients)
            logger.debug("[TRACE] is_client: %s", is_client)

        except Exception as e:
            logger.error("UDP socket error: %s", e)
            break
        client_ip, client_port = addr[0], addr[1]
        try:
            ip_obj = ip_address(client_ip)
        except ValueError:
            ip_obj = None
        is_client = ip_obj is not None and any(
            ip_obj in net for net in cfg.allowed_clients
        )
        logger.debug("[CHECK] Incoming UDP from %s:%d", client_ip, client_port)
        logger.debug("[CHECK] allowed_clients = %s", cfg.allowed_clients)
        logger.debug("[CHECK] ip_obj = %s", ip_obj)
        logger.debug("[CHECK] is_client = %s", is_client)

        if is_client:
            # UDP datagram from an allowed client
            if tun:
                logger.debug(
                    "[DEBUG] handle_client_packet from %s:%d, raw: %s",
                    addr[0],
                    addr[1],
                    data.hex(),
                )
                try:
                    handler.handle_client_packet(data, addr)
                except Exception as e:
                    logger.error("Exception in handle_client_packet: %s", e)

            else:
                # Handle direct UDP forward (no TUN)

                if len(data) < 4:
                    continue
                if data[0] != 0x00 or data[1] != 0x00:
                    continue
                frag = data[2]
                if frag != 0x00:
                    continue
                atyp = data[3]
                off = 4
                dest_addr = None
                dest_port = None
                if atyp == 0x01:
                    if len(data) < off + 6:
                        continue
                    dest_addr = socket.inet_ntoa(data[off : off + 4])
                    off += 4
                    dest_port = int.from_bytes(data[off : off + 2], 'big')
                    off += 2
                elif atyp == 0x03:
                    if len(data) < off + 1:
                        continue
                    name_len = data[off]
                    off += 1
                    if len(data) < off + name_len + 2:
                        continue
                    dest_name = data[off : off + name_len].decode(
                        'ascii', errors='ignore'
                    )
                    off += name_len
                    dest_port = int.from_bytes(data[off : off + 2], 'big')
                    off += 2
                    try:
                        dest_addr = socket.gethostbyname(dest_name)
                    except Exception as e:
                        logger.warning(
                            f"[UDP-DENY ] {client_ip}:{client_port}"
                            f" → {dest_name}:{dest_port} reason=resolve_fail"
                        )
                        continue
                elif atyp == 0x04:
                    if len(data) < off + 18:
                        continue
                    try:
                        dest_addr = socket.inet_ntop(
                            socket.AF_INET6, data[off : off + 16]
                        )
                    except OSError:
                        continue
                    off += 16
                    dest_port = int.from_bytes(data[off : off + 2], 'big')
                    off += 2
                else:
                    continue
                payload = data[off:]
                if dest_addr is None:
                    continue
                # Filtering
                allowed = True
                reason = "deny_rule"
                try:
                    dest_ip_obj = ip_address(dest_addr)
                except ValueError:
                    dest_ip_obj = None
                if dest_ip_obj:
                    for net, port in getattr(cfg, "deny_rules", []):
                        if dest_ip_obj in net and (port is None or dest_port == port):
                            allowed = False
                            break
                    if allowed and getattr(cfg, "allow_rules", []):
                        match = False
                        for net, port in cfg.allow_rules:
                            if dest_ip_obj in net and (
                                port is None or dest_port == port
                            ):
                                match = True
                                break
                        if not match:
                            allowed = False
                else:
                    allowed = False
                if not allowed:
                    logger.warning(
                        f"[UDP-DENY ] {client_ip}:{client_port}"
                        f" → {dest_addr}:{dest_port} reason={reason}"
                    )
                    continue
                # Forward to remote
                try:
                    logger.debug(
                        "[SEND] Sending UDP to %s:%d (payload %d bytes): %s",
                        dest_addr,
                        dest_port,
                        len(payload),
                        payload.hex(),
                    )
                    udp_sock.sendto(payload, (dest_addr, dest_port))
                except Exception as e:
                    logger.error(
                        "Failed to relay UDP to %s:%d - %s",
                        dest_addr,
                        dest_port,
                        e,
                    )
                    continue
                # Update mapping for return traffic
                remote_map[(dest_addr, dest_port)] = addr
                logger.info(
                    f"[UDP-ALLOW] {client_ip}:{client_port}"
                    f" → {dest_addr}:{dest_port} len={len(payload)}"
                )
        else:
            # UDP datagram from remote host
            logger.debug(
                "[REJECT] UDP from %s:%d rejected: not in allowed_clients",
                client_ip,
                client_port,
            )
            if tun:
                # Should not happen (remote replies handled via tun), ignore
                continue
            # Direct mode: relay back to client if known
            remote_ip, remote_port = client_ip, client_port
            if (remote_ip, remote_port) not in remote_map:
                continue
            client_addr = remote_map[(remote_ip, remote_port)]
            # Build SOCKS UDP response
            try:
                if ':' in remote_ip:
                    addr_bytes = socket.inet_pton(socket.AF_INET6, remote_ip)
                    resp_atyp = 0x04
                else:
                    addr_bytes = socket.inet_aton(remote_ip)
                    resp_atyp = 0x01
                port_bytes = remote_port.to_bytes(2, 'big')
                resp_header = (
                    b"\x00\x00\x00" + bytes([resp_atyp]) + addr_bytes + port_bytes
                )
            except Exception as e:
                logger.error(
                    "Failed to build UDP response header for %s: %s",
                    remote_ip,
                    e,
                )
                continue
            response_data = resp_header + data
            udp_sock.sendto(response_data, client_addr)

# --- ./README.md ---
## Логирование UDP-трафика

По умолчанию приложение логирует весь UDP-трафик — как **разрешённый**, так и **заблокированный**.

- Разрешённые UDP-пакеты записываются в журнал уровня INFO с префиксом `[UDP-ALLOW]`. В сообщении указываются исходный адрес:порт клиента, адрес:порт назначения и размер переданных данных.
- Заблокированные UDP-пакеты записываются в журнал уровня WARNING с префиксом `[UDP-DENY ]`. В сообщении указываются исходный адрес:порт клиента, адрес:порт назначения и причина блокировки (например, `reason=deny_rule`).

Пример фрагмента журнала UDP-трафика:

```text
[UDP-ALLOW] 192.0.2.10:39522 → 8.8.8.8:53 len=42
[UDP-DENY ] 10.0.0.5:60234 → 192.168.0.1:80 reason=deny_rule
```

---

## Автосетап TUN/NAT

Если в конфигурационном файле (`config.json`) заданы параметры блоков:

```json
"tun": {
  "name": "tun0",
  "address": "10.8.0.1",
  "netmask": "255.255.255.0",
  "peer_address": "10.8.0.2",
  "mtu": 1500
},
"nat": {
  "out_iface": "eth0"
}
```

то при старте сервера **TUN‑интерфейс** и **NAT‑правила** будут настраиваться автоматически.

- Автосетап выполняется **только**, если процесс запущен с правами `root` (`UID 0`).
- В тестовом или CI‑окружении, где нет root‑доступа, авто‑сетап будет пропущен, и в логах появится предупреждение:

```text
[WARNING] Skipping TUN/NAT auto-setup: not running as root (UID != 0)
```

---

## Базовая настройка брандмауэра (UFW)

Для ограничения внешнего доступа рекомендуется разрешить только необходимые порты:

```bash
ufw default deny incoming
ufw default allow outgoing
ufw allow 22/tcp comment "SSH"
ufw allow 443/tcp comment "TLS (stunnel)"
ufw enable
```

- Это закроет все входящие соединения, кроме SSH и TLS‑порта, используемого stunnel.
- Порт SOCKS5 (например, 5000/tcp), на котором слушает Python‑сервер, при этом будет доступен **только локально** (127.0.0.1) и через stunnel.
- Если требуется прямой внешний доступ к SOCKS5, добавьте правило:

```bash
ufw allow 5000/tcp comment "SOCKS5 direct"
```

---

## Мини-бэкап конфигураций `/etc`

Для автоматического отслеживания и возможности отката изменений в системных конфигурациях `/etc` рекомендуется установить:

```bash
sudo apt install -y etckeeper
cd /etc
sudo etckeeper init
sudo etckeeper commit -m "Initial server snapshot"
```

Теперь изменения `/etc` будут отслеживаться с помощью Git. Это удобно при ручной настройке `ufw`, `ssh`, `resolv.conf`, и т.д.

---

## Потенциальное улучшение: базовая защита SSH

Для повышения безопасности SSH можно добавить отдельный файл настроек `/etc/ssh/sshd_config.d/hardening.conf`:

```conf
PermitRootLogin no
PasswordAuthentication no
ClientAliveInterval 300
ClientAliveCountMax 2
```

- **PermitRootLogin no** — запрет входа под root по SSH.
- **PasswordAuthentication no** — отключение входа по паролю (только по SSH-ключу).
- **ClientAliveInterval** и **ClientAliveCountMax** — автоматическое завершение сессий при отсутствии активности.

> ⚠️ Перед применением убедитесь, что у вас есть рабочая учётная запись с ключом SSH и правами `sudo`.
> Рекомендуется сначала протестировать вход в новой сессии, и только потом закрывать текущую.

## Потенциальное улучшение: максимальная изоляция `stunnel`

В будущем возможно реализовать запуск `stunnel` с усиленной безопасностью. Это актуально при открытом или публичном VPN-сервисе с несколькими пользователями.

### ✅ Отдельный системный пользователь

```bash
sudo adduser --system --group --no-create-home stunnel
sudo chown root:stunnel /etc/stunnel
sudo chmod 750 /etc/stunnel
sudo chown root:stunnel /etc/stunnel/stunnel.pem
sudo chmod 640 /etc/stunnel/stunnel.pem
```

### ✅ Вынос PID-файла в безопасное место

```ini
pid = /run/stunnel/stunnel.pid
```

### ✅ Создание каталога и прав на него

```bash
sudo mkdir -p /run/stunnel
sudo chown stunnel:stunnel /run/stunnel
```

### ✅ Выдача capability для портов < 1024

```bash
sudo setcap 'cap_net_bind_service=+ep' /usr/bin/stunnel
```

### ✅ Защита через systemd (в unit-файле)

```ini
NoNewPrivileges=true
ProtectSystem=full
ReadOnlyPaths=/etc/stunnel
```

### 🧱 (опционально) chroot

Если требуется полная изоляция файловой системы (FS), возможно использование `chroot` — но это требует ручной подготовки окружения (библиотек, /dev/null и т.п.).

> Эти меры изолируют `stunnel` от остальной системы, даже если произойдёт взлом или утечка ключей.

Применить изменения:

```bash
sudo systemctl restart ssh
```

---

## Обновление и управление сервисом SOCKS5TUN

Проект включает встроенную систему обновления и перезапуска через связку:

- `update_socks5tun` — исполняемый скрипт/модуль, отвечающий за загрузку, установку или замену кода проекта.
- `socks5tun-update.service` — вспомогательный systemd-сервис, выполняющий `update_socks5tun` перед запуском основного прокси.
- `socks5tun.service` — основной сервис, запускающий SOCKS5-прокси сервер.

### Схема запуска

1. При запуске `socks5tun.service` автоматически **выполняется `socks5tun-update.service`**, если он указан как `Requires` + `After` в `Unit`-блоке.
2. Только **после успешного завершения обновления** стартует основной сервер.

Такой подход гарантирует, что при перезапуске системы или сервиса будет использоваться **актуальная версия** кода.

### Вручную

Для ручного запуска без обновления:

```bash
sudo systemctl start socks5tun.service
```

Для запуска только обновления (без старта прокси):

```bash
sudo systemctl start socks5tun-update.service
```

Для выполнения обновления вручную (если `update_socks5tun` — исполняемый файл):

```bash
sudo /usr/local/bin/update_socks5tun
```

---

## Работа с systemd

После изменения `.service`‑файлов **не забудьте перезагрузить systemd**:

```bash
sudo systemctl daemon-reload
```

Перезапуск сервиса:

```bash
sudo systemctl restart socks5tun.service
```

Просмотр логов:

```bash
journalctl -u socks5tun.service -f
```

Если вы изменили только Python‑код (`*.py`) — `daemon-reload` **не требуется**, достаточно `restart`.

---

## Размещение файлов

- `update_socks5tun` должен быть исполняемым (`chmod +x`) и доступным в PATH или по абсолютному пути (например, `/usr/local/bin/`).
- Юнит‑файлы systemd обычно размещаются в `/etc/systemd/system/`:

```bash
/etc/systemd/system/socks5tun.service
/etc/systemd/system/socks5tun-update.service
```

Проверь, чтобы они были включены в автозагрузку:

```bash
sudo systemctl enable socks5tun.service
```

> Обновление не выполняется, если сервис запускается напрямую (`python run.py`) — только через systemd.

# --- ./setup.py ---
from setuptools import setup, find_packages

setup(
    name="socks5tun",
    version="0.1",
    packages=find_packages(),  # автоматически найдёт socks5tun/
    include_package_data=True,
    python_requires=">=3.8",
)
[32m[INFO] === MISC FILES ===(B[m

# --- ./help.txt ---
# Активировать окружение на сервере:
source /opt/venv-pyroute/bin/activate

# Архивировать папку tests
zip -r tests_with_ci.zip tests .github/workflows/test.yml

# Создать txt файл с содержимым test + ДЕРЕВО
./diagnostics/collect_tests.sh


### Запуск проекта:
## Запуска через автомат

# перезапуск systemd, если были обновления systemd
sudo systemctl daemon-reexec

# обновляет конфигурацию systemd (нужно после изменения .service файла)
sudo systemctl daemon-reload

# перезапуск проекта
sudo systemctl restart socks5tun.service

# логи он-лайн
sudo journalctl -fu socks5tun.service

## Запуск вручную
# Тестовый запуск проекта
python -m socks5tun.run -c config_dev.json

# Рабочий запуск
python -m socks5tun.run


### Прочее
# stunnel на сервере
sudo nano /etc/stunnel/stunnel.conf

# Запустить тесты
pytest -q

# Вернутся в проект
cd ~/socks5tun
# --- ./config_dev.json ---
{
    "tcp_host": "127.0.0.1",
    "tcp_port": 1080,
    "udp_host": "127.0.0.1",
    "udp_port": 1080,
    "tun_mode": "dummy",
    "log_level": "INFO",
    "auth": null,
    "allowed_clients": [
        "127.0.0.1/32"
    ],
    "blocked_destinations": [
        "0.0.0.0/8",
        "10.0.0.0/8",
        "127.0.0.0/8",
        "169.254.0.0/16",
        "172.16.0.0/12",
        "192.168.0.0/16",
        "240.0.0.0/4"
    ],
    "dns_resolver": "system"
}
# --- ./.github/workflows/test.yml ---
name: CI
on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  tests:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: [3.12]
    steps:
      - uses: actions/checkout@v3
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      - name: Run tests
        run: pytest

# --- ./config_prod.json ---
{
  "tcp_host": "0.0.0.0",
  "tcp_port": 5000,
  "udp_host": "0.0.0.0",
  "udp_port": 5000,
  "tun_mode": "linux",
  "log_level": "DEBUG",

  "tun": {
    "name": "tun0",
    "address": "10.8.0.1",
    "netmask": "255.255.255.0",
    "peer_address": "10.8.0.2",
    "mtu": 1500
  },

  "nat": {
    "out_iface": "eth0"
  },

  "auth": null,
  "allowed_clients": ["0.0.0.0/0"],
  "blocked_destinations": [
    "0.0.0.0/8", "10.0.0.0/8", "127.0.0.0/8",
    "169.254.0.0/16", "172.16.0.0/12", "192.168.0.0/16",
    "240.0.0.0/4"
  ],
  "dns_resolver": "system",
  "self_check": true
}

# --- ./build/lib/socks5tun/dummy_tun.py ---
"""
Dummy TUN interface for simulating a TUN device.
"""

import threading
import traceback
import logging
from collections import deque


class DummyTun:
    """
    A dummy TUN interface that mimics a TUN device for testing or environments
    where a real TUN device is not available.
    Data written to this dummy interface
    is stored, and data can be injected for reading.
    """

    def __init__(self):
        # Queues for incoming (to be read) and outgoing (written) data
        self._incoming_data = deque()
        self._outgoing_data = deque()
        self._lock = threading.Lock()
        # Conditions to wait for data availability
        self._incoming_cond = threading.Condition(self._lock)
        self._outgoing_cond = threading.Condition(self._lock)
        self.active = False

    def open(self):
        """
        Open/initialize the dummy TUN interface.
        (For a real TUN, this would create the TUN device.
        Here we just mark it active.)
        """
        with self._lock:
            self.active = True

    def read(self, size: int = 1500) -> bytes:
        """
        Read data from the dummy TUN interface
        (blocking until data is available or interface is closed).
        Returns bytes of data, or b'' if the interface is closed.
        """
        with self._incoming_cond:
            # Wait until data is available or the interface becomes inactive
            while not self._incoming_data and self.active:
                self._incoming_cond.wait()
            if not self.active and not self._incoming_data:
                # Interface closed and no data remaining
                return b""
            data = self._incoming_data.popleft()
        # Return up to 'size' bytes from the data (simulate reading a packet)
        if size and len(data) > size:
            remaining = data[size:]
            # Put the remaining back to be read next time
            with self._incoming_cond:
                self._incoming_data.appendleft(remaining)
            return data[:size]
        else:
            return data

    def write(self, data: bytes) -> int:
        """
        Write data to the dummy TUN interface.
        (For a real TUN, this would send the packet into the OS network stack.)
        Here we store it in an outgoing queue for inspection.
        Returns the number of bytes written.
        """
        if logging.getLogger().isEnabledFor(logging.DEBUG):
            print("🔄 DummyTun.write() called by:")
            traceback.print_stack(limit=5)
        traceback.print_stack(limit=5)
        with self._outgoing_cond:
            self._outgoing_data.append(data)
            # Notify any waiters for outgoing data (if used in tests)
            self._outgoing_cond.notify_all()
        return len(data)

    def inject(self, data: bytes):
        """
        Inject data into the dummy TUN interface as
        if it was received from the network.
        This data will be available to read() by the server.
        """
        with self._incoming_cond:
            self._incoming_data.append(data)
            # Notify any thread waiting for incoming data
            self._incoming_cond.notify_all()

    def close(self):
        """
        Close the dummy TUN interface.
        """
        with self._incoming_cond:
            self.active = False
            # Wake up any waiting readers so they can stop
            self._incoming_cond.notify_all()

# --- ./build/lib/socks5tun/config.py ---
"""
Configuration handling for Socks5 proxy server.
"""

import json
import ipaddress


class Config:
    """
    Holds configuration for the Socks5 server.
    """

    def __init__(self, data: dict):
        # TCP and UDP listening addresses and ports
        self.tcp_host: str = data.get("tcp_host", "127.0.0.1")
        self.tcp_port: int = data.get("tcp_port", 1080)
        self.udp_host: str = data.get("udp_host", "127.0.0.1")
        self.udp_port: int = data.get("udp_port", 1080)
        # Full tun/nat configs for easier access
        self.tun = data.get("tun", {})
        self.nat = data.get("nat", {})
        # TUN interface mode (default "dummy")
        self.tun_mode: str = data.get("tun_mode", "dummy")
        self.dns_resolver = data.get("dns_resolver", "system")
        # Logging level
        self.log_level: str = data.get("log_level", "INFO").upper()
        # Authentication credentials (if any)
        auth_data = data.get("auth")
        if (
            auth_data
            and isinstance(auth_data, dict)
            and "username" in auth_data
            and "password" in auth_data
        ):
            self.auth = {
                "username": auth_data["username"],
                "password": auth_data["password"],
            }
        else:
            self.auth = None
        # Allowed client networks
        allowed_list = data.get("allowed_clients", ["0.0.0.0/0"])
        self.allowed_clients = [ipaddress.ip_network(net) for net in allowed_list]
        # Blocked destination networks
        blocked_list = data.get("blocked_destinations", [])
        self.blocked_destinations = [ipaddress.ip_network(net) for net in blocked_list]
        # Backward compatibility
        self.forbidden_networks = data.get("forbidden_networks", [])
        self.blocked_destinations = [
            ipaddress.ip_network(net)
            for net in data.get(
                "blocked_destinations",
                [],
            )
        ]
        self.deny_rules = [(net, None) for net in self.blocked_destinations]
        self.allow_rules = []


def load_config(path: str) -> Config:
    """
    Load configuration from a JSON file and return a Config object.
    Raises FileNotFoundError if file is not found,
    or ValueError if JSON is invalid or contents are not as expected.
    """
    try:
        with open(path, "r") as f:
            data = json.load(f)
    except FileNotFoundError:
        raise
    except json.JSONDecodeError as e:
        raise ValueError(f"Invalid JSON configuration: {e}")

    # Backward compatibility for old keys
    if "tun" in data:
        if "tun_mode" not in data:
            data["tun_mode"] = "linux" if data["tun"] else "disabled"
        data.pop("tun", None)
    if "bind_host" in data or "bind_port" in data:
        raise ValueError(
            "Outdated config keys 'bind_host'/'bind_port' detected; "
            "use 'tcp_host'/'tcp_port' instead."
        )

    # Validate required field types and values
    if "tcp_host" in data and not isinstance(data["tcp_host"], str):
        raise ValueError("tcp_host must be a string")
    if "tcp_port" in data and not isinstance(data["tcp_port"], int):
        raise ValueError("tcp_port must be an integer")
    if "udp_host" in data and not isinstance(data["udp_host"], str):
        raise ValueError("udp_host must be a string")
    if "udp_port" in data and not isinstance(data["udp_port"], int):
        raise ValueError("udp_port must be an integer")
    if "tun_mode" in data:
        if not isinstance(data["tun_mode"], str):
            raise ValueError("tun_mode must be a string")
        if data["tun_mode"] not in {"dummy", "linux", "disabled"}:
            raise ValueError(
                "tun_mode must be one of: 'dummy', " "'linux', or 'disabled'"
            )
    if "log_level" in data and not isinstance(data["log_level"], str):
        raise ValueError("log_level must be a string")
    if "allowed_clients" in data and not isinstance(
        data["allowed_clients"],
        list,
    ):
        raise ValueError("allowed_clients must be a list of network strings")
    if "blocked_destinations" in data and not isinstance(
        data["blocked_destinations"], list
    ):
        raise ValueError(
            "blocked_destinations " "must be " "a list of network " "strings"
        )
    if "auth" in data:
        if data["auth"] is not None:
            if not (
                isinstance(data["auth"], dict)
                and "username" in data["auth"]
                and "password" in data["auth"]
            ):
                raise ValueError(
                    "auth must be an "
                    "object with 'username' "
                    "and 'password', or null"
                )

    # Create and return Config object
    return Config(data)

# --- ./build/lib/socks5tun/logger.py ---
"""
Logging configuration for Socks5 proxy server.
"""
import logging

def setup_logging(level: str):
    """
    Configure logging for the proxy server with the given level.
    """
    # Convert level name to numeric value (default to INFO if unrecognized)
    numeric_level = getattr(logging, level.upper(), logging.INFO)
    logging.basicConfig(
        level=numeric_level,
        format="%(asctime)s [%(levelname)s] [%(threadName)s] %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S"
    )
    # Optionally, adjust logging levels for third-party libraries if needed
    logging.getLogger("urllib3").setLevel(logging.WARNING)

# --- ./build/lib/socks5tun/__init__.py ---

# --- ./build/lib/socks5tun/run.py ---
# run.py
# !/usr/bin/env python3
"""
Entry point for the Socks5 proxy server.
"""
import argparse
import logging
import os
import sys
import threading
import subprocess
import json
import fcntl
import struct
from datetime import datetime

from socks5tun.config import load_config
from socks5tun.logger import setup_logging
from socks5tun.server import SocksServer

logger = logging.getLogger(__name__)


def main():
    parser = argparse.ArgumentParser(description="Socks5 Proxy Server")
    parser.add_argument(
        "-c",
        "--config",
        default="config_prod.json",
        help="Path to configuration JSON file",
    )
    args = parser.parse_args()
    try:
        cfg = load_config(args.config)

    except FileNotFoundError:
        logger.error("Configuration file not found: %s", args.config)
        sys.exit(1)
    except ValueError as e:
        logger.error("Error in configuration: %s", e)
        sys.exit(1)

    # Setup logging with level from config
    setup_logging(cfg.log_level)
    log = logging.getLogger("socks5-server")

    from ipaddress import ip_network

    cfg.allowed_clients = [ip_network(net) for net in cfg.allowed_clients]
    logger.debug(">> allowed_clients converted to: %s", cfg.allowed_clients)

    cfg.blocked_destinations = [ip_network(net) for net in cfg.blocked_destinations]

    if hasattr(cfg, "deny_rules"):
        cfg.deny_rules = [(ip_network(net), port) for net, port in cfg.deny_rules]
        log.debug(">> deny_rules converted to: %s", cfg.deny_rules)

    if hasattr(cfg, "allow_rules"):
        cfg.allow_rules = [(ip_network(net), port) for net, port in cfg.allow_rules]
        log.debug(">> allow_rules converted to: %s", cfg.allow_rules)

    log.info(
        "Starting Socks5 proxy server on %s:%d",
        cfg.tcp_host,
        cfg.tcp_port,
    )
    # If TUN interface is enabled in config, open it
    tun = None
    if cfg.tun_mode:
        try:
            if cfg.tun_mode == "dummy":
                from socks5tun.dummy_tun import DummyTun

                tun = DummyTun()
                tun.open()
                log.info(
                    "Dummy TUN interface opened "
                    "(not connected to "
                    "system network)",
                )
            elif cfg.tun_mode == "linux":

                TUNSETIFF = 0x400454CA
                IFF_TUN = 0x0001
                IFF_NO_PI = 0x1000
                tun_fd = os.open("/dev/net/tun", os.O_RDWR)
                ifs = fcntl.ioctl(
                    tun_fd,
                    TUNSETIFF,
                    struct.pack("16sH", b"tun%d", IFF_TUN | IFF_NO_PI),
                )
                tun_name = ifs[:16].strip(b"\x00").decode('utf-8')
                log.info("🔧 Created TUN interface with name: %s", tun_name)

                class LinuxTun:
                    def __init__(self, fd):
                        self.fd = fd

                    def read(self, size: int = 1500):
                        return os.read(self.fd, size)

                    def write(self, data: bytes):
                        return os.write(self.fd, data)

                    def close(self):
                        os.close(self.fd)

                tun = LinuxTun(tun_fd)
                log.info("Linux TUN interface %s opened", tun_name)

                # --- NEW: авто-конфигурация интерфейса и NAT ---

                if os.geteuid() == 0:
                    tun_ip = cfg.tun.get("address", "10.8.0.1")
                    tun_netmask = cfg.tun.get("netmask", "255.255.255.0")
                    peer_ip = cfg.tun.get("peer_address", "10.8.0.2")
                    mtu = cfg.tun.get("mtu", 1500)
                    out_iface = cfg.nat.get("out_iface")

                    try:
                        subprocess.run(
                            [
                                "ip",
                                "addr",
                                "add",
                                f"{tun_ip}/{tun_netmask}",
                                "peer",
                                peer_ip,
                                "dev",
                                tun_name,
                            ],
                            check=True,
                        )
                        subprocess.run(
                            ["ip", "link", "set", tun_name, "mtu", str(mtu)],
                            check=True,
                        )
                        subprocess.run(
                            ["ip", "link", "set", tun_name, "up"],
                            check=True,
                        )
                        log.info(
                            "Configured IP %s peer %s mtu %s on %s",
                            tun_ip,
                            peer_ip,
                            mtu,
                            tun_name,
                        )
                        # Включаем форвардинг
                        with open("/proc/sys/net/ipv4/ip_forward", "w") as f:
                            f.write("1\n")
                        if out_iface:
                            subprocess.run(
                                [
                                    "iptables",
                                    "-t",
                                    "nat",
                                    "-C",
                                    "POSTROUTING",
                                    "-s",
                                    f"{tun_ip}/{tun_netmask}",
                                    "-o",
                                    out_iface,
                                    "-j",
                                    "MASQUERADE",
                                ],
                                check=False,
                            )
                            subprocess.run(
                                [
                                    "iptables",
                                    "-t",
                                    "nat",
                                    "-A",
                                    "POSTROUTING",
                                    "-s",
                                    f"{tun_ip}/{tun_netmask}",
                                    "-o",
                                    out_iface,
                                    "-j",
                                    "MASQUERADE",
                                ],
                                check=False,
                            )
                            log.info(
                                "Added MASQUERADE rule for %s → %s", tun_name, out_iface
                            )
                    except subprocess.CalledProcessError as e:
                        log.error("Failed to configure TUN/NAT: %s", e)
                        if os.environ.get("ALLOW_CONTINUE_ON_TUN_ERROR") == "1":
                            return
                        else:
                            sys.exit(1)
                else:
                    log.warning(
                        "Skipping TUN/NAT auto-setup: not running as root (UID != 0)"
                    )

                # ------------------------------------------------

            else:
                tun = None
        except Exception as e:
            log.error("Failed to initialize TUN interface: %s", e)
            if os.environ.get("ALLOW_CONTINUE_ON_TUN_ERROR") == "1":
                return
            else:
                sys.exit(1)
    # Start the Socks5 server and UDP relay thread
    from socks5tun.udp_handler import start_udp_loop

    def udp_wrapper():
        try:
            start_udp_loop(cfg, tun)
        except Exception as e:
            log.exception("Exception in UDP thread: %s", e)

    threading.Thread(
        target=udp_wrapper,
        daemon=True,
    ).start()
    os.environ["DISABLE_SELF_CONNECT"] = "1"
    server = SocksServer(cfg, tun=tun)

    try:
        log.info(
            "✅ Starting server, patch is active at %s",
            datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        )
        server.start()
    except KeyboardInterrupt:
        log.info("Server interrupted by user, shutting down")
    finally:
        if tun:
            tun.close()

            if getattr(cfg, "tun_mode", None) == "linux":
                tun_name = cfg.tun.get("name", "tun0")

                # --- Удаляем NAT-правило ---
                try:
                    tun_ip = cfg.tun.get("address", "10.8.0.1")
                    tun_netmask = cfg.tun.get("netmask", "255.255.255.0")
                    out_iface = cfg.nat.get("out_iface")
                    if out_iface:
                        subprocess.run(
                            [
                                "iptables",
                                "-t",
                                "nat",
                                "-D",
                                "POSTROUTING",
                                "-s",
                                f"{tun_ip}/{tun_netmask}",
                                "-o",
                                out_iface,
                                "-j",
                                "MASQUERADE",
                            ],
                            stdout=subprocess.DEVNULL,
                            stderr=subprocess.DEVNULL,
                            check=False,
                        )
                        log.info(
                            "Removed MASQUERADE rule for %s → %s",
                            tun_name,
                            out_iface,
                        )
                except Exception as e:
                    log.warning(f"Failed to remove MASQUERADE rule: {e}")

                # --- Удаляем TUN при остановке ---
                log.info(f"Removing TUN interface: {tun_name}")
                try:
                    subprocess.run(
                        [
                            "ip",
                            "tuntap",
                            "del",
                            "dev",
                            tun_name,
                            "mode",
                            "tun",
                        ],
                        stdout=subprocess.DEVNULL,
                        stderr=subprocess.DEVNULL,
                        check=False,
                    )
                except Exception as e:
                    log.warning(f"Failed to delete tun {tun_name}: {e}")


if __name__ == "__main__":
    main()

# --- ./build/lib/socks5tun/server.py ---
# server.py
import os
import inspect
import psutil
import traceback
import socket
import threading
import select
import logging
import ipaddress

from socks5tun.config import Config

# SOCKS5 protocol constants and values
SOCKS_VERSION = 5
# Authentication methods
NO_AUTH = 0x00
USER_AUTH = 0x02
NO_ACCEPTABLE = 0xFF
# Command codes
CMD_CONNECT = 0x01
CMD_BIND = 0x02  # BIND not implemented
CMD_UDP_ASSOCIATE = 0x03
# Address types
ADDR_IPV4 = 0x01
ADDR_DOMAIN = 0x03
ADDR_IPV6 = 0x04
# Reply codes
REP_SUCCESS = 0x00
REP_GENERAL_FAILURE = 0x01
REP_CONN_NOT_ALLOWED = 0x02
REP_NETWORK_UNREACHABLE = 0x03
REP_HOST_UNREACHABLE = 0x04
REP_CONN_REFUSED = 0x05
REP_TTL_EXPIRED = 0x06
REP_CMD_NOT_SUPPORTED = 0x07
REP_ADDR_NOT_SUPPORTED = 0x08


# Порты, с которых мы ожидаем локальный форвардинг (stunnel, ssh -L, tun2socks и т.п.)
LOCAL_FORWARD_WHITELIST = {443, 1080, 1194}


def is_self_connection(
    client_ip: str, client_port: int, server_port: int
) -> tuple[str, str]:
    """
    Определяет тип соединения:
    - 'self' — loopback + клиентский порт = порт сервера (реальный self-connect)
    - 'local_forward' — loopback + порт клиента в whitelist (ожидаемый локальный форвардер)
    - 'local_other' — loopback всё остальное
    - 'other' — всё остальное
    """
    try:
        ip_obj = ipaddress.ip_address(client_ip)
    except ValueError:
        ip_obj = None

    if ip_obj and ip_obj.is_loopback:
        pname = "unknown"
        pid = None
        for conn in psutil.net_connections(kind='tcp'):
            if not conn.laddr or not conn.raddr:
                continue
            if (
                conn.laddr[1] == server_port
                and conn.raddr[0] == client_ip
                and conn.raddr[1] == client_port
            ):
                pid = conn.pid
                if pid:
                    try:
                        pname = psutil.Process(pid).name()
                    except Exception:
                        pass
                break

        # 1. Настоящий self-connect
        if client_port == server_port:
            return "self", f"{pid} {pname}"

        # 2. Локальный форвард (по whitelist портов)
        if client_port in LOCAL_FORWARD_WHITELIST:
            return "local_forward", f"{pid} {pname}"

        # 3. Остальное loopback
        return "local_other", f"{pid} {pname if pname else 'unknown'}"

    return "other", "unknown"


def recv_exact(conn, n):
    """Читает ровно n байт из сокета, иначе выбрасывает исключение."""
    data = b''
    while len(data) < n:
        chunk = conn.recv(n - len(data))
        if not chunk:
            raise IOError("Connection closed prematurely")
        data += chunk
    return data


class SocksServer:
    """
    A Socks5 proxy server that handles TCP CONNECT and UDP ASSOCIATE commands.
    """

    def __init__(self, config: Config, tun=None):
        self.config = config
        self.tun = tun  # DummyTun or real TUN interface if provided
        self._log = logging.getLogger("socks5-server")
        # Prepare allowed client networks
        self.allowed_nets = config.allowed_clients
        # Authentication setup
        self.auth_required = config.auth is not None
        self.auth_credentials = config.auth if config.auth else {}

    def start(self):
        """
        Start the Socks5 server: bind and listen for incoming connections,
        handle each in a new thread.
        """

        self._log.warning(
            "[DEBUG] Server started — stack:\n%s",
            ''.join(traceback.format_stack(limit=10)),
        )

        # Выбираем тип адреса
        family = socket.AF_INET6 if ':' in self.config.tcp_host else socket.AF_INET
        with socket.socket(family, socket.SOCK_STREAM) as server_sock:
            server_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            server_sock.bind((self.config.tcp_host, self.config.tcp_port))
            server_sock.listen()
            self._log.info(
                "Listening on %s:%d",
                self.config.tcp_host,
                self.config.tcp_port,
            )

            while True:
                try:
                    client_sock, client_addr = server_sock.accept()

                    # --- NEW: проверка IP клиента ---
                    if not self._is_client_allowed(client_addr[0]):
                        self._log.warning(
                            "Rejected connection from %s:%d "
                            "(not in allowed_clients)",
                            client_addr[0],
                            client_addr[1],
                        )
                        client_sock.close()
                        continue  # ждём следующий accept
                    # --------------------------------

                    # Определяем тип подключения и информацию о процессе
                    ctype, who = is_self_connection(
                        client_addr[0], client_addr[1], self.config.tcp_port
                    )

                    if ctype == "self":
                        # Настоящий self-test
                        self._log.info(
                            "[🧪 SELF-TEST] Accepted internal connection "
                            "from %s:%d (%s)",
                            client_addr[0],
                            client_addr[1],
                            who,
                        )
                        stack = inspect.stack()
                        self._log.debug(
                            "Top call: %s:%d in %s()",
                            stack[1].filename,
                            stack[1].lineno,
                            stack[1].function,
                        )

                    elif ctype == "local_stunnel":
                        # Локальный stunnel на loopback
                        self._log.info(
                            "[LOCAL STUNNEL] TCP connection from %s:%d (%s)",
                            client_addr[0],
                            client_addr[1],
                            who,
                        )

                    elif ctype == "local_other":
                        self._log.info(
                            "[LOCAL] TCP connection from %s:%d (%s)",
                            client_addr[0],
                            client_addr[1],
                            who,
                        )

                    elif ctype == "local_forward":
                        self._log.info(
                            "[LOCAL FORWARD] TCP connection from %s:%d (%s)",
                            client_addr[0],
                            client_addr[1],
                            who,
                        )

                    else:
                        # Любое другое подключение
                        self._log.info(
                            "[ACCEPT] TCP connection from %s:%d by %s",
                            client_addr[0],
                            client_addr[1],
                            who,
                        )
                        self._log.debug(
                            "[TRACE] Stack trace for connection from %s:%d:\n%s",
                            client_addr[0],
                            client_addr[1],
                            ''.join(traceback.format_stack(limit=8)),
                        )

                    # Запускаем обработчик клиента в отдельном потоке
                    threading.Thread(
                        target=self._handle_client,
                        args=(client_sock, client_addr),
                        daemon=True,
                    ).start()

                except OSError:
                    break

    def _is_client_allowed(self, client_ip: str) -> bool:
        """Check if the client IP is in allowed networks."""
        ip_obj = ipaddress.ip_address(client_ip)
        return any(ip_obj in net for net in self.allowed_nets)

    def _is_dest_allowed(self, dest_ip: str, dest_port: int) -> bool:
        """Check if the destination IP:
        port is permitted by allow/deny rules."""
        try:
            ip_obj = ipaddress.ip_address(dest_ip)
        except Exception:
            return False
        # Deny rules
        for net, port in getattr(self.config, "deny_rules", []):
            if ip_obj in net and (port is None or dest_port == port):
                return False
        # Allow rules
        allow_rules = getattr(self.config, "allow_rules", [])
        if allow_rules:
            allowed = False
            for net, port in allow_rules:
                if ip_obj in net and (port is None or dest_port == port):
                    allowed = True
                    break
            if not allowed:
                return False
        return True

    def _handle_client(self, conn: socket.socket, client_addr):
        if client_addr[0] == "127.0.0.1":
            self._log.warning(
                "👀 LOCAL connection from %s — likely self-initiated",
                client_addr[0],
            )

        try:
            # Для DummySocket в тестах отключаем setsockopt
            if hasattr(conn, "setsockopt"):
                conn.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)

            header = recv_exact(conn, 2)
            self._log.warning(
                "[SNIFF] First 2 bytes from %s:%d: hex=%s ascii=%r",
                client_addr[0],
                client_addr[1],
                header.hex(),
                header,
            )
            proto_guess = None
            if header.startswith(b"PO") or header.startswith(b"GE"):
                proto_guess = "HTTP"
            elif header.startswith(b"\x16\x03"):
                proto_guess = "TLS"
            elif header.startswith(b"CO"):
                proto_guess = "HTTPS proxy (CONNECT)"
            elif header[0] != 0x05:
                proto_guess = "Unknown non-SOCKS"

            if proto_guess:
                self._log.warning(
                    "[GUESS] %s:%d likely using %s instead of SOCKS5",
                    client_addr[0],
                    client_addr[1],
                    proto_guess,
                )
            ver, nmethods = header[0], header[1]
            self._log.info(
                "SOCKS5 handshake header from %s: %s", client_addr[0], header.hex()
            )

            if ver != SOCKS_VERSION:
                self._log.error(
                    "Unsupported SOCKS version %d from %s", ver, client_addr[0]
                )
                conn.close()
                return

            methods = recv_exact(conn, nmethods)
            self._log.info(
                "SOCKS5 methods from %s: %s",
                client_addr[0],
                methods.hex(),
            )

            self._log.debug(
                "[DEBUG] Waiting for SOCKS5 request from %s:%d...",
                client_addr[0],
                client_addr[1],
            )

            if self.auth_required:
                if USER_AUTH not in methods:
                    conn.sendall(bytes([SOCKS_VERSION, NO_ACCEPTABLE]))
                    conn.close()
                    return
                conn.sendall(bytes([SOCKS_VERSION, USER_AUTH]))

                ver_auth = recv_exact(conn, 1)
                if ver_auth[0] != 0x01:
                    conn.close()
                    return

                ulen = recv_exact(conn, 1)[0]
                username = recv_exact(conn, ulen).decode()

                plen = recv_exact(conn, 1)[0]
                password = recv_exact(conn, plen).decode()

                if username != self.auth_credentials.get(
                    "username"
                ) or password != self.auth_credentials.get("password"):
                    conn.sendall(bytes([0x01, 0x01]))
                    self._log.warning(
                        "Authentication failed for %s",
                        client_addr[0],
                    )
                    conn.close()
                    return
                else:
                    conn.sendall(bytes([0x01, 0x00]))
            else:
                if NO_AUTH in methods:
                    conn.sendall(bytes([SOCKS_VERSION, NO_AUTH]))
                else:
                    conn.sendall(bytes([SOCKS_VERSION, NO_ACCEPTABLE]))
                    conn.close()
                    return

            self._log.debug(
                "[DEBUG] Waiting for SOCKS5 request from %s:%d...",
                client_addr[0],
                client_addr[1],
            )

            # Добавь timeout через select (например, 3 секунды)
            ready, _, _ = select.select([conn], [], [], 3)
            if not ready:
                self._log.warning(
                    "[TIMEOUT] Client %s:%d did not send "
                    "SOCKS5 request after handshake",
                    client_addr[0],
                    client_addr[1],
                )
                conn.close()
                return
            request = recv_exact(conn, 4)

            self._log.info(
                "SOCKS5 request header from %s: %s",
                client_addr[0],
                request.hex(),
            )
            ver, cmd, _, atyp = request

            if ver != SOCKS_VERSION:
                self._log.error(
                    "Mismatched SOCKS version in request from %s",
                    client_addr[0],
                )
                conn.close()
                return

            if cmd == CMD_CONNECT:
                self._handle_connect(conn, atyp, client_addr)
            elif cmd == CMD_UDP_ASSOCIATE:
                self._handle_udp_associate(conn, atyp, client_addr)
            else:
                self._send_reply(
                    conn,
                    REP_CMD_NOT_SUPPORTED,
                    bind_ip="0.0.0.0",
                    bind_port=0,
                    atyp=ADDR_IPV4,
                )
                conn.close()

        except ConnectionResetError:
            self._log.warning(
                "Client %s forcibly closed the connection (RST)",
                client_addr[0],
            )
        except EOFError:
            self._log.warning(
                "Client %s closed connection with EOF",
                client_addr[0],
            )
        except Exception as e:
            is_self, who = is_self_connection(
                client_addr[0], client_addr[1], self.config.tcp_port
            )
            if is_self or client_addr[0] == "127.0.0.1":
                self._log.info(
                    "🔁 [LOCAL/SELF] "
                    "Connection from %s "
                    "closed prematurely "
                    "(%s)",
                    client_addr[0],
                    who if is_self else str(e),
                )
            else:
                self._log.error(
                    "Error handling client %s: %s",
                    client_addr[0],
                    e,
                )

        finally:
            try:
                conn.close()
            except Exception:
                pass

    def _handle_connect(self, conn: socket.socket, atyp: int, client_addr):
        """Handle SOCKS5 CONNECT (TCP forwarding)"""
        try:
            dest_addr, dest_port = self._read_dest_address(conn, atyp)
        except Exception as e:
            self._log.error(
                "Failed to parse destination address from %s: %s",
                client_addr[0],
                e,
            )
            rep = (
                REP_ADDR_NOT_SUPPORTED
                if isinstance(e, ValueError)
                else REP_GENERAL_FAILURE
            )
            self._send_reply(
                conn,
                rep,
                bind_ip="0.0.0.0",
                bind_port=0,
                atyp=ADDR_IPV4,
            )
            conn.close()
            return
        # Check against allow/deny rules
        if not self._is_dest_allowed(dest_addr, dest_port):
            self._log.info(
                "Blocked destination %s requested by %s",
                dest_addr,
                client_addr[0],
            )
            self._send_reply(
                conn,
                REP_CONN_NOT_ALLOWED,
                bind_ip="0.0.0.0",
                bind_port=0,
                atyp=ADDR_IPV4,
            )
            conn.close()
            return
        # Create remote socket to target
        remote_family = socket.AF_INET6 if ':' in dest_addr else socket.AF_INET
        try:
            remote_sock = socket.socket(remote_family, socket.SOCK_STREAM)
            remote_sock.connect((dest_addr, dest_port))
        except socket.error as e:
            err_no = getattr(e, 'errno', None)
            if err_no in (111, 61):
                rep = REP_CONN_REFUSED
            elif err_no in (113, 101):
                rep = REP_HOST_UNREACHABLE
            else:
                rep = REP_GENERAL_FAILURE
            self._log.error(
                "TCP Connect to %s:%d failed: %s",
                dest_addr,
                dest_port,
                e,
            )
            self._send_reply(
                conn,
                rep,
                bind_ip="0.0.0.0",
                bind_port=0,
                atyp=ADDR_IPV4,
            )
            conn.close()
            return
        # Connected successfully
        bind_ip, bind_port = remote_sock.getsockname()[:2]
        reply_atyp = ADDR_IPV6 if remote_family == socket.AF_INET6 else ADDR_IPV4
        self._send_reply(
            conn,
            REP_SUCCESS,
            bind_ip=bind_ip,
            bind_port=bind_port,
            atyp=reply_atyp,
        )
        self._log.info(
            "Established TCP tunnel from %s to %s:%d",
            client_addr[0],
            dest_addr,
            dest_port,
        )
        try:
            self._exchange_loop(conn, remote_sock)
        finally:
            remote_sock.close()
            conn.close()
            self._log.info("Closed TCP tunnel for %s", client_addr[0])

    def _handle_udp_associate(
        self,
        conn: socket.socket,
        atyp: int,
        client_addr,
    ):
        """Handle SOCKS5 UDP ASSOCIATE (UDP relay)"""
        try:
            client_ip, client_port = self._read_dest_address(conn, atyp)
        except Exception:
            client_ip, client_port = client_addr[0], 0
        # Determine address and port for UDP relay from config
        bind_ip = self.config.udp_host
        if bind_ip == "0.0.0.0":
            bind_ip = conn.getsockname()[0]
            if bind_ip == "0.0.0.0":
                bind_ip = "0.0.0.0"
        if bind_ip in ("::", "::0", "0:0:0:0:0:0:0:0"):
            local_ip = conn.getsockname()[0]
            if local_ip and local_ip != "::":
                bind_ip = local_ip
            else:
                bind_ip = "::"
        reply_atyp = ADDR_IPV6 if ':' in bind_ip else ADDR_IPV4
        self._send_reply(
            conn,
            REP_SUCCESS,
            bind_ip=bind_ip,
            bind_port=self.config.udp_port,
            atyp=reply_atyp,
        )
        self._log.info(
            "UDP association established with %s, UDP relay port %d",
            client_addr[0],
            self.config.udp_port,
        )
        try:
            conn.recv(1)
        except Exception:
            pass
        conn.close()
        self._log.info("Closed UDP association for %s", client_addr[0])

    def _exchange_loop(
        self,
        client_sock: socket.socket,
        remote_sock: socket.socket,
    ):
        """Relay data between client
        and remote sockets until one side closes."""
        while True:
            rlist, _, _ = select.select([client_sock, remote_sock], [], [])
            if client_sock in rlist:
                data = client_sock.recv(4096)
                if not data:
                    break
                remote_sock.sendall(data)
            if remote_sock in rlist:
                data = remote_sock.recv(4096)
                if not data:
                    break
                client_sock.sendall(data)

    def _send_reply(
        self,
        conn: socket.socket,
        rep: int,
        bind_ip: str,
        bind_port: int,
        atyp: int,
    ):
        """Send a SOCKS5 reply packet
        with given reply code and bind address/port."""
        try:
            if atyp == ADDR_IPV4:
                addr_bytes = socket.inet_aton(bind_ip)
            elif atyp == ADDR_IPV6:
                addr_bytes = socket.inet_pton(socket.AF_INET6, bind_ip)
            elif atyp == ADDR_DOMAIN:
                addr_bytes = bytes([len(bind_ip)]) + bind_ip.encode('utf-8')
            else:
                atyp = ADDR_IPV4
                addr_bytes = b"\x00\x00\x00\x00"
            port_bytes = int(bind_port).to_bytes(2, 'big')
            response = (
                bytes(
                    [
                        SOCKS_VERSION,
                        rep,
                        0x00,
                        atyp,
                    ]
                )
                + addr_bytes
                + port_bytes
            )
            conn.sendall(response)
        except Exception as e:
            self._log.error("Failed to send reply to client: %s", e)

    def _read_dest_address(self, conn: socket.socket, atyp: int):
        """
        Read destination address and port from the client request.
        Returns a tuple (dest_addr, dest_port).
        """
        if atyp == ADDR_IPV4:
            addr_bytes = conn.recv(4)
            if len(addr_bytes) < 4:
                raise IOError("Incomplete IPv4 address")
            dest_addr = socket.inet_ntoa(addr_bytes)
            port_bytes = conn.recv(2)
            if len(port_bytes) < 2:
                raise IOError("Incomplete port")
            dest_port = int.from_bytes(port_bytes, 'big')
            return dest_addr, dest_port
        elif atyp == ADDR_DOMAIN:
            length_byte = conn.recv(1)
            if not length_byte:
                raise IOError("Incomplete domain length")
            length = length_byte[0]
            domain_bytes = conn.recv(length)
            if len(domain_bytes) < length:
                raise IOError("Incomplete domain name")
            dest_domain = domain_bytes.decode('utf-8', 'ignore')
            port_bytes = conn.recv(2)
            if len(port_bytes) < 2:
                raise IOError("Incomplete port")
            dest_port = int.from_bytes(port_bytes, 'big')
            try:
                dest_addr = socket.gethostbyname(dest_domain)
            except Exception as e:
                self._log.warning(
                    "Failed to resolve domain %s: %s",
                    dest_domain,
                    e,
                )
                raise e
            return dest_addr, dest_port
        elif atyp == ADDR_IPV6:
            addr_bytes = conn.recv(16)
            if len(addr_bytes) < 16:
                raise IOError("Incomplete IPv6 address")
            dest_addr = socket.inet_ntop(socket.AF_INET6, addr_bytes)
            port_bytes = conn.recv(2)
            if len(port_bytes) < 2:
                raise IOError("Incomplete port")
            dest_port = int.from_bytes(port_bytes, 'big')
            return dest_addr, dest_port
        else:
            raise ValueError("Unsupported address type %d" % atyp)

# --- ./build/lib/socks5tun/udp_handler.py ---
# udp_handler.py
import socket
import logging
import struct
import threading
from ipaddress import ip_address, ip_network

logger = logging.getLogger("socks5-server")


class UDPHandler:
    def __init__(self, cfg, tun):
        self.cfg = cfg
        self.tun = tun
        self.remote_map = {}
        # Load legacy forbidden networks if present (for compatibility)
        self.forbidden_networks = []
        if hasattr(cfg, "forbidden_networks"):
            for net in cfg.forbidden_networks:
                try:
                    self.forbidden_networks.append(ip_network(net))
                except ValueError:
                    continue

    def _ip_checksum(self, data: bytes) -> int:
        """Calculate IPv4 header checksum."""
        if len(data) % 2 == 1:
            data += b'\x00'
        total = 0
        for i in range(0, len(data), 2):
            word = data[i] << 8 | data[i + 1]
            total += word
        total = (total >> 16) + (total & 0xFFFF)
        total = ~total & 0xFFFF
        return total

    def handle_client_packet(self, data: bytes, client_addr):
        """
        Handle a UDP packet from client (SOCKS5 UDP ASSOCIATE).
        data: raw UDP datagram from client (including SOCKS5 UDP header).
        client_addr: tuple (src_ip, src_port) of the client.
        """
        # Minimum UDP header length is 4 bytes
        if len(data) < 4:
            return
        # Check reserved bytes and fragmentation field
        if data[0] != 0x00 or data[1] != 0x00:
            return  # Invalid reserved field
        frag = data[2]
        if frag != 0x00:
            logger.warning(
                f"Received fragmented UDP packet from {client_addr}, dropping"
            )
            return
        atyp = data[3]
        offset = 4
        dest_addr = None
        dest_port = None
        # Parse destination based on ATYP
        if atyp == 0x01:  # IPv4
            if len(data) < offset + 6:
                return
            dest_addr = socket.inet_ntoa(data[offset : offset + 4])
            offset += 4
            dest_port = struct.unpack("!H", data[offset : offset + 2])[0]
            offset += 2
        elif atyp == 0x03:  # Domain name
            if len(data) < offset + 1:
                return
            name_len = data[offset]
            offset += 1
            if len(data) < offset + name_len + 2:
                return
            dest_name = data[offset : offset + name_len].decode(
                'ascii', errors='ignore'
            )
            offset += name_len
            dest_port = struct.unpack("!H", data[offset : offset + 2])[0]
            offset += 2
            # Resolve domain to IP
            if getattr(self.cfg, "dns_resolver", "system") == "system":
                try:
                    addrs = socket.getaddrinfo(
                        dest_name, dest_port, proto=socket.IPPROTO_UDP
                    )
                except Exception:
                    logger.warning(
                        f"[UDP-DENY ] {client_addr[0]}:{client_addr[1]}"
                        f" → {dest_name}:{dest_port} reason=resolve_fail"
                    )
                    return
            else:
                try:
                    addrs = socket.getaddrinfo(
                        dest_name, dest_port, proto=socket.IPPROTO_UDP
                    )
                except Exception:
                    logger.warning(
                        f"[UDP-DENY ] {client_addr[0]}:{client_addr[1]}"
                        f" → {dest_name}:{dest_port} reason=resolve_fail"
                    )
                    return
            if not addrs:
                logger.warning(
                    f"[UDP-DENY ] {client_addr[0]}:{client_addr[1]}"
                    f" → {dest_name}:{dest_port} reason=resolve_fail"
                )
                return
            dest_addr = addrs[0][4][0]
        elif atyp == 0x04:  # IPv6
            if len(data) < offset + 18:
                return
            try:
                dest_addr = socket.inet_ntop(
                    socket.AF_INET6, data[offset : offset + 16]
                )
            except OSError:
                return
            offset += 16
            dest_port = struct.unpack("!H", data[offset : offset + 2])[0]
            offset += 2
        else:
            return
        payload = data[offset:]
        if dest_addr is None:
            return
        # Apply allow/deny filtering
        allowed = True
        reason = "deny_rule"
        try:
            ip_obj = ip_address(dest_addr)
        except ValueError:
            ip_obj = None
        if ip_obj:
            # Check deny rules
            for net, port in getattr(self.cfg, "deny_rules", []):
                if ip_obj in net and (port is None or dest_port == port):
                    allowed = False
                    break

            # Check legacy forbidden networks if no explicit deny rules
            if allowed and not getattr(self.cfg, "deny_rules", []):
                for net in self.forbidden_networks:
                    if ip_obj in net:
                        allowed = False
                        break

            # Check allow rules
            if allowed and getattr(self.cfg, "allow_rules", []):
                matched = False
                for net, port in self.cfg.allow_rules:
                    if ip_obj in net and (port is None or dest_port == port):
                        matched = True
                        break
                if not matched:
                    allowed = False
        else:
            allowed = False
        if not allowed:
            logger.warning(
                f"[UDP-DENY ] {client_addr[0]}:{client_addr[1]}"
                f" → {dest_addr}:{dest_port} reason={reason}"
            )
            return
        # Build packet and forward to TUN (IPv4 only)
        ip_obj = ip_address(dest_addr)
        if ip_obj.version == 4:
            src_ip = client_addr[0]
            src_port = client_addr[1] & 0xFFFF
            dst_ip = dest_addr
            # IPv4 header
            version = 4
            ihl = 5
            ver_ihl = (version << 4) + ihl
            tos = 0
            total_length = 20 + 8 + len(payload)
            identification = 0
            flags_offset = 0
            ttl = 64
            protocol = socket.IPPROTO_UDP
            src_ip_bytes = socket.inet_aton(src_ip)
            dst_ip_bytes = socket.inet_aton(dst_ip)
            # Initial header with zero checksum
            ip_header = struct.pack(
                "!BBHHHBBH4s4s",
                ver_ihl,
                tos,
                total_length,
                identification,
                flags_offset,
                ttl,
                protocol,
                0,
                src_ip_bytes,
                dst_ip_bytes,
            )
            checksum = self._ip_checksum(ip_header)
            # Final IP header with checksum
            ip_header = struct.pack(
                "!BBHHHBBH4s4s",
                ver_ihl,
                tos,
                total_length,
                identification,
                flags_offset,
                ttl,
                protocol,
                checksum,
                src_ip_bytes,
                dst_ip_bytes,
            )
            # UDP header
            dst_port_net = dest_port & 0xFFFF
            udp_length = 8 + len(payload)
            udp_header = struct.pack(
                "!HHHH",
                src_port,
                dst_port_net,
                udp_length,
                0,
            )
            packet = ip_header + udp_header + payload
            self.tun.write(packet)
            self.remote_map[(dest_addr, dest_port)] = client_addr
        elif ip_obj.version == 6:
            logger.warning(
                f"Cannot forward UDP to IPv6 address"
                f" {dest_addr} "
                f"(not supported)"
            )
            return
        else:
            return
        # Log forwarded packet as allowed
        logger.info(
            f"[UDP-ALLOW] {client_addr[0]}:{client_addr[1]}"
            f" → {dest_addr}:{dest_port} len={len(payload)}"
        )


def start_udp_loop(cfg, tun):
    """
    Start a loop to handle global UDP relay.
    Listens on cfg.udp_host:cfg.udp_port for UDP traffic.
    """
    family = socket.AF_INET6 if ':' in cfg.udp_host else socket.AF_INET
    udp_sock = socket.socket(family, socket.SOCK_DGRAM)
    logger.debug("[BOOT] Entered start_udp_loop()")
    try:
        udp_sock.bind((cfg.udp_host, cfg.udp_port))
    except OSError as e:
        logger.error(
            "Failed to bind UDP socket on %s:%d — %s",
            cfg.udp_host,
            cfg.udp_port,
            e,
        )
        return

    logger.info(
        "[DEBUG] Bound UDP socket on %s:%d",
        cfg.udp_host,
        cfg.udp_port,
    )
    logger.info(f"UDP relay socket listening on {cfg.udp_host}:{cfg.udp_port}")
    # Mapping for direct UDP mode (dest -> client)
    remote_map = {}
    # Handler for client packets
    handler = UDPHandler(cfg, tun)
    handler.remote_map = remote_map
    # If TUN interface is available, start thread to handle incoming packets from TUN
    if tun:

        def tun_reader():
            while True:
                try:
                    packet = tun.read()
                except Exception as e:
                    logger.error("UDP tun read error: %s", e)
                    break
                if not packet:
                    break
                # Only handle IPv4 UDP packets from tun
                if len(packet) < 20:
                    continue
                version = packet[0] >> 4
                if version != 4:
                    # Only IPv4 supported for now
                    continue
                proto = packet[9]
                if proto != socket.IPPROTO_UDP:
                    continue
                src_ip = socket.inet_ntoa(packet[12:16])
                dst_ip = socket.inet_ntoa(packet[16:20])
                src_port = int.from_bytes(packet[20:22], 'big')
                dst_port = int.from_bytes(packet[22:24], 'big')
                payload = packet[28:]
                client_key = (src_ip, src_port)
                # If we have a client for this dest, forward to it
                if client_key in remote_map:
                    client_addr = remote_map[client_key]
                else:
                    # No mapping, drop
                    logger.warning(
                        f"Received UDP packet from {src_ip}:{src_port} with "
                        "no client mapping for {dst_ip}:{dst_port}"
                    )
                    continue
                # Build SOCKS UDP response
                try:
                    if ':' in src_ip:
                        addr_bytes = socket.inet_pton(socket.AF_INET6, src_ip)
                        resp_atyp = 0x04
                    else:
                        addr_bytes = socket.inet_aton(src_ip)
                        resp_atyp = 0x01
                    port_bytes = src_port.to_bytes(2, 'big')
                    resp_header = (
                        b"\x00\x00\x00" + bytes([resp_atyp]) + addr_bytes + port_bytes
                    )
                except Exception as e:
                    logger.error(
                        "Failed to build UDP response header for %s: %s", src_ip, e
                    )
                    continue
                response_data = resp_header + payload
                try:
                    udp_sock.sendto(response_data, client_addr)
                except Exception as e:
                    logger.error(
                        "Failed to send UDP packet to client %s:%d - %s",
                        client_addr[0],
                        client_addr[1],
                        e,
                    )

        threading.Thread(target=tun_reader, daemon=True).start()
    # Main loop to handle incoming UDP datagrams on socket
    logger.debug("[BOOT] Entering UDP receive loop...")

    while True:
        try:
            logger.debug("[LOOP] Waiting for UDP packet...")
            data, addr = udp_sock.recvfrom(65535)
            logger.debug(
                "[TRACE] --- UDP packet received from %s:%d ---",
                addr[0],
                addr[1],
            )

            logger.debug(
                "[DEBUG] Got UDP from %s:%d, len=%d",
                addr[0],
                addr[1],
                len(data),
            )
            client_ip, client_port = addr[0], addr[1]
            try:
                ip_obj = ip_address(client_ip)
            except ValueError:
                ip_obj = None
            is_client = ip_obj is not None and any(
                ip_obj in net for net in cfg.allowed_clients
            )

            # ✅ ДОПОЛНИТЕЛЬНЫЕ ЛОГИ
            logger.debug("[TRACE] UDP packet from: %s:%d", client_ip, client_port)
            logger.debug("[TRACE] Evaluated ip_obj: %s", ip_obj)
            logger.debug("[TRACE] allowed_clients: %s", cfg.allowed_clients)
            logger.debug("[TRACE] is_client: %s", is_client)

        except Exception as e:
            logger.error("UDP socket error: %s", e)
            break
        client_ip, client_port = addr[0], addr[1]
        try:
            ip_obj = ip_address(client_ip)
        except ValueError:
            ip_obj = None
        is_client = ip_obj is not None and any(
            ip_obj in net for net in cfg.allowed_clients
        )
        logger.debug("[CHECK] Incoming UDP from %s:%d", client_ip, client_port)
        logger.debug("[CHECK] allowed_clients = %s", cfg.allowed_clients)
        logger.debug("[CHECK] ip_obj = %s", ip_obj)
        logger.debug("[CHECK] is_client = %s", is_client)

        if is_client:
            # UDP datagram from an allowed client
            if tun:
                logger.debug(
                    "[DEBUG] handle_client_packet from %s:%d, raw: %s",
                    addr[0],
                    addr[1],
                    data.hex(),
                )
                try:
                    handler.handle_client_packet(data, addr)
                except Exception as e:
                    logger.error("Exception in handle_client_packet: %s", e)

            else:
                # Handle direct UDP forward (no TUN)

                if len(data) < 4:
                    continue
                if data[0] != 0x00 or data[1] != 0x00:
                    continue
                frag = data[2]
                if frag != 0x00:
                    continue
                atyp = data[3]
                off = 4
                dest_addr = None
                dest_port = None
                if atyp == 0x01:
                    if len(data) < off + 6:
                        continue
                    dest_addr = socket.inet_ntoa(data[off : off + 4])
                    off += 4
                    dest_port = int.from_bytes(data[off : off + 2], 'big')
                    off += 2
                elif atyp == 0x03:
                    if len(data) < off + 1:
                        continue
                    name_len = data[off]
                    off += 1
                    if len(data) < off + name_len + 2:
                        continue
                    dest_name = data[off : off + name_len].decode(
                        'ascii', errors='ignore'
                    )
                    off += name_len
                    dest_port = int.from_bytes(data[off : off + 2], 'big')
                    off += 2
                    try:
                        dest_addr = socket.gethostbyname(dest_name)
                    except Exception as e:
                        logger.warning(
                            f"[UDP-DENY ] {client_ip}:{client_port}"
                            f" → {dest_name}:{dest_port} reason=resolve_fail"
                        )
                        continue
                elif atyp == 0x04:
                    if len(data) < off + 18:
                        continue
                    try:
                        dest_addr = socket.inet_ntop(
                            socket.AF_INET6, data[off : off + 16]
                        )
                    except OSError:
                        continue
                    off += 16
                    dest_port = int.from_bytes(data[off : off + 2], 'big')
                    off += 2
                else:
                    continue
                payload = data[off:]
                if dest_addr is None:
                    continue
                # Filtering
                allowed = True
                reason = "deny_rule"
                try:
                    dest_ip_obj = ip_address(dest_addr)
                except ValueError:
                    dest_ip_obj = None
                if dest_ip_obj:
                    for net, port in getattr(cfg, "deny_rules", []):
                        if dest_ip_obj in net and (port is None or dest_port == port):
                            allowed = False
                            break
                    if allowed and getattr(cfg, "allow_rules", []):
                        match = False
                        for net, port in cfg.allow_rules:
                            if dest_ip_obj in net and (
                                port is None or dest_port == port
                            ):
                                match = True
                                break
                        if not match:
                            allowed = False
                else:
                    allowed = False
                if not allowed:
                    logger.warning(
                        f"[UDP-DENY ] {client_ip}:{client_port}"
                        f" → {dest_addr}:{dest_port} reason={reason}"
                    )
                    continue
                # Forward to remote
                try:
                    logger.debug(
                        "[SEND] Sending UDP to %s:%d (payload %d bytes): %s",
                        dest_addr,
                        dest_port,
                        len(payload),
                        payload.hex(),
                    )
                    udp_sock.sendto(payload, (dest_addr, dest_port))
                except Exception as e:
                    logger.error(
                        "Failed to relay UDP to %s:%d - %s",
                        dest_addr,
                        dest_port,
                        e,
                    )
                    continue
                # Update mapping for return traffic
                remote_map[(dest_addr, dest_port)] = addr
                logger.info(
                    f"[UDP-ALLOW] {client_ip}:{client_port}"
                    f" → {dest_addr}:{dest_port} len={len(payload)}"
                )
        else:
            # UDP datagram from remote host
            logger.debug(
                "[REJECT] UDP from %s:%d rejected: not in allowed_clients",
                client_ip,
                client_port,
            )
            if tun:
                # Should not happen (remote replies handled via tun), ignore
                continue
            # Direct mode: relay back to client if known
            remote_ip, remote_port = client_ip, client_port
            if (remote_ip, remote_port) not in remote_map:
                continue
            client_addr = remote_map[(remote_ip, remote_port)]
            # Build SOCKS UDP response
            try:
                if ':' in remote_ip:
                    addr_bytes = socket.inet_pton(socket.AF_INET6, remote_ip)
                    resp_atyp = 0x04
                else:
                    addr_bytes = socket.inet_aton(remote_ip)
                    resp_atyp = 0x01
                port_bytes = remote_port.to_bytes(2, 'big')
                resp_header = (
                    b"\x00\x00\x00" + bytes([resp_atyp]) + addr_bytes + port_bytes
                )
            except Exception as e:
                logger.error(
                    "Failed to build UDP response header for %s: %s",
                    remote_ip,
                    e,
                )
                continue
            response_data = resp_header + data
            udp_sock.sendto(response_data, client_addr)

# --- ./README.md ---
## Логирование UDP-трафика

По умолчанию приложение логирует весь UDP-трафик — как **разрешённый**, так и **заблокированный**.

- Разрешённые UDP-пакеты записываются в журнал уровня INFO с префиксом `[UDP-ALLOW]`. В сообщении указываются исходный адрес:порт клиента, адрес:порт назначения и размер переданных данных.
- Заблокированные UDP-пакеты записываются в журнал уровня WARNING с префиксом `[UDP-DENY ]`. В сообщении указываются исходный адрес:порт клиента, адрес:порт назначения и причина блокировки (например, `reason=deny_rule`).

Пример фрагмента журнала UDP-трафика:

```text
[UDP-ALLOW] 192.0.2.10:39522 → 8.8.8.8:53 len=42
[UDP-DENY ] 10.0.0.5:60234 → 192.168.0.1:80 reason=deny_rule
```

---

## Автосетап TUN/NAT

Если в конфигурационном файле (`config.json`) заданы параметры блоков:

```json
"tun": {
  "name": "tun0",
  "address": "10.8.0.1",
  "netmask": "255.255.255.0",
  "peer_address": "10.8.0.2",
  "mtu": 1500
},
"nat": {
  "out_iface": "eth0"
}
```

то при старте сервера **TUN‑интерфейс** и **NAT‑правила** будут настраиваться автоматически.

- Автосетап выполняется **только**, если процесс запущен с правами `root` (`UID 0`).
- В тестовом или CI‑окружении, где нет root‑доступа, авто‑сетап будет пропущен, и в логах появится предупреждение:

```text
[WARNING] Skipping TUN/NAT auto-setup: not running as root (UID != 0)
```

---

## Базовая настройка брандмауэра (UFW)

Для ограничения внешнего доступа рекомендуется разрешить только необходимые порты:

```bash
ufw default deny incoming
ufw default allow outgoing
ufw allow 22/tcp comment "SSH"
ufw allow 443/tcp comment "TLS (stunnel)"
ufw enable
```

- Это закроет все входящие соединения, кроме SSH и TLS‑порта, используемого stunnel.
- Порт SOCKS5 (например, 5000/tcp), на котором слушает Python‑сервер, при этом будет доступен **только локально** (127.0.0.1) и через stunnel.
- Если требуется прямой внешний доступ к SOCKS5, добавьте правило:

```bash
ufw allow 5000/tcp comment "SOCKS5 direct"
```

---

## Мини-бэкап конфигураций `/etc`

Для автоматического отслеживания и возможности отката изменений в системных конфигурациях `/etc` рекомендуется установить:

```bash
sudo apt install -y etckeeper
cd /etc
sudo etckeeper init
sudo etckeeper commit -m "Initial server snapshot"
```

Теперь изменения `/etc` будут отслеживаться с помощью Git. Это удобно при ручной настройке `ufw`, `ssh`, `resolv.conf`, и т.д.

---

## Потенциальное улучшение: базовая защита SSH

Для повышения безопасности SSH можно добавить отдельный файл настроек `/etc/ssh/sshd_config.d/hardening.conf`:

```conf
PermitRootLogin no
PasswordAuthentication no
ClientAliveInterval 300
ClientAliveCountMax 2
```

- **PermitRootLogin no** — запрет входа под root по SSH.
- **PasswordAuthentication no** — отключение входа по паролю (только по SSH-ключу).
- **ClientAliveInterval** и **ClientAliveCountMax** — автоматическое завершение сессий при отсутствии активности.

> ⚠️ Перед применением убедитесь, что у вас есть рабочая учётная запись с ключом SSH и правами `sudo`.
> Рекомендуется сначала протестировать вход в новой сессии, и только потом закрывать текущую.

## Потенциальное улучшение: максимальная изоляция `stunnel`

В будущем возможно реализовать запуск `stunnel` с усиленной безопасностью. Это актуально при открытом или публичном VPN-сервисе с несколькими пользователями.

### ✅ Отдельный системный пользователь

```bash
sudo adduser --system --group --no-create-home stunnel
sudo chown root:stunnel /etc/stunnel
sudo chmod 750 /etc/stunnel
sudo chown root:stunnel /etc/stunnel/stunnel.pem
sudo chmod 640 /etc/stunnel/stunnel.pem
```

### ✅ Вынос PID-файла в безопасное место

```ini
pid = /run/stunnel/stunnel.pid
```

### ✅ Создание каталога и прав на него

```bash
sudo mkdir -p /run/stunnel
sudo chown stunnel:stunnel /run/stunnel
```

### ✅ Выдача capability для портов < 1024

```bash
sudo setcap 'cap_net_bind_service=+ep' /usr/bin/stunnel
```

### ✅ Защита через systemd (в unit-файле)

```ini
NoNewPrivileges=true
ProtectSystem=full
ReadOnlyPaths=/etc/stunnel
```

### 🧱 (опционально) chroot

Если требуется полная изоляция файловой системы (FS), возможно использование `chroot` — но это требует ручной подготовки окружения (библиотек, /dev/null и т.п.).

> Эти меры изолируют `stunnel` от остальной системы, даже если произойдёт взлом или утечка ключей.

Применить изменения:

```bash
sudo systemctl restart ssh
```

---

## Обновление и управление сервисом SOCKS5TUN

Проект включает встроенную систему обновления и перезапуска через связку:

- `update_socks5tun` — исполняемый скрипт/модуль, отвечающий за загрузку, установку или замену кода проекта.
- `socks5tun-update.service` — вспомогательный systemd-сервис, выполняющий `update_socks5tun` перед запуском основного прокси.
- `socks5tun.service` — основной сервис, запускающий SOCKS5-прокси сервер.

### Схема запуска

1. При запуске `socks5tun.service` автоматически **выполняется `socks5tun-update.service`**, если он указан как `Requires` + `After` в `Unit`-блоке.
2. Только **после успешного завершения обновления** стартует основной сервер.

Такой подход гарантирует, что при перезапуске системы или сервиса будет использоваться **актуальная версия** кода.

### Вручную

Для ручного запуска без обновления:

```bash
sudo systemctl start socks5tun.service
```

Для запуска только обновления (без старта прокси):

```bash
sudo systemctl start socks5tun-update.service
```

Для выполнения обновления вручную (если `update_socks5tun` — исполняемый файл):

```bash
sudo /usr/local/bin/update_socks5tun
```

---

## Работа с systemd

После изменения `.service`‑файлов **не забудьте перезагрузить systemd**:

```bash
sudo systemctl daemon-reload
```

Перезапуск сервиса:

```bash
sudo systemctl restart socks5tun.service
```

Просмотр логов:

```bash
journalctl -u socks5tun.service -f
```

Если вы изменили только Python‑код (`*.py`) — `daemon-reload` **не требуется**, достаточно `restart`.

---

## Размещение файлов

- `update_socks5tun` должен быть исполняемым (`chmod +x`) и доступным в PATH или по абсолютному пути (например, `/usr/local/bin/`).
- Юнит‑файлы systemd обычно размещаются в `/etc/systemd/system/`:

```bash
/etc/systemd/system/socks5tun.service
/etc/systemd/system/socks5tun-update.service
```

Проверь, чтобы они были включены в автозагрузку:

```bash
sudo systemctl enable socks5tun.service
```

> Обновление не выполняется, если сервис запускается напрямую (`python run.py`) — только через systemd.

# --- ./setup.py ---
from setuptools import setup, find_packages

setup(
    name="socks5tun",
    version="0.1",
    packages=find_packages(),  # автоматически найдёт socks5tun/
    include_package_data=True,
    python_requires=">=3.8",
)
[32m[INFO] === MISC FILES ===(B[m

# --- ./help.txt ---
# Активировать окружение на сервере:
source /opt/venv-pyroute/bin/activate

# Архивировать папку tests
zip -r tests_with_ci.zip tests .github/workflows/test.yml

# Создать txt файл с содержимым test + ДЕРЕВО
./diagnostics/collect_tests.sh


### Запуск проекта:
## Запуска через автомат

# перезапуск systemd, если были обновления systemd
sudo systemctl daemon-reexec

# обновляет конфигурацию systemd (нужно после изменения .service файла)
sudo systemctl daemon-reload

# перезапуск проекта
sudo systemctl restart socks5tun.service

# логи он-лайн
sudo journalctl -fu socks5tun.service

## Запуск вручную
# Тестовый запуск проекта
python -m socks5tun.run -c config_dev.json

# Рабочий запуск
python -m socks5tun.run


### Прочее
# stunnel на сервере
sudo nano /etc/stunnel/stunnel.conf

# Запустить тесты
pytest -q

# Проверка покрытия тестами
./scripts/coverage.sh

# Вернутся в проект
cd ~/socks5tun

# Отправить в GitHub
gpush "мой комментарий"
- либо просто
gpush

# --- ./requirements.txt ---
build==1.3.0
coverage==7.10.2
debugpy==1.8.15
iniconfig==2.1.0
packaging==25.0
pluggy==1.6.0
psutil==7.0.0
Pygments==2.19.2
pyproject_hooks==1.2.0
pyroute2==0.9.3
pytest==8.4.1
pytest-cov==6.2.1
pytest-timeout==2.4.0
types-psutil==7.0.0.20250801

# --- ./config_dev.json ---
{
    "tcp_host": "127.0.0.1",
    "tcp_port": 1080,
    "udp_host": "127.0.0.1",
    "udp_port": 1080,
    "tun_mode": "dummy",
    "log_level": "INFO",
    "auth": null,
    "allowed_clients": [
        "127.0.0.1/32"
    ],
    "blocked_destinations": [
        "0.0.0.0/8",
        "10.0.0.0/8",
        "127.0.0.0/8",
        "169.254.0.0/16",
        "172.16.0.0/12",
        "192.168.0.0/16",
        "240.0.0.0/4"
    ],
    "dns_resolver": "system"
}
# --- ./.github/workflows/test.yml ---
name: CI
on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  tests:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ["3.12"]
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
          cache: "pip"
          cache-dependency-path: |
            requirements.txt

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then
            pip install -r requirements.txt
          fi
          pip install .  # установить сам пакет

      - name: Run tests
        run: pytest -q

# --- ./htmlcov/status.json ---
{"note":"This file is an internal implementation detail to speed up HTML report generation. Its format can change at any time. You might be looking for the JSON report: https://coverage.rtfd.io/cmd.html#cmd-json","format":5,"version":"7.10.2","globals":"c50a5305b270b2f93df20d9edf8ab75c","files":{"z_0e0abb026a94b5ef_config_py":{"hash":"fcdd25fc6a846b78df553f1353a8484c","index":{"url":"z_0e0abb026a94b5ef_config_py.html","file":"socks5tun/config.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":63,"n_excluded":0,"n_missing":51,"n_branches":34,"n_partial_branches":0,"n_missing_branches":34}}},"z_0e0abb026a94b5ef_dummy_tun_py":{"hash":"bc4163be880ef67a541134a658e5455d","index":{"url":"z_0e0abb026a94b5ef_dummy_tun_py.html","file":"socks5tun/dummy_tun.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":45,"n_excluded":0,"n_missing":45,"n_branches":8,"n_partial_branches":0,"n_missing_branches":8}}},"z_0e0abb026a94b5ef_logger_py":{"hash":"aaedf1a33f6f7450f987d7f8ec88a09e","index":{"url":"z_0e0abb026a94b5ef_logger_py.html","file":"socks5tun/logger.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":5,"n_excluded":0,"n_missing":3,"n_branches":0,"n_partial_branches":0,"n_missing_branches":0}}},"z_0e0abb026a94b5ef_run_py":{"hash":"02cd20bd239de03119904c0bc9f4e62d","index":{"url":"z_0e0abb026a94b5ef_run_py.html","file":"socks5tun/run.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":129,"n_excluded":0,"n_missing":101,"n_branches":26,"n_partial_branches":1,"n_missing_branches":25}}},"z_0e0abb026a94b5ef_server_py":{"hash":"d951631eaec5601d357b4abf704342e5","index":{"url":"z_0e0abb026a94b5ef_server_py.html","file":"socks5tun/server.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":339,"n_excluded":0,"n_missing":296,"n_branches":124,"n_partial_branches":0,"n_missing_branches":124}}},"z_0e0abb026a94b5ef_udp_handler_py":{"hash":"6720585061b94990acddb6f2b51b6421","index":{"url":"z_0e0abb026a94b5ef_udp_handler_py.html","file":"socks5tun/udp_handler.py","description":"","nums":{"precision":0,"n_files":1,"n_statements":341,"n_excluded":0,"n_missing":341,"n_branches":122,"n_partial_branches":0,"n_missing_branches":122}}}}}
# --- ./config_prod.json ---
{
  "tcp_host": "0.0.0.0",
  "tcp_port": 5000,

  "udp_host": "::",
  "udp_port": 5000,

  "tun_mode": "linux",
  "log_level": "DEBUG",

  "tun": {
    "name": "tun0",
    "address": "10.8.0.1",
    "netmask": "255.255.255.0",
    "peer_address": "10.8.0.2",
    "mtu": 1500,

    "address6": "fd00:0:0:8::1",
    "peer_address6": "fd00:0:0:8::2",
    "prefix6": 64
  },

  "nat": {
    "out_iface": "eth0"
  },

  "auth": null,

  "allowed_clients": [
    "127.0.0.1/32",
    "10.8.0.0/24",
    "fd00:0:0:8::/64"
  ],

  "forbidden_networks": [
    "0.0.0.0/8",
    "10.0.0.0/8",
    "127.0.0.0/8",
    "169.254.0.0/16",
    "172.16.0.0/12",
    "192.168.0.0/16",
    "240.0.0.0/4"
  ],

  "dns_resolver": "system",
  "self_check": true
}

# --- ./build/lib/socks5tun/dummy_tun.py ---
"""
Dummy TUN interface for simulating a TUN device.
"""

import threading
import traceback
import logging
from collections import deque


class DummyTun:
    """
    A dummy TUN interface that mimics a TUN device for testing or environments
    where a real TUN device is not available.
    Data written to this dummy interface
    is stored, and data can be injected for reading.
    """

    def __init__(self):
        # Queues for incoming (to be read) and outgoing (written) data
        self._incoming_data = deque()
        self._outgoing_data = deque()
        self._lock = threading.Lock()
        # Conditions to wait for data availability
        self._incoming_cond = threading.Condition(self._lock)
        self._outgoing_cond = threading.Condition(self._lock)
        self.active = False

    def open(self):
        """
        Open/initialize the dummy TUN interface.
        (For a real TUN, this would create the TUN device.
        Here we just mark it active.)
        """
        with self._lock:
            self.active = True

    def read(self, size: int = 1500) -> bytes:
        """
        Read data from the dummy TUN interface
        (blocking until data is available or interface is closed).
        Returns bytes of data, or b'' if the interface is closed.
        """
        with self._incoming_cond:
            # Wait until data is available or the interface becomes inactive
            while not self._incoming_data and self.active:
                self._incoming_cond.wait()
            if not self.active and not self._incoming_data:
                # Interface closed and no data remaining
                return b""
            data = self._incoming_data.popleft()
        # Return up to 'size' bytes from the data (simulate reading a packet)
        if size and len(data) > size:
            remaining = data[size:]
            # Put the remaining back to be read next time
            with self._incoming_cond:
                self._incoming_data.appendleft(remaining)
            return data[:size]
        else:
            return data

    def write(self, data: bytes) -> int:
        """
        Write data to the dummy TUN interface.
        (For a real TUN, this would send the packet into the OS network stack.)
        Here we store it in an outgoing queue for inspection.
        Returns the number of bytes written.
        """
        if logging.getLogger().isEnabledFor(logging.DEBUG):
            print("🔄 DummyTun.write() called by:")
            traceback.print_stack(limit=5)
        traceback.print_stack(limit=5)
        with self._outgoing_cond:
            self._outgoing_data.append(data)
            # Notify any waiters for outgoing data (if used in tests)
            self._outgoing_cond.notify_all()
        return len(data)

    def inject(self, data: bytes):
        """
        Inject data into the dummy TUN interface as
        if it was received from the network.
        This data will be available to read() by the server.
        """
        with self._incoming_cond:
            self._incoming_data.append(data)
            # Notify any thread waiting for incoming data
            self._incoming_cond.notify_all()

    def close(self):
        """
        Close the dummy TUN interface.
        """
        with self._incoming_cond:
            self.active = False
            # Wake up any waiting readers so they can stop
            self._incoming_cond.notify_all()

# --- ./build/lib/socks5tun/config.py ---
"""
Configuration handling for Socks5 proxy server.
"""

import json
import ipaddress


class Config:
    """
    Holds configuration for the Socks5 server.
    """

    def __init__(self, data: dict):
        # TCP and UDP listening addresses and ports
        self.tcp_host: str = data.get("tcp_host", "127.0.0.1")
        self.tcp_port: int = data.get("tcp_port", 1080)
        self.udp_host: str = data.get("udp_host", "127.0.0.1")
        self.udp_port: int = data.get("udp_port", 1080)

        # Full tun/nat configs for easier access (НЕ выбрасываем поля!)
        self.tun = data.get("tun", {}) or {}
        self.nat = data.get("nat", {}) or {}

        # TUN interface mode (default "dummy")
        self.tun_mode: str = data.get("tun_mode", "dummy")

        self.dns_resolver = data.get("dns_resolver", "system")

        # Logging level
        self.log_level: str = data.get("log_level", "INFO").upper()

        # Authentication credentials (if any)
        auth_data = data.get("auth")
        if (
            auth_data
            and isinstance(auth_data, dict)
            and "username" in auth_data
            and "password" in auth_data
        ):
            self.auth = {
                "username": auth_data["username"],
                "password": auth_data["password"],
            }
        else:
            self.auth = None

        # Allowed client networks
        allowed_list = data.get("allowed_clients", ["0.0.0.0/0"])
        self.allowed_clients = [ipaddress.ip_network(net) for net in allowed_list]

        # Blocked destination networks
        blocked_list = data.get("blocked_destinations", [])
        self.blocked_destinations = [ipaddress.ip_network(net) for net in blocked_list]

        # Backward compatibility
        self.forbidden_networks = data.get("forbidden_networks", [])

        # Derived rules (deny everything from blocked_destinations by default)
        self.deny_rules = [(net, None) for net in self.blocked_destinations]
        self.allow_rules = []


def load_config(path: str) -> Config:
    """
    Load configuration from a JSON file and return a Config object.
    Raises FileNotFoundError if file is not found,
    or ValueError if JSON is invalid or contents are not as expected.
    """
    try:
        with open(path, "r") as f:
            data = json.load(f)
    except FileNotFoundError:
        raise
    except json.JSONDecodeError as e:
        raise ValueError(f"Invalid JSON configuration: {e}")

    # Backward compatibility for old keys:
    # 1) НЕ выбрасываем 'tun' — он нужен. Только подставляем tun_mode, если не задан.
    if "tun" in data:
        if "tun_mode" not in data:
            data["tun_mode"] = "linux" if data["tun"] else "disabled"
        # НИЧЕГО не pop-аем!

        # Мини-валидация структуры tun
        if not isinstance(data["tun"], dict):
            raise ValueError("'tun' must be an object")

    # 2) Устаревшие имена ключей
    if "bind_host" in data or "bind_port" in data:
        raise ValueError(
            "Outdated config keys 'bind_host'/'bind_port' detected; "
            "use 'tcp_host'/'tcp_port' instead."
        )

    # Validate required field types and values
    if "tcp_host" in data and not isinstance(data["tcp_host"], str):
        raise ValueError("tcp_host must be a string")
    if "tcp_port" in data and not isinstance(data["tcp_port"], int):
        raise ValueError("tcp_port must be an integer")
    if "udp_host" in data and not isinstance(data["udp_host"], str):
        raise ValueError("udp_host must be a string")
    if "udp_port" in data and not isinstance(data["udp_port"], int):
        raise ValueError("udp_port must be an integer")
    if "tun_mode" in data:
        if not isinstance(data["tun_mode"], str):
            raise ValueError("tun_mode must be a string")
        if data["tun_mode"] not in {"dummy", "linux", "disabled"}:
            raise ValueError("tun_mode must be one of: 'dummy', 'linux', or 'disabled'")
    if "log_level" in data and not isinstance(data["log_level"], str):
        raise ValueError("log_level must be a string")
    if "allowed_clients" in data and not isinstance(data["allowed_clients"], list):
        raise ValueError("allowed_clients must be a list of network strings")
    if "blocked_destinations" in data and not isinstance(
        data["blocked_destinations"], list
    ):
        raise ValueError("blocked_destinations must be a list of network strings")
    if "auth" in data:
        if data["auth"] is not None:
            if not (
                isinstance(data["auth"], dict)
                and "username" in data["auth"]
                and "password" in data["auth"]
            ):
                raise ValueError(
                    "auth must be an object with 'username' and 'password', or null"
                )

    return Config(data)

# --- ./build/lib/socks5tun/logger.py ---
"""
Logging configuration for Socks5 proxy server.
"""
import logging

def setup_logging(level: str):
    """
    Configure logging for the proxy server with the given level.
    """
    # Convert level name to numeric value (default to INFO if unrecognized)
    numeric_level = getattr(logging, level.upper(), logging.INFO)
    logging.basicConfig(
        level=numeric_level,
        format="%(asctime)s [%(levelname)s] [%(threadName)s] %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S"
    )
    # Optionally, adjust logging levels for third-party libraries if needed
    logging.getLogger("urllib3").setLevel(logging.WARNING)

# --- ./build/lib/socks5tun/__init__.py ---

# --- ./build/lib/socks5tun/run.py ---
# run.py
#!/usr/bin/env python3
"""
Entry point for the Socks5 proxy server.
"""
import argparse
import logging
import os
import sys
import threading
import subprocess
import json
import fcntl
import struct
from datetime import datetime

from socks5tun.config import load_config
from socks5tun.logger import setup_logging
from socks5tun.server import SocksServer

logger = logging.getLogger(__name__)


def _ipv4_netmask_to_prefixlen(netmask: str) -> int:
    """
    Convert dotted-decimal netmask (e.g. 255.255.255.0) to prefixlen (e.g. 24).
    Raises ValueError on invalid input.
    """
    parts = netmask.split(".")
    if len(parts) != 4:
        raise ValueError(f"Invalid netmask: {netmask}")
    val = 0
    for p in parts:
        n = int(p)
        if n < 0 or n > 255:
            raise ValueError(f"Invalid netmask octet: {p}")
        val = (val << 8) | n
    # must be contiguous ones followed by zeros
    if val == 0 or val == 0xFFFFFFFF:
        raise ValueError(f"Suspicious netmask: {netmask}")
    if (val | (val - 1)) != 0xFFFFFFFF:
        raise ValueError(f"Non-contiguous netmask: {netmask}")
    return bin(val).count("1")


def main():
    parser = argparse.ArgumentParser(description="Socks5 Proxy Server")
    parser.add_argument(
        "-c",
        "--config",
        default="config_prod.json",
        help="Path to configuration JSON file",
    )
    args = parser.parse_args()

    try:
        cfg = load_config(args.config)
    except FileNotFoundError:
        logger.error("Configuration file not found: %s", args.config)
        sys.exit(1)
    except ValueError as e:
        logger.error("Error in configuration: %s", e)
        sys.exit(1)

    # Setup logging with level from config
    setup_logging(cfg.log_level)
    log = logging.getLogger("socks5-server")

    from ipaddress import ip_network

    # Normalize ACLs
    cfg.allowed_clients = [ip_network(net) for net in cfg.allowed_clients]
    log.debug(">> allowed_clients converted to: %s", cfg.allowed_clients)

    if hasattr(cfg, "blocked_destinations"):
        cfg.blocked_destinations = [ip_network(net) for net in cfg.blocked_destinations]

    if hasattr(cfg, "deny_rules"):
        cfg.deny_rules = [(ip_network(net), port) for net, port in cfg.deny_rules]
        log.debug(">> deny_rules converted to: %s", cfg.deny_rules)

    if hasattr(cfg, "allow_rules"):
        cfg.allow_rules = [(ip_network(net), port) for net, port in cfg.allow_rules]
        log.debug(">> allow_rules converted to: %s", cfg.allow_rules)

    log.info("Starting Socks5 proxy server on %s:%d", cfg.tcp_host, cfg.tcp_port)

    # If TUN interface is enabled in config, open it
    tun = None
    tun_name = None
    if cfg.tun_mode:
        try:
            if cfg.tun_mode == "dummy":
                from socks5tun.dummy_tun import DummyTun

                tun = DummyTun()
                tun.open()
                log.info("Dummy TUN interface opened (not connected to system network)")
            elif cfg.tun_mode == "linux":
                # Set desired name from config (fallback to tun%d if busy)
                desired_name = cfg.tun.get("name", "tun0").encode("utf-8")
                if len(desired_name) > 15:
                    raise ValueError("TUN name too long (max 15 bytes)")

                TUNSETIFF = 0x400454CA
                IFF_TUN = 0x0001
                IFF_NO_PI = 0x1000

                tun_fd = os.open("/dev/net/tun", os.O_RDWR)
                # try desired name first
                ifr = struct.pack(
                    "16sH", desired_name.ljust(16, b"\x00"), IFF_TUN | IFF_NO_PI
                )
                try:
                    ifs = fcntl.ioctl(tun_fd, TUNSETIFF, ifr)
                except OSError:
                    # fallback to auto name
                    ifs = fcntl.ioctl(
                        tun_fd,
                        TUNSETIFF,
                        struct.pack("16sH", b"tun%d", IFF_TUN | IFF_NO_PI),
                    )
                tun_name = ifs[:16].strip(b"\x00").decode("utf-8")
                log.info("🔧 Created TUN interface with name: %s", tun_name)

                class LinuxTun:
                    def __init__(self, fd):
                        self.fd = fd

                    def read(self, size: int = 1500):
                        return os.read(self.fd, size)

                    def write(self, data: bytes):
                        return os.write(self.fd, data)

                    def close(self):
                        os.close(self.fd)

                tun = LinuxTun(tun_fd)
                log.info("Linux TUN interface %s opened", tun_name)

                # --- Auto-configure interface (IPv4 + IPv6). NAT66 остаётся в ExecStartPre. ---
                if os.geteuid() == 0:
                    tun_ip = cfg.tun.get("address", "10.8.0.1")
                    tun_netmask = cfg.tun.get("netmask", "255.255.255.0")
                    try:
                        prefix4 = _ipv4_netmask_to_prefixlen(tun_netmask)
                    except Exception as e:
                        log.warning(
                            "Invalid netmask '%s' (%s); falling back to /24",
                            tun_netmask,
                            e,
                        )
                        prefix4 = 24

                    peer_ip = cfg.tun.get("peer_address", "10.8.0.2")
                    mtu = cfg.tun.get("mtu", 1500)
                    out_iface = cfg.nat.get("out_iface")

                    try:
                        # IPv4 address + peer
                        subprocess.run(
                            [
                                "ip",
                                "addr",
                                "add",
                                f"{tun_ip}/{prefix4}",
                                "peer",
                                peer_ip,
                                "dev",
                                tun_name,
                            ],
                            check=True,
                        )
                    except subprocess.CalledProcessError as e:
                        log.warning(
                            "IPv4 address may already be set on %s: %s", tun_name, e
                        )

                    # MTU + UP
                    subprocess.run(
                        ["ip", "link", "set", tun_name, "mtu", str(mtu)], check=True
                    )
                    subprocess.run(["ip", "link", "set", tun_name, "up"], check=True)

                    log.info(
                        "Configured IPv4 %s/%d peer %s mtu %s on %s",
                        tun_ip,
                        prefix4,
                        peer_ip,
                        mtu,
                        tun_name,
                    )

                    # Enable IPv4 forwarding (temporary; persistent is up to the host)
                    try:
                        with open("/proc/sys/net/ipv4/ip_forward", "w") as f:
                            f.write("1\n")
                    except Exception as e:
                        log.warning("Failed to enable IPv4 forwarding: %s", e)

                    # (Backward-compat) add IPv4 MASQUERADE if out_iface present
                    if out_iface:
                        try:
                            subprocess.run(
                                [
                                    "iptables",
                                    "-t",
                                    "nat",
                                    "-C",
                                    "POSTROUTING",
                                    "-s",
                                    f"{tun_ip}/{prefix4}",
                                    "-o",
                                    out_iface,
                                    "-j",
                                    "MASQUERADE",
                                ],
                                check=True,
                                stdout=subprocess.DEVNULL,
                                stderr=subprocess.DEVNULL,
                            )
                            added_v4 = False
                        except subprocess.CalledProcessError:
                            subprocess.run(
                                [
                                    "iptables",
                                    "-t",
                                    "nat",
                                    "-A",
                                    "POSTROUTING",
                                    "-s",
                                    f"{tun_ip}/{prefix4}",
                                    "-o",
                                    out_iface,
                                    "-j",
                                    "MASQUERADE",
                                ],
                                check=True,
                            )
                            added_v4 = True
                        if added_v4:
                            log.info(
                                "Added IPv4 MASQUERADE rule for %s → %s",
                                tun_name,
                                out_iface,
                            )

                    # IPv6 address (no NAT here; NAT66 handled by ExecStartPre script)
                    addr6 = cfg.tun.get("address6")  # e.g. "fd00:0:0:8::1/64"
                    peer6 = cfg.tun.get("peer_address6")
                    if addr6:
                        try:
                            subprocess.run(
                                ["ip", "-6", "addr", "add", addr6, "dev", tun_name],
                                check=True,
                            )
                            log.info(
                                "Configured IPv6 %s%s on %s",
                                addr6,
                                f" (peer {peer6})" if peer6 else "",
                                tun_name,
                            )
                        except subprocess.CalledProcessError as e:
                            log.warning(
                                "IPv6 address may already be set on %s: %s", tun_name, e
                            )

                else:
                    log.warning(
                        "Skipping TUN auto-setup: not running as root (UID != 0)"
                    )
            else:
                tun = None
        except Exception as e:
            log.error("Failed to initialize TUN interface: %s", e)
            if os.environ.get("ALLOW_CONTINUE_ON_TUN_ERROR") == "1":
                return
            else:
                sys.exit(1)

    # Start the Socks5 server and UDP relay thread
    from socks5tun.udp_handler import start_udp_loop

    def udp_wrapper():
        try:
            start_udp_loop(cfg, tun)
        except Exception as e:
            log.exception("Exception in UDP thread: %s", e)

    threading.Thread(target=udp_wrapper, daemon=True).start()

    # Prevent self-check from hammering the TCP port as "HTTP"
    os.environ["DISABLE_SELF_CONNECT"] = "1"
    server = SocksServer(cfg, tun=tun)

    try:
        log.info(
            "✅ Starting server, patch is active at %s",
            datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        )
        server.start()
    except KeyboardInterrupt:
        log.info("Server interrupted by user, shutting down")
    finally:
        if tun:
            tun.close()

            if getattr(cfg, "tun_mode", None) == "linux":
                # Clean up IPv4 MASQUERADE (we only add v4 inside run.py)
                try:
                    tun_ip = cfg.tun.get("address", "10.8.0.1")
                    tun_netmask = cfg.tun.get("netmask", "255.255.255.0")
                    try:
                        prefix4 = _ipv4_netmask_to_prefixlen(tun_netmask)
                    except Exception:
                        prefix4 = 24
                    out_iface = cfg.nat.get("out_iface")
                    if out_iface:
                        subprocess.run(
                            [
                                "iptables",
                                "-t",
                                "nat",
                                "-D",
                                "POSTROUTING",
                                "-s",
                                f"{tun_ip}/{prefix4}",
                                "-o",
                                out_iface,
                                "-j",
                                "MASQUERADE",
                            ],
                            stdout=subprocess.DEVNULL,
                            stderr=subprocess.DEVNULL,
                            check=False,
                        )
                        log.info(
                            "Removed IPv4 MASQUERADE rule for %s → %s",
                            tun_name or "tun",
                            out_iface,
                        )
                except Exception as e:
                    log.warning("Failed to remove IPv4 MASQUERADE rule: %s", e)

                # Optionally remove IPv6 addr (not strictly required)
                try:
                    addr6 = cfg.tun.get("address6")
                    if addr6:
                        subprocess.run(
                            [
                                "ip",
                                "-6",
                                "addr",
                                "del",
                                addr6,
                                "dev",
                                tun_name or cfg.tun.get("name", "tun0"),
                            ],
                            stdout=subprocess.DEVNULL,
                            stderr=subprocess.DEVNULL,
                            check=False,
                        )
                except Exception:
                    pass

                # Delete TUN device
                try:
                    subprocess.run(
                        [
                            "ip",
                            "tuntap",
                            "del",
                            "dev",
                            (tun_name or cfg.tun.get("name", "tun0")),
                            "mode",
                            "tun",
                        ],
                        stdout=subprocess.DEVNULL,
                        stderr=subprocess.DEVNULL,
                        check=False,
                    )
                    log.info(
                        "Removed TUN interface: %s",
                        tun_name or cfg.tun.get("name", "tun0"),
                    )
                except Exception as e:
                    log.warning("Failed to delete tun %s: %s", tun_name, e)


if __name__ == "__main__":
    main()

# --- ./build/lib/socks5tun/server.py ---
# server.py
import os
import inspect
import psutil
import traceback
import socket
import threading
import select
import logging
import ipaddress

from socks5tun.config import Config

# SOCKS5 protocol constants and values
SOCKS_VERSION = 5
# Authentication methods
NO_AUTH = 0x00
USER_AUTH = 0x02
NO_ACCEPTABLE = 0xFF
# Command codes
CMD_CONNECT = 0x01
CMD_BIND = 0x02  # BIND not implemented
CMD_UDP_ASSOCIATE = 0x03
# Address types
ADDR_IPV4 = 0x01
ADDR_DOMAIN = 0x03
ADDR_IPV6 = 0x04
# Reply codes
REP_SUCCESS = 0x00
REP_GENERAL_FAILURE = 0x01
REP_CONN_NOT_ALLOWED = 0x02
REP_NETWORK_UNREACHABLE = 0x03
REP_HOST_UNREACHABLE = 0x04
REP_CONN_REFUSED = 0x05
REP_TTL_EXPIRED = 0x06
REP_CMD_NOT_SUPPORTED = 0x07
REP_ADDR_NOT_SUPPORTED = 0x08


# Порты, с которых мы ожидаем локальный форвардинг (stunnel, ssh -L, tun2socks и т.п.)
LOCAL_FORWARD_WHITELIST = {443, 1080, 1194}


def is_self_connection(
    client_ip: str, client_port: int, server_port: int
) -> tuple[str, str]:
    """
    Определяет тип соединения:
    - 'self' — loopback + клиентский порт = порт сервера (реальный self-connect)
    - 'local_forward' — loopback + порт клиента в whitelist (ожидаемый локальный форвардер)
    - 'local_other' — loopback всё остальное
    - 'other' — всё остальное
    """
    try:
        ip_obj = ipaddress.ip_address(client_ip)
    except ValueError:
        ip_obj = None

    if ip_obj and ip_obj.is_loopback:
        pname = "unknown"
        pid = None
        for conn in psutil.net_connections(kind='tcp'):
            if not conn.laddr or not conn.raddr:
                continue
            if (
                conn.laddr[1] == server_port
                and conn.raddr[0] == client_ip
                and conn.raddr[1] == client_port
            ):
                pid = conn.pid
                if pid:
                    try:
                        pname = psutil.Process(pid).name()
                    except Exception:
                        pass
                break

        # 1. Настоящий self-connect
        if client_port == server_port:
            return "self", f"{pid} {pname}"

        # 2. Локальный форвард (по whitelist портов)
        if client_port in LOCAL_FORWARD_WHITELIST:
            return "local_forward", f"{pid} {pname}"

        # 3. Остальное loopback
        return "local_other", f"{pid} {pname if pname else 'unknown'}"

    return "other", "unknown"


def recv_exact(conn, n):
    """Читает ровно n байт из сокета, иначе выбрасывает исключение."""
    data = b''
    while len(data) < n:
        chunk = conn.recv(n - len(data))
        if not chunk:
            raise IOError("Connection closed prematurely")
        data += chunk
    return data


class SocksServer:
    """
    A Socks5 proxy server that handles TCP CONNECT and UDP ASSOCIATE commands.
    """

    def __init__(self, config: Config, tun=None):
        self.config = config
        self.tun = tun  # DummyTun or real TUN interface if provided
        self._log = logging.getLogger("socks5-server")
        # Prepare allowed client networks
        self.allowed_nets = config.allowed_clients
        # Authentication setup
        self.auth_required = config.auth is not None
        self.auth_credentials = config.auth if config.auth else {}

    def start(self):
        """
        Start the Socks5 server: bind and listen for incoming connections,
        handle each in a new thread.
        """

        self._log.warning(
            "[DEBUG] Server started — stack:\n%s",
            ''.join(traceback.format_stack(limit=10)),
        )

        # Выбираем тип адреса
        family = socket.AF_INET6 if ':' in self.config.tcp_host else socket.AF_INET
        with socket.socket(family, socket.SOCK_STREAM) as server_sock:
            server_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            server_sock.bind((self.config.tcp_host, self.config.tcp_port))
            server_sock.listen()
            self._log.info(
                "Listening on %s:%d",
                self.config.tcp_host,
                self.config.tcp_port,
            )

            while True:
                try:
                    client_sock, client_addr = server_sock.accept()

                    # --- NEW: проверка IP клиента ---
                    if not self._is_client_allowed(client_addr[0]):
                        self._log.warning(
                            "Rejected connection from %s:%d "
                            "(not in allowed_clients)",
                            client_addr[0],
                            client_addr[1],
                        )
                        client_sock.close()
                        continue  # ждём следующий accept
                    # --------------------------------

                    # Определяем тип подключения и информацию о процессе
                    ctype, who = is_self_connection(
                        client_addr[0], client_addr[1], self.config.tcp_port
                    )

                    if ctype == "self":
                        # Настоящий self-test
                        self._log.info(
                            "[🧪 SELF-TEST] Accepted internal connection "
                            "from %s:%d (%s)",
                            client_addr[0],
                            client_addr[1],
                            who,
                        )
                        stack = inspect.stack()
                        self._log.debug(
                            "Top call: %s:%d in %s()",
                            stack[1].filename,
                            stack[1].lineno,
                            stack[1].function,
                        )

                    elif ctype == "local_stunnel":
                        # Локальный stunnel на loopback
                        self._log.info(
                            "[LOCAL STUNNEL] TCP connection from %s:%d (%s)",
                            client_addr[0],
                            client_addr[1],
                            who,
                        )

                    elif ctype == "local_other":
                        self._log.info(
                            "[LOCAL] TCP connection from %s:%d (%s)",
                            client_addr[0],
                            client_addr[1],
                            who,
                        )

                    elif ctype == "local_forward":
                        self._log.info(
                            "[LOCAL FORWARD] TCP connection from %s:%d (%s)",
                            client_addr[0],
                            client_addr[1],
                            who,
                        )

                    else:
                        # Любое другое подключение
                        self._log.info(
                            "[ACCEPT] TCP connection from %s:%d by %s",
                            client_addr[0],
                            client_addr[1],
                            who,
                        )
                        self._log.debug(
                            "[TRACE] Stack trace for connection from %s:%d:\n%s",
                            client_addr[0],
                            client_addr[1],
                            ''.join(traceback.format_stack(limit=8)),
                        )

                    # Запускаем обработчик клиента в отдельном потоке
                    threading.Thread(
                        target=self._handle_client,
                        args=(client_sock, client_addr),
                        daemon=True,
                    ).start()

                except OSError:
                    break

    def _is_client_allowed(self, client_ip: str) -> bool:
        """Check if the client IP is in allowed networks."""
        ip_obj = ipaddress.ip_address(client_ip)
        return any(ip_obj in net for net in self.allowed_nets)

    def _is_dest_allowed(self, dest_ip: str, dest_port: int) -> bool:
        """Check if the destination IP:
        port is permitted by allow/deny rules."""
        try:
            ip_obj = ipaddress.ip_address(dest_ip)
        except Exception:
            return False
        # Deny rules
        for net, port in getattr(self.config, "deny_rules", []):
            if ip_obj in net and (port is None or dest_port == port):
                return False
        # Allow rules
        allow_rules = getattr(self.config, "allow_rules", [])
        if allow_rules:
            allowed = False
            for net, port in allow_rules:
                if ip_obj in net and (port is None or dest_port == port):
                    allowed = True
                    break
            if not allowed:
                return False
        return True

    def _handle_client(self, conn: socket.socket, client_addr):
        if client_addr[0] == "127.0.0.1":
            self._log.warning(
                "👀 LOCAL connection from %s — likely self-initiated",
                client_addr[0],
            )

        try:
            # Для DummySocket в тестах отключаем setsockopt
            if hasattr(conn, "setsockopt"):
                conn.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)

            header = recv_exact(conn, 2)
            self._log.warning(
                "[SNIFF] First 2 bytes from %s:%d: hex=%s ascii=%r",
                client_addr[0],
                client_addr[1],
                header.hex(),
                header,
            )
            proto_guess = None
            if header.startswith(b"PO") or header.startswith(b"GE"):
                proto_guess = "HTTP"
            elif header.startswith(b"\x16\x03"):
                proto_guess = "TLS"
            elif header.startswith(b"CO"):
                proto_guess = "HTTPS proxy (CONNECT)"
            elif header[0] != 0x05:
                proto_guess = "Unknown non-SOCKS"

            if proto_guess:
                self._log.warning(
                    "[GUESS] %s:%d likely using %s instead of SOCKS5",
                    client_addr[0],
                    client_addr[1],
                    proto_guess,
                )
            ver, nmethods = header[0], header[1]
            self._log.info(
                "SOCKS5 handshake header from %s: %s", client_addr[0], header.hex()
            )

            if ver != SOCKS_VERSION:
                self._log.error(
                    "Unsupported SOCKS version %d from %s", ver, client_addr[0]
                )
                conn.close()
                return

            methods = recv_exact(conn, nmethods)
            self._log.info(
                "SOCKS5 methods from %s: %s",
                client_addr[0],
                methods.hex(),
            )

            self._log.debug(
                "[DEBUG] Waiting for SOCKS5 request from %s:%d...",
                client_addr[0],
                client_addr[1],
            )

            if self.auth_required:
                if USER_AUTH not in methods:
                    conn.sendall(bytes([SOCKS_VERSION, NO_ACCEPTABLE]))
                    conn.close()
                    return
                conn.sendall(bytes([SOCKS_VERSION, USER_AUTH]))

                ver_auth = recv_exact(conn, 1)
                if ver_auth[0] != 0x01:
                    conn.close()
                    return

                ulen = recv_exact(conn, 1)[0]
                username = recv_exact(conn, ulen).decode()

                plen = recv_exact(conn, 1)[0]
                password = recv_exact(conn, plen).decode()

                if username != self.auth_credentials.get(
                    "username"
                ) or password != self.auth_credentials.get("password"):
                    conn.sendall(bytes([0x01, 0x01]))
                    self._log.warning(
                        "Authentication failed for %s",
                        client_addr[0],
                    )
                    conn.close()
                    return
                else:
                    conn.sendall(bytes([0x01, 0x00]))
            else:
                if NO_AUTH in methods:
                    conn.sendall(bytes([SOCKS_VERSION, NO_AUTH]))
                else:
                    conn.sendall(bytes([SOCKS_VERSION, NO_ACCEPTABLE]))
                    conn.close()
                    return

            self._log.debug(
                "[DEBUG] Waiting for SOCKS5 request from %s:%d...",
                client_addr[0],
                client_addr[1],
            )

            # Добавь timeout через select (например, 3 секунды)
            ready, _, _ = select.select([conn], [], [], 3)
            if not ready:
                self._log.warning(
                    "[TIMEOUT] Client %s:%d did not send "
                    "SOCKS5 request after handshake",
                    client_addr[0],
                    client_addr[1],
                )
                conn.close()
                return
            request = recv_exact(conn, 4)

            self._log.info(
                "SOCKS5 request header from %s: %s",
                client_addr[0],
                request.hex(),
            )
            ver, cmd, _, atyp = request

            if ver != SOCKS_VERSION:
                self._log.error(
                    "Mismatched SOCKS version in request from %s",
                    client_addr[0],
                )
                conn.close()
                return

            if cmd == CMD_CONNECT:
                self._handle_connect(conn, atyp, client_addr)
            elif cmd == CMD_UDP_ASSOCIATE:
                self._handle_udp_associate(conn, atyp, client_addr)
            else:
                self._send_reply(
                    conn,
                    REP_CMD_NOT_SUPPORTED,
                    bind_ip="0.0.0.0",
                    bind_port=0,
                    atyp=ADDR_IPV4,
                )
                conn.close()

        except ConnectionResetError:
            self._log.warning(
                "Client %s forcibly closed the connection (RST)",
                client_addr[0],
            )
        except EOFError:
            self._log.warning(
                "Client %s closed connection with EOF",
                client_addr[0],
            )
        except Exception as e:
            is_self, who = is_self_connection(
                client_addr[0], client_addr[1], self.config.tcp_port
            )
            if is_self or client_addr[0] == "127.0.0.1":
                self._log.info(
                    "🔁 [LOCAL/SELF] "
                    "Connection from %s "
                    "closed prematurely "
                    "(%s)",
                    client_addr[0],
                    who if is_self else str(e),
                )
            else:
                self._log.error(
                    "Error handling client %s: %s",
                    client_addr[0],
                    e,
                )

        finally:
            try:
                conn.close()
            except Exception:
                pass

    def _handle_connect(self, conn: socket.socket, atyp: int, client_addr):
        """Handle SOCKS5 CONNECT (TCP forwarding)"""
        try:
            dest_addr, dest_port = self._read_dest_address(conn, atyp)
        except Exception as e:
            self._log.error(
                "Failed to parse destination address from %s: %s",
                client_addr[0],
                e,
            )
            rep = (
                REP_ADDR_NOT_SUPPORTED
                if isinstance(e, ValueError)
                else REP_GENERAL_FAILURE
            )
            self._send_reply(
                conn,
                rep,
                bind_ip="0.0.0.0",
                bind_port=0,
                atyp=ADDR_IPV4,
            )
            conn.close()
            return
        # Check against allow/deny rules
        if not self._is_dest_allowed(dest_addr, dest_port):
            self._log.info(
                "Blocked destination %s requested by %s",
                dest_addr,
                client_addr[0],
            )
            self._send_reply(
                conn,
                REP_CONN_NOT_ALLOWED,
                bind_ip="0.0.0.0",
                bind_port=0,
                atyp=ADDR_IPV4,
            )
            conn.close()
            return
        # Create remote socket to target
        remote_family = socket.AF_INET6 if ':' in dest_addr else socket.AF_INET
        try:
            remote_sock = socket.socket(remote_family, socket.SOCK_STREAM)
            remote_sock.connect((dest_addr, dest_port))
        except socket.error as e:
            err_no = getattr(e, 'errno', None)
            if err_no in (111, 61):
                rep = REP_CONN_REFUSED
            elif err_no in (113, 101):
                rep = REP_HOST_UNREACHABLE
            else:
                rep = REP_GENERAL_FAILURE
            self._log.error(
                "TCP Connect to %s:%d failed: %s",
                dest_addr,
                dest_port,
                e,
            )
            self._send_reply(
                conn,
                rep,
                bind_ip="0.0.0.0",
                bind_port=0,
                atyp=ADDR_IPV4,
            )
            conn.close()
            return
        # Connected successfully
        bind_ip, bind_port = remote_sock.getsockname()[:2]
        reply_atyp = ADDR_IPV6 if remote_family == socket.AF_INET6 else ADDR_IPV4
        self._send_reply(
            conn,
            REP_SUCCESS,
            bind_ip=bind_ip,
            bind_port=bind_port,
            atyp=reply_atyp,
        )
        self._log.info(
            "Established TCP tunnel from %s to %s:%d",
            client_addr[0],
            dest_addr,
            dest_port,
        )
        try:
            self._exchange_loop(conn, remote_sock)
        finally:
            remote_sock.close()
            conn.close()
            self._log.info("Closed TCP tunnel for %s", client_addr[0])

    def _handle_udp_associate(
        self,
        conn: socket.socket,
        atyp: int,
        client_addr,
    ):
        """Handle SOCKS5 UDP ASSOCIATE (UDP relay)"""
        try:
            client_ip, client_port = self._read_dest_address(conn, atyp)
        except Exception:
            client_ip, client_port = client_addr[0], 0
        # Determine address and port for UDP relay from config
        bind_ip = self.config.udp_host
        if bind_ip == "0.0.0.0":
            bind_ip = conn.getsockname()[0]
            if bind_ip == "0.0.0.0":
                bind_ip = "0.0.0.0"
        if bind_ip in ("::", "::0", "0:0:0:0:0:0:0:0"):
            local_ip = conn.getsockname()[0]
            if local_ip and local_ip != "::":
                bind_ip = local_ip
            else:
                bind_ip = "::"
        reply_atyp = ADDR_IPV6 if ':' in bind_ip else ADDR_IPV4
        self._send_reply(
            conn,
            REP_SUCCESS,
            bind_ip=bind_ip,
            bind_port=self.config.udp_port,
            atyp=reply_atyp,
        )
        self._log.info(
            "UDP association established with %s, UDP relay port %d",
            client_addr[0],
            self.config.udp_port,
        )
        try:
            conn.recv(1)
        except Exception:
            pass
        conn.close()
        self._log.info("Closed UDP association for %s", client_addr[0])

    def _exchange_loop(
        self,
        client_sock: socket.socket,
        remote_sock: socket.socket,
    ):
        """Relay data between client
        and remote sockets until one side closes."""
        while True:
            rlist, _, _ = select.select([client_sock, remote_sock], [], [])
            if client_sock in rlist:
                data = client_sock.recv(4096)
                if not data:
                    break
                remote_sock.sendall(data)
            if remote_sock in rlist:
                data = remote_sock.recv(4096)
                if not data:
                    break
                client_sock.sendall(data)

    def _send_reply(
        self,
        conn: socket.socket,
        rep: int,
        bind_ip: str,
        bind_port: int,
        atyp: int,
    ):
        """Send a SOCKS5 reply packet
        with given reply code and bind address/port."""
        try:
            if atyp == ADDR_IPV4:
                addr_bytes = socket.inet_aton(bind_ip)
            elif atyp == ADDR_IPV6:
                addr_bytes = socket.inet_pton(socket.AF_INET6, bind_ip)
            elif atyp == ADDR_DOMAIN:
                addr_bytes = bytes([len(bind_ip)]) + bind_ip.encode('utf-8')
            else:
                atyp = ADDR_IPV4
                addr_bytes = b"\x00\x00\x00\x00"
            port_bytes = int(bind_port).to_bytes(2, 'big')
            response = (
                bytes(
                    [
                        SOCKS_VERSION,
                        rep,
                        0x00,
                        atyp,
                    ]
                )
                + addr_bytes
                + port_bytes
            )
            conn.sendall(response)
        except Exception as e:
            self._log.error("Failed to send reply to client: %s", e)

    def _read_dest_address(self, conn: socket.socket, atyp: int):
        """
        Read destination address and port from the client request.
        Returns a tuple (dest_addr, dest_port).
        """
        if atyp == ADDR_IPV4:
            addr_bytes = conn.recv(4)
            if len(addr_bytes) < 4:
                raise IOError("Incomplete IPv4 address")
            dest_addr = socket.inet_ntoa(addr_bytes)
            port_bytes = conn.recv(2)
            if len(port_bytes) < 2:
                raise IOError("Incomplete port")
            dest_port = int.from_bytes(port_bytes, 'big')
            return dest_addr, dest_port
        elif atyp == ADDR_DOMAIN:
            length_byte = conn.recv(1)
            if not length_byte:
                raise IOError("Incomplete domain length")
            length = length_byte[0]
            domain_bytes = conn.recv(length)
            if len(domain_bytes) < length:
                raise IOError("Incomplete domain name")
            dest_domain = domain_bytes.decode('utf-8', 'ignore')
            port_bytes = conn.recv(2)
            if len(port_bytes) < 2:
                raise IOError("Incomplete port")
            dest_port = int.from_bytes(port_bytes, 'big')
            try:
                dest_addr = socket.gethostbyname(dest_domain)
            except Exception as e:
                self._log.warning(
                    "Failed to resolve domain %s: %s",
                    dest_domain,
                    e,
                )
                raise e
            return dest_addr, dest_port
        elif atyp == ADDR_IPV6:
            addr_bytes = conn.recv(16)
            if len(addr_bytes) < 16:
                raise IOError("Incomplete IPv6 address")
            dest_addr = socket.inet_ntop(socket.AF_INET6, addr_bytes)
            port_bytes = conn.recv(2)
            if len(port_bytes) < 2:
                raise IOError("Incomplete port")
            dest_port = int.from_bytes(port_bytes, 'big')
            return dest_addr, dest_port
        else:
            raise ValueError("Unsupported address type %d" % atyp)

# --- ./build/lib/socks5tun/udp_handler.py ---
# udp_handler.py
import socket
import logging
import struct
import threading
from ipaddress import ip_address, ip_network

logger = logging.getLogger("socks5-server")


class UDPHandler:
    def __init__(self, cfg, tun):
        self.cfg = cfg
        self.tun = tun
        self.remote_map = {}
        # Load legacy forbidden networks if present (for compatibility)
        self.forbidden_networks = []
        if hasattr(cfg, "forbidden_networks"):
            for net in cfg.forbidden_networks:
                try:
                    self.forbidden_networks.append(ip_network(net))
                except ValueError:
                    continue

    def _ip_checksum(self, data: bytes) -> int:
        """Calculate IPv4 header checksum."""
        if len(data) % 2 == 1:
            data += b"\x00"
        total = 0
        for i in range(0, len(data), 2):
            word = data[i] << 8 | data[i + 1]
            total += word
        total = (total >> 16) + (total & 0xFFFF)
        total = ~total & 0xFFFF
        return total

    def _udp_checksum_v6(
        self, src_ip: str, dst_ip: str, udp_header: bytes, payload: bytes
    ) -> int:
        """
        RFC 2460/8200: UDP checksum over IPv6 pseudo-header + UDP header (csum=0) + payload.
        """
        src_bytes = socket.inet_pton(socket.AF_INET6, src_ip)
        dst_bytes = socket.inet_pton(socket.AF_INET6, dst_ip)
        udp_len = len(udp_header) + len(payload)
        pseudo = (
            src_bytes
            + dst_bytes
            + struct.pack("!I", udp_len)
            + b"\x00\x00\x00"
            + struct.pack("!B", socket.IPPROTO_UDP)
        )
        hdr = bytearray(udp_header)
        hdr[6:8] = b"\x00\x00"
        data = pseudo + bytes(hdr) + payload
        if len(data) % 2:
            data += b"\x00"
        total = 0
        for i in range(0, len(data), 2):
            total += (data[i] << 8) | data[i + 1]
        total = (total >> 16) + (total & 0xFFFF)
        total = (total >> 16) + (total & 0xFFFF)
        csum = (~total) & 0xFFFF
        return 0xFFFF if csum == 0 else csum

    def handle_client_packet(self, data: bytes, client_addr):
        """
        Handle a UDP packet from client (SOCKS5 UDP ASSOCIATE).
        data: raw UDP datagram from client (including SOCKS5 UDP header).
        client_addr: tuple (src_ip, src_port) of the client.
        """
        # Minimum UDP header length is 4 bytes
        if len(data) < 4:
            return
        # Check reserved bytes and fragmentation field
        if data[0] != 0x00 or data[1] != 0x00:
            return  # Invalid reserved field
        frag = data[2]
        if frag != 0x00:
            logger.warning(
                f"Received fragmented UDP packet from {client_addr}, dropping"
            )
            return

        atyp = data[3]
        offset = 4
        dest_addr = None
        dest_port = None

        # Parse destination based on ATYP
        if atyp == 0x01:  # IPv4
            if len(data) < offset + 6:
                return
            dest_addr = socket.inet_ntoa(data[offset : offset + 4])
            offset += 4
            dest_port = struct.unpack("!H", data[offset : offset + 2])[0]
            offset += 2

        elif atyp == 0x03:  # Domain name
            if len(data) < offset + 1:
                return
            name_len = data[offset]
            offset += 1
            if len(data) < offset + name_len + 2:
                return
            dest_name = data[offset : offset + name_len].decode(
                "ascii", errors="ignore"
            )
            offset += name_len
            dest_port = struct.unpack("!H", data[offset : offset + 2])[0]
            offset += 2

            # Политика DNS: при "remote"/"none" не резолвим локально
            dns_mode = getattr(self.cfg, "dns_resolver", "system")
            if dns_mode in ("remote", "none"):
                logger.warning(
                    f"[UDP-DENY ] {client_addr[0]}:{client_addr[1]} → {dest_name}:{dest_port} reason=dns_remote_mode"
                )
                return

            # Предпочесть IPv6, если слушаем на :: (dual-stack), иначе IPv4; с фоллбеком
            prefer_v6 = ":" in self.cfg.udp_host
            family = socket.AF_INET6 if prefer_v6 else socket.AF_INET
            try:
                addrs = socket.getaddrinfo(
                    dest_name,
                    dest_port,
                    family=family,
                    type=socket.SOCK_DGRAM,
                    proto=socket.IPPROTO_UDP,
                )
            except Exception:
                addrs = []

            if not addrs:
                alt_family = (
                    socket.AF_INET if family == socket.AF_INET6 else socket.AF_INET6
                )
                try:
                    addrs = socket.getaddrinfo(
                        dest_name,
                        dest_port,
                        family=alt_family,
                        type=socket.SOCK_DGRAM,
                        proto=socket.IPPROTO_UDP,
                    )
                except Exception:
                    addrs = []

            if not addrs:
                logger.warning(
                    f"[UDP-DENY ] {client_addr[0]}:{client_addr[1]} → {dest_name}:{dest_port} reason=resolve_fail"
                )
                return

            dest_addr = addrs[0][4][0]

        elif atyp == 0x04:  # IPv6
            if len(data) < offset + 18:
                return
            try:
                dest_addr = socket.inet_ntop(
                    socket.AF_INET6, data[offset : offset + 16]
                )
            except OSError:
                return
            offset += 16
            dest_port = struct.unpack("!H", data[offset : offset + 2])[0]
            offset += 2
        else:
            return

        payload = data[offset:]
        if dest_addr is None:
            return

        # Apply allow/deny filtering
        allowed = True
        reason = "deny_rule"
        try:
            ip_obj = ip_address(dest_addr)
        except ValueError:
            ip_obj = None

        if ip_obj:
            # Deny rules
            for net, port in getattr(self.cfg, "deny_rules", []):
                if ip_obj in net and (port is None or dest_port == port):
                    allowed = False
                    break
            # Legacy forbidden if no explicit deny
            if allowed and not getattr(self.cfg, "deny_rules", []):
                for net in self.forbidden_networks:
                    if ip_obj in net:
                        allowed = False
                        break
            # Allow rules gate
            if allowed and getattr(self.cfg, "allow_rules", []):
                matched = False
                for net, port in self.cfg.allow_rules:
                    if ip_obj in net and (port is None or dest_port == port):
                        matched = True
                        break
                if not matched:
                    allowed = False
        else:
            allowed = False

        if not allowed:
            logger.warning(
                f"[UDP-DENY ] {client_addr[0]}:{client_addr[1]} → {dest_addr}:{dest_port} reason={reason}"
            )
            return

        # Build packet and forward to TUN
        ip_obj = ip_address(dest_addr)
        if ip_obj.version == 4:
            # Source: prefer configured peer_address (inside tunnel), fallback to client socket addr
            src_ip = self.cfg.tun.get("peer_address", client_addr[0])
            src_port = client_addr[1] & 0xFFFF
            dst_ip = dest_addr

            # IPv4 header
            version = 4
            ihl = 5
            ver_ihl = (version << 4) + ihl
            tos = 0
            total_length = 20 + 8 + len(payload)
            identification = 0
            flags_offset = 0
            ttl = 64
            protocol = socket.IPPROTO_UDP
            src_ip_bytes = socket.inet_aton(src_ip)
            dst_ip_bytes = socket.inet_aton(dst_ip)
            ip_header = struct.pack(
                "!BBHHHBBH4s4s",
                ver_ihl,
                tos,
                total_length,
                identification,
                flags_offset,
                ttl,
                protocol,
                0,
                src_ip_bytes,
                dst_ip_bytes,
            )
            checksum = self._ip_checksum(ip_header)
            ip_header = struct.pack(
                "!BBHHHBBH4s4s",
                ver_ihl,
                tos,
                total_length,
                identification,
                flags_offset,
                ttl,
                protocol,
                checksum,
                src_ip_bytes,
                dst_ip_bytes,
            )

            # UDP header (IPv4 UDP checksum may be zero; many stacks allow this)
            dst_port_net = dest_port & 0xFFFF
            udp_length = 8 + len(payload)
            udp_header = struct.pack("!HHHH", src_port, dst_port_net, udp_length, 0)

            packet = ip_header + udp_header + payload
            try:
                self.tun.write(packet)
            except Exception as e:
                logger.error("Failed to write IPv4 packet to TUN: %s", e)
                return
            self.remote_map[(dest_addr, dest_port)] = client_addr

        elif ip_obj.version == 6:
            # IPv6 build & send into TUN (UDP checksum REQUIRED)
            src_ip = (
                self.cfg.tun.get("peer_address6") or self.cfg.tun.get("peer_address_v6")
            ) or client_addr[0]
            try:
                socket.inet_pton(socket.AF_INET6, src_ip)
                socket.inet_pton(socket.AF_INET6, dest_addr)
            except OSError:
                logger.error("Invalid IPv6 src/dst: %s -> %s", src_ip, dest_addr)
                return

            version = 6
            traffic_class = 0
            flow_label = 0
            udp_len = 8 + len(payload)
            next_hdr = socket.IPPROTO_UDP
            hop_limit = 64
            ver_tc_fl = (version << 28) | (traffic_class << 20) | flow_label
            ip6_header = struct.pack(
                "!IHBB16s16s",
                ver_tc_fl,
                udp_len,
                next_hdr,
                hop_limit,
                socket.inet_pton(socket.AF_INET6, src_ip),
                socket.inet_pton(socket.AF_INET6, dest_addr),
            )
            src_port = client_addr[1] & 0xFFFF
            udp_header = struct.pack("!HHHH", src_port, dest_port & 0xFFFF, udp_len, 0)
            csum = self._udp_checksum_v6(src_ip, dest_addr, udp_header, payload)
            udp_header = struct.pack(
                "!HHHH", src_port, dest_port & 0xFFFF, udp_len, csum
            )

            packet = ip6_header + udp_header + payload
            try:
                self.tun.write(packet)
            except Exception as e:
                logger.error("Failed to write IPv6 packet to TUN: %s", e)
                return
            self.remote_map[(dest_addr, dest_port)] = client_addr

        else:
            return

        logger.info(
            f"[UDP-ALLOW] {client_addr[0]}:{client_addr[1]} → {dest_addr}:{dest_port} len={len(payload)}"
        )


def start_udp_loop(cfg, tun):
    """
    Start a loop to handle global UDP relay.
    Listens on cfg.udp_host:cfg.udp_port for UDP traffic.
    """

    def _normalize_ip_for_acl(addr: str) -> str:
        # convert ::ffff:a.b.c.d → a.b.c.d for ACL checks
        if addr.startswith("::ffff:"):
            try:
                v4 = addr.split("::ffff:")[-1]
                socket.inet_pton(socket.AF_INET, v4)
                return v4
            except Exception:
                return addr
        return addr

    family = (
        socket.AF_INET6
        if (cfg.udp_host == "::" or ":" in cfg.udp_host)
        else socket.AF_INET
    )
    udp_sock = socket.socket(family, socket.SOCK_DGRAM)
    if family == socket.AF_INET6:
        # Allow IPv4 on IPv6 socket (dual-stack)
        try:
            udp_sock.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_V6ONLY, 0)
        except OSError as e:
            logger.warning("Could not set IPV6_V6ONLY=0: %s", e)

    logger.debug("[BOOT] Entered start_udp_loop()")
    try:
        udp_sock.bind((cfg.udp_host, cfg.udp_port))
    except OSError as e:
        logger.error(
            "Failed to bind UDP socket on %s:%d — %s",
            cfg.udp_host,
            cfg.udp_port,
            e,
        )
        return

    logger.info("[DEBUG] Bound UDP socket on %s:%d", cfg.udp_host, cfg.udp_port)
    logger.info(f"UDP relay socket listening on {cfg.udp_host}:{cfg.udp_port}")

    # Mapping for direct UDP mode (dest -> client)
    remote_map = {}

    # Handler for client packets
    handler = UDPHandler(cfg, tun)
    handler.remote_map = remote_map

    # If TUN interface is available, start thread to handle incoming packets from TUN
    if tun:

        def tun_reader():
            while True:
                try:
                    packet = tun.read()
                except Exception as e:
                    logger.error("UDP tun read error: %s", e)
                    break
                if not packet:
                    break

                # IPv4/IPv6 from TUN
                if len(packet) < 1:
                    continue
                version = packet[0] >> 4

                if version == 4:
                    if len(packet) < 28:
                        continue
                    if packet[9] != socket.IPPROTO_UDP:
                        continue
                    src_ip = socket.inet_ntoa(packet[12:16])
                    src_port = int.from_bytes(packet[20:22], "big")
                    payload = packet[28:]
                    client_key = (src_ip, src_port)

                elif version == 6:
                    if len(packet) < 48:
                        continue
                    if packet[6] != socket.IPPROTO_UDP:
                        continue
                    src_ip = socket.inet_ntop(socket.AF_INET6, packet[8:24])
                    src_port = int.from_bytes(packet[40:42], "big")
                    payload = packet[48:]
                    client_key = (src_ip, src_port)

                else:
                    continue

                if client_key not in remote_map:
                    logger.warning(
                        "Received UDP from %s:%d with no client mapping",
                        client_key[0],
                        client_key[1],
                    )
                    continue

                client_addr = remote_map[client_key]

                # Build SOCKS5 UDP response
                try:
                    if ":" in src_ip:
                        addr_bytes = socket.inet_pton(socket.AF_INET6, src_ip)
                        resp_atyp = 0x04
                    else:
                        addr_bytes = socket.inet_aton(src_ip)
                        resp_atyp = 0x01
                    port_bytes = src_port.to_bytes(2, "big")
                    resp_header = (
                        b"\x00\x00\x00" + bytes([resp_atyp]) + addr_bytes + port_bytes
                    )
                    response_data = resp_header + payload
                    udp_sock.sendto(response_data, client_addr)
                except Exception as e:
                    logger.error(
                        "Failed to send UDP packet to client %s:%d - %s",
                        client_addr[0],
                        client_addr[1],
                        e,
                    )

        threading.Thread(target=tun_reader, daemon=True).start()

    # Main loop to handle incoming UDP datagrams on socket
    logger.debug("[BOOT] Entering UDP receive loop...")

    while True:
        try:
            logger.debug("[LOOP] Waiting for UDP packet...")
            data, addr = udp_sock.recvfrom(65535)
            logger.debug(
                "[TRACE] --- UDP packet received from %s:%d ---", addr[0], addr[1]
            )
            logger.debug(
                "[DEBUG] Got UDP from %s:%d, len=%d", addr[0], addr[1], len(data)
            )

            client_ip, client_port = addr[0], addr[1]
            norm_ip = _normalize_ip_for_acl(client_ip)
            try:
                ip_obj = ip_address(norm_ip)
            except ValueError:
                ip_obj = None
            is_client = ip_obj is not None and any(
                ip_obj in net for net in cfg.allowed_clients
            )

            # extra trace
            logger.debug("[TRACE] UDP packet from: %s:%d", client_ip, client_port)
            logger.debug("[TRACE] Evaluated ip_obj: %s", ip_obj)
            logger.debug("[TRACE] allowed_clients: %s", cfg.allowed_clients)
            logger.debug("[TRACE] is_client: %s", is_client)

        except Exception as e:
            logger.error("UDP socket error: %s", e)
            break

        # duplicate vars for clarity below
        client_ip, client_port = addr[0], addr[1]
        norm_ip = _normalize_ip_for_acl(client_ip)
        try:
            ip_obj = ip_address(norm_ip)
        except ValueError:
            ip_obj = None
        is_client = ip_obj is not None and any(
            ip_obj in net for net in cfg.allowed_clients
        )
        logger.debug("[CHECK] Incoming UDP from %s:%d", client_ip, client_port)
        logger.debug("[CHECK] allowed_clients = %s", cfg.allowed_clients)
        logger.debug("[CHECK] ip_obj = %s", ip_obj)
        logger.debug("[CHECK] is_client = %s", is_client)

        if is_client:
            # UDP datagram from an allowed client
            if tun:
                logger.debug(
                    "[DEBUG] handle_client_packet from %s:%d, raw: %s",
                    addr[0],
                    addr[1],
                    data.hex(),
                )
                try:
                    handler.handle_client_packet(data, addr)
                except Exception as e:
                    logger.error("Exception in handle_client_packet: %s", e)
            else:
                # Direct UDP forward (no TUN)
                if len(data) < 4:
                    continue
                if data[0] != 0x00 or data[1] != 0x00:
                    continue
                if data[2] != 0x00:
                    continue
                atyp = data[3]
                off = 4
                dest_addr = None
                dest_port = None

                if atyp == 0x01:
                    if len(data) < off + 6:
                        continue
                    dest_addr = socket.inet_ntoa(data[off : off + 4])
                    off += 4
                    dest_port = int.from_bytes(data[off : off + 2], "big")
                    off += 2

                elif atyp == 0x03:
                    if len(data) < off + 1:
                        continue
                    name_len = data[off]
                    off += 1
                    if len(data) < off + name_len + 2:
                        continue
                    dest_name = data[off : off + name_len].decode(
                        "ascii", errors="ignore"
                    )
                    off += name_len
                    dest_port = int.from_bytes(data[off : off + 2], "big")
                    off += 2

                    # Политика DNS: при "remote"/"none" не резолвим локально
                    dns_mode = getattr(cfg, "dns_resolver", "system")
                    if dns_mode in ("remote", "none"):
                        logger.warning(
                            f"[UDP-DENY ] {client_ip}:{client_port} → {dest_name}:{dest_port} reason=dns_remote_mode"
                        )
                        continue

                    # Предпочесть IPv6, если слушаем на :: (dual-stack), иначе IPv4; с фоллбеком
                    prefer_v6 = family == socket.AF_INET6
                    fam = socket.AF_INET6 if prefer_v6 else socket.AF_INET
                    try:
                        info_list = socket.getaddrinfo(
                            dest_name,
                            dest_port,
                            family=fam,
                            type=socket.SOCK_DGRAM,
                            proto=socket.IPPROTO_UDP,
                        )
                    except Exception:
                        info_list = []

                    if not info_list:
                        alt_fam = (
                            socket.AF_INET
                            if fam == socket.AF_INET6
                            else socket.AF_INET6
                        )
                        try:
                            info_list = socket.getaddrinfo(
                                dest_name,
                                dest_port,
                                family=alt_fam,
                                type=socket.SOCK_DGRAM,
                                proto=socket.IPPROTO_UDP,
                            )
                        except Exception:
                            info_list = []

                    if not info_list:
                        logger.warning(
                            f"[UDP-DENY ] {client_ip}:{client_port} → {dest_name}:{dest_port} reason=resolve_fail"
                        )
                        continue

                    dest_addr = info_list[0][4][0]

                elif atyp == 0x04:
                    if len(data) < off + 18:
                        continue
                    try:
                        dest_addr = socket.inet_ntop(
                            socket.AF_INET6, data[off : off + 16]
                        )
                    except OSError:
                        continue
                    off += 16
                    dest_port = int.from_bytes(data[off : off + 2], "big")
                    off += 2

                else:
                    continue

                payload = data[off:]
                if dest_addr is None:
                    continue

                # Filtering (reuse same logic as above)
                allowed = True
                reason = "deny_rule"
                try:
                    dest_ip_obj = ip_address(dest_addr)
                except ValueError:
                    dest_ip_obj = None
                if dest_ip_obj:
                    for net, port in getattr(cfg, "deny_rules", []):
                        if dest_ip_obj in net and (port is None or dest_port == port):
                            allowed = False
                            break
                    if allowed and getattr(cfg, "allow_rules", []):
                        match = False
                        for net, port in cfg.allow_rules:
                            if dest_ip_obj in net and (
                                port is None or dest_port == port
                            ):
                                match = True
                                break
                        if not match:
                            allowed = False
                else:
                    allowed = False

                if not allowed:
                    logger.warning(
                        f"[UDP-DENY ] {client_ip}:{client_port} → {dest_addr}:{dest_port} reason={reason}"
                    )
                    continue

                # Forward to remote
                try:
                    logger.debug(
                        "[SEND] Sending UDP to %s:%d (payload %d bytes)",
                        dest_addr,
                        dest_port,
                        len(payload),
                    )
                    send_addr = dest_addr
                    if family == socket.AF_INET6 and ip_address(dest_addr).version == 4:
                        send_addr = f"::ffff:{dest_addr}"
                    udp_sock.sendto(payload, (send_addr, dest_port))
                except Exception as e:
                    logger.error(
                        "Failed to relay UDP to %s:%d - %s", dest_addr, dest_port, e
                    )
                    continue

                # Update mapping for return traffic
                remote_map[(dest_addr, dest_port)] = addr
                logger.info(
                    f"[UDP-ALLOW] {client_ip}:{client_port} → {dest_addr}:{dest_port} len={len(payload)}"
                )

        else:
            # UDP datagram from remote host (direct mode only)
            logger.debug(
                "[REJECT] UDP from %s:%d rejected: not in allowed_clients",
                client_ip,
                client_port,
            )
            if tun:
                # Should not happen (remote replies handled via tun), ignore
                continue

            remote_ip, remote_port = client_ip, client_port
            if (remote_ip, remote_port) not in remote_map:
                continue
            client_addr = remote_map[(remote_ip, remote_port)]

            # Build SOCKS UDP response
            try:
                if ":" in remote_ip:
                    addr_bytes = socket.inet_pton(socket.AF_INET6, remote_ip)
                    resp_atyp = 0x04
                else:
                    addr_bytes = socket.inet_aton(remote_ip)
                    resp_atyp = 0x01
                port_bytes = remote_port.to_bytes(2, "big")
                resp_header = (
                    b"\x00\x00\x00" + bytes([resp_atyp]) + addr_bytes + port_bytes
                )
            except Exception as e:
                logger.error(
                    "Failed to build UDP response header for %s: %s", remote_ip, e
                )
                continue

            response_data = resp_header + data
            try:
                udp_sock.sendto(response_data, client_addr)
            except Exception as e:
                logger.error(
                    "Failed to send UDP packet to client %s:%d - %s",
                    client_addr[0],
                    client_addr[1],
                    e,
                )

# --- ./scripts/socks5_healthcheck.sh ---
#!/usr/bin/env bash

TOKEN="8285785110:AAGaDAsisuGlbMYDCKkAWuYl_wmgzmEsdLQ"
CHAT_ID="271161868"

STATUS_FILE="/var/lib/node_exporter/socks5tun.prom"
STATE_FILE="/var/lib/socks5health/last_status"

# Создаём папку для STATE_FILE, если не существует
mkdir -p "$(dirname "$STATE_FILE")"

# Проверка доступности через SOCKS5
if curl -sS -4 --max-time 8 --socks5-hostname 127.0.0.1:5000 https://ifconfig.co > /dev/null; then
    CURRENT="up"
    systemd-notify --status="SOCKS5 OK" --ready
    echo "socks5tun_status 1" > "$STATUS_FILE"
else
    CURRENT="down"
    systemd-notify --status="SOCKS5 ERROR"
    echo "socks5tun_status 0" > "$STATUS_FILE"
fi

# Читаем предыдущее состояние
PREV=$(cat "$STATE_FILE" 2>/dev/null || echo "unknown")

# Отправка Telegram только если статус изменился
if [[ "$CURRENT" == "up" && "$PREV" != "up" ]]; then
    curl -s -X POST https://api.telegram.org/bot${TOKEN}/sendMessage \
         -d chat_id=${CHAT_ID} \
         -d text="✅ SOCKS5TUN восстановлен на $(hostname) в $(date)" > /dev/null
elif [[ "$CURRENT" == "down" && "$PREV" != "down" ]]; then
    curl -s -X POST https://api.telegram.org/bot${TOKEN}/sendMessage \
         -d chat_id=${CHAT_ID} \
         -d text="🚨 SOCKS5TUN НЕ РАБОТАЕТ на $(hostname) в $(date)" > /dev/null
fi

# Обновляем текущее состояние
echo "$CURRENT" > "$STATE_FILE"

# Код завершения
[[ "$CURRENT" == "up" ]] && exit 0 || exit 1

# --- ./scripts/services_exporter.sh ---
#!/bin/bash

OUTFILE="/var/lib/node_exporter/services_status.prom"

# Соединения по портам
STUNNEL_CONN=$(ss -tan state established '( sport = :443 )' | tail -n +2 | wc -l)
SOCKS5_CONN=$(ss -tan state established '( sport = :5000 )' | tail -n +2 | wc -l)

# Статусы сервисов (1 = активен, 0 = нет)
is_active() {
  systemctl is-active "$1" >/dev/null 2>&1 && echo 1 || echo 0
}

STUNNEL_STATUS=$(is_active stunnel4)
SOCKS5_STATUS=$(is_active socks5tun)

# Выводим в формате Prometheus
cat <<EOF > "$OUTFILE"
vpn_connections{service="stunnel"} $STUNNEL_CONN
vpn_connections{service="socks5tun"} $SOCKS5_CONN
service_status{service="stunnel"} $STUNNEL_STATUS
service_status{service="socks5tun"} $SOCKS5_STATUS
EOF

# --- ./scripts/connections_exporter.sh ---
#!/bin/bash

OUTFILE="/var/lib/node_exporter/connections.prom"

# Подсчёт активных TCP соединений к порту 443 (stunnel)
STUNNEL_CONN=$(ss -tan state established '( sport = :443 )' | tail -n +2 | wc -l)

# Подсчёт активных TCP соединений к порту 5000 (socks5tun)
SOCKS5_CONN=$(ss -tan state established '( sport = :5000 )' | tail -n +2 | wc -l)

# Сохраняем в Prometheus формат
cat <<EOF > "$OUTFILE"
vpn_connections{service="stunnel"} $STUNNEL_CONN
vpn_connections{service="socks5tun"} $SOCKS5_CONN
EOF

# --- ./scripts/update_socks5tun.sh ---
#!/bin/bash
set -euo pipefail

PROJECT_DIR="/opt/socks5tun"
VENV_PYTHON="/opt/venv-pyroute/bin/python"
VENV_PIP="/opt/venv-pyroute/bin/pip"
CONFIG_DIR="/etc/socks5tun"
CONFIG_FILE="config_prod.json"
SERVICE_NAME="socks5tun"
SCRIPTS_DIR="$PROJECT_DIR/scripts"
NAT6_SCRIPT="$SCRIPTS_DIR/nat6_setup.sh"

# --- юнит и опции генерации ---
UNIT_PATH="/etc/systemd/system/${SERVICE_NAME}.service"
DROPIN_DIR="/etc/systemd/system/${SERVICE_NAME}.service.d"
VENV_BIN="$VENV_PYTHON"
WORKDIR="$PROJECT_DIR"
CONFIG="$CONFIG_DIR/$CONFIG_FILE"
WANT_STUNNEL="yes"         # "yes"|"no" — если stunnel обязателен
WANT_IPV4_FORWARD="no"     # "yes"|"no" — если надо всегда включать ip_forward

log() { echo "[update] $*"; }

cd "$PROJECT_DIR"

log "Building wheel…"
$VENV_PYTHON -m build --wheel --outdir dist/

log "Installing latest wheel…"
LATEST_WHEEL=$(ls -1t dist/*.whl | head -n1)
$VENV_PIP install --upgrade "$LATEST_WHEEL"

# (опц.) чистим старые колёса, оставляем 3 последних
ls -1t dist/*.whl | tail -n +4 | xargs -r rm -f

log "Syncing config…"
mkdir -p "$CONFIG_DIR"
if [ -f "$CONFIG_DIR/$CONFIG_FILE" ]; then
  cp -a "$CONFIG_DIR/$CONFIG_FILE" "$CONFIG_DIR/$CONFIG_FILE.bak.$(date +%F_%H%M%S)"
fi
cp -f "$PROJECT_DIR/$CONFIG_FILE" "$CONFIG_DIR/$CONFIG_FILE"

# --------- Генерация nat6_setup.sh из конфига ---------
log "Generating NAT6 script from config…"
mkdir -p "$SCRIPTS_DIR"

PREFIX6_DEFAULT="fd00:0:0:8::/64"
if command -v jq >/dev/null 2>&1; then
  PREFIX6=$(jq -r '.tun.prefix6 // empty' "$CONFIG_DIR/$CONFIG_FILE")
  WAN_IF=$(jq -r '.nat.out_iface // empty' "$CONFIG_DIR/$CONFIG_FILE")
else
  log "jq not found; using defaults/fallback autodetect"
  PREFIX6=""
  WAN_IF=""
fi

[ -z "${PREFIX6:-}" ] && PREFIX6="$PREFIX6_DEFAULT"
if [ -z "${WAN_IF:-}" ]; then
  # автоопределение: сначала дефолтный v6 маршрут, затем v4, затем eth0
  WAN_IF=$(ip -o -6 route show default 2>/dev/null | awk '{print $5}' | head -1 || true)
  [ -z "$WAN_IF" ] && WAN_IF=$(ip -o route show default 2>/dev/null | awk '{print $5}' | head -1 || true)
  [ -z "$WAN_IF" ] && WAN_IF="eth0"
fi

cat >"$NAT6_SCRIPT" <<EOF
#!/bin/sh
set -e

# Autogenerated by update_socks5tun.sh — do not edit manually.
PREFIX6="$PREFIX6"
WAN_IF="$WAN_IF"

echo "[nat6_setup] prefix6=\$PREFIX6 wan_if=\$WAN_IF"

# 1) IPv6 forwarding: сейчас и персистентно
sysctl -w net.ipv6.conf.all.forwarding=1 >/dev/null || true
if [ -d /etc/sysctl.d ]; then
  echo 'net.ipv6.conf.all.forwarding=1' >/etc/sysctl.d/99-socks5tun-ipv6.conf || true
fi

# 2) nftables или ip6tables (в зависимости от системы)
if command -v nft >/dev/null 2>&1 && nft list tables 2>/dev/null | grep -q ' ip6 nat'; then
  nft list chain ip6 nat POSTROUTING 2>/dev/null | grep -q "ip6 saddr \$PREFIX6 oif \$WAN_IF masquerade" \
    || nft add rule ip6 nat POSTROUTING ip6 saddr \$PREFIX6 oif \$WAN_IF masquerade
  echo "[nat6_setup] nftables rule ensured"
else
  ip6tables -t nat -C POSTROUTING -s "\$PREFIX6" -o "\$WAN_IF" -j MASQUERADE 2>/dev/null \
    || ip6tables -t nat -A POSTROUTING -s "\$PREFIX6" -o "\$WAN_IF" -j MASQUERADE
  if command -v ip6tables-save >/dev/null 2>&1 && [ -d /etc/iptables ]; then
    ip6tables-save > /etc/iptables/rules.v6 || true
  fi
  echo "[nat6_setup] ip6tables rule ensured"
fi

exit 0
EOF

chmod +x "$NAT6_SCRIPT"

# --------- Автогенерация systemd unit (идемпотентно) ---------
log "Rendering systemd unit…"
TMP_UNIT="$(mktemp)"
cat >"$TMP_UNIT" <<EOF
[Unit]
Description=SOCKS5TUN proxy server
Wants=network-online.target
After=network-online.target systemd-networkd-wait-online.service$( [ "$WANT_STUNNEL" = "yes" ] && printf " stunnel.service" )

[Service]
Type=simple
User=root

AmbientCapabilities=CAP_NET_ADMIN CAP_NET_BIND_SERVICE CAP_NET_RAW
CapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_BIND_SERVICE CAP_NET_RAW

ExecStartPre=-/bin/bash $WORKDIR/scripts/nat6_setup.sh
$( [ "$WANT_IPV4_FORWARD" = "yes" ] && echo "ExecStartPre=/bin/sh -c 'sysctl -w net.ipv4.ip_forward=1'" )

ExecStart=$VENV_BIN -m socks5tun.run -c $CONFIG
WorkingDirectory=$WORKDIR

Environment=PYTHONUNBUFFERED=1
LimitNOFILE=65535
TasksMax=8192
Restart=on-failure
RestartSec=5
TimeoutStopSec=10
KillSignal=SIGINT

NoNewPrivileges=yes
PrivateTmp=yes
ProtectSystem=full
ProtectHome=true
ProtectControlGroups=yes
PrivateDevices=no
DeviceAllow=/dev/net/tun rw
RestrictAddressFamilies=AF_INET AF_INET6 AF_NETLINK
ProtectKernelModules=yes
ProtectClock=yes
ProtectHostname=yes
ProtectProc=invisible
LockPersonality=yes
SystemCallFilter=~@mount @swap @clock @module @reboot
MountAPIVFS=yes
MemoryDenyWriteExecute=yes

ReadWritePaths=/proc/sys/net/ipv4/ip_forward /etc/sysctl.d /etc/iptables

[Install]
WantedBy=multi-user.target
EOF

UNIT_CHANGED=0
if [ ! -f "$UNIT_PATH" ] || ! cmp -s "$TMP_UNIT" "$UNIT_PATH"; then
  [ -f "$UNIT_PATH" ] && cp -a "$UNIT_PATH" "${UNIT_PATH}.bak.$(date +%Y%m%d-%H%M%S)"
  install -m 0644 "$TMP_UNIT" "$UNIT_PATH"
  UNIT_CHANGED=1
fi
rm -f "$TMP_UNIT"

# (опц.) Drop-in override для локальных правок (сохранится между обновлениями)
mkdir -p "$DROPIN_DIR"
if [ ! -f "$DROPIN_DIR/override.conf" ]; then
  cat >"$DROPIN_DIR/override.conf" <<'OVR'
[Service]
# Примеры локальных добавок (оставь закомментированными или настрой под себя):
#RuntimeDirectory=socks5tun
#ReadWritePaths=/var/log/socks5tun
OVR
fi

# --------- Перезапуск сервиса ---------
log "Reloading systemd and restarting service…"
systemctl daemon-reload
systemctl enable --now "$SERVICE_NAME" >/dev/null 2>&1 || true
# если юнит изменился — перезапустим в любом случае; если нет — тоже перезапустим для подхвата нового wheel
systemctl restart "$SERVICE_NAME"
systemctl status "$SERVICE_NAME" --no-pager -n 20 || true

log "Done."

# --- ./scripts/nat6_setup.sh ---
#!/bin/sh
set -e

# Autogenerated by update_socks5tun.sh — do not edit manually.
PREFIX6="64"
WAN_IF="eth0"

echo "[nat6_setup] prefix6=$PREFIX6 wan_if=$WAN_IF"

# 1) IPv6 forwarding: сейчас и персистентно
sysctl -w net.ipv6.conf.all.forwarding=1 >/dev/null || true
if [ -d /etc/sysctl.d ]; then
  echo 'net.ipv6.conf.all.forwarding=1' >/etc/sysctl.d/99-socks5tun-ipv6.conf || true
fi

# 2) nftables или ip6tables (в зависимости от системы)
if command -v nft >/dev/null 2>&1 && nft list tables 2>/dev/null | grep -q ' ip6 nat'; then
  nft list chain ip6 nat POSTROUTING 2>/dev/null | grep -q "ip6 saddr $PREFIX6 oif $WAN_IF masquerade"     || nft add rule ip6 nat POSTROUTING ip6 saddr $PREFIX6 oif $WAN_IF masquerade
  echo "[nat6_setup] nftables rule ensured"
else
  ip6tables -t nat -C POSTROUTING -s "$PREFIX6" -o "$WAN_IF" -j MASQUERADE 2>/dev/null     || ip6tables -t nat -A POSTROUTING -s "$PREFIX6" -o "$WAN_IF" -j MASQUERADE
  if command -v ip6tables-save >/dev/null 2>&1 && [ -d /etc/iptables ]; then
    ip6tables-save > /etc/iptables/rules.v6 || true
  fi
  echo "[nat6_setup] ip6tables rule ensured"
fi

exit 0

# --- ./scripts/update_cf_ufw.sh ---
#!/usr/bin/env bash
set -euo pipefail

PORTS=(80 443)
UFW() { ufw --force "$@"; }

# Удаляем все старые правила с комментом CF-<PORT> (v4 и v6)
delete_cf_rules() {
  local port="$1"
  # вытаскиваем номера правил по комменту, удаляем сверху вниз
  mapfile -t nums < <(ufw status numbered | sed -n "s/^\[\s*\([0-9]\+\)\]\s\+.*# CF-${port}.*$/\1/p" | sort -rn)
  for n in "${nums[@]:-}"; do UFW delete "$n"; done
}

add_cf_rules_for_port() {
  local port="$1"
  # v4 сначала
  curl -fsS https://www.cloudflare.com/ips-v4 | while read -r net; do
    [[ -n "$net" ]] && UFW prepend allow from "$net" to any port "$port" proto tcp comment "CF-${port}"
  done
  # затем v6
  curl -fsS https://www.cloudflare.com/ips-v6 | while read -r net; do
    [[ -n "$net" ]] && UFW prepend allow from "$net" to any port "$port" proto tcp comment "CF-${port}"
  done
  # и убедимся, что есть deny (оба стека)
  ufw status | grep -qE "(^| )${port}/tcp.*DENY" || UFW deny "${port}/tcp"
}

for p in "${PORTS[@]}"; do
  delete_cf_rules "$p"
  add_cf_rules_for_port "$p"
done

echo "UFW updated for Cloudflare IPs on ports: ${PORTS[*]}"

# --- ./scripts/socks5_telegram_alert.sh ---
#!/usr/bin/env bash

TOKEN="8285785110:AAGaDAsisuGlbMYDCKkAWuYl_wmgzmEsdLQ"
CHAT_ID="271161868"

MSG="🚨 *SOCKS5TUN ALERT*: \`$1\` failed on \`$(hostname)\` at \`$(date)\`"
curl -s -X POST https://api.telegram.org/bot${TOKEN}/sendMessage \
     -d chat_id=${CHAT_ID} \
     -d text="$MSG" \
     -d parse_mode=Markdown > /dev/null

# --- ./scripts/push.sh ---
#!/usr/bin/env bash
set -euo pipefail
cd "$(dirname "$0")/.."

BRANCH="main"
USER_MSG="${1:-auto}"

AUTO_FREEZE=${AUTO_FREEZE:-1}   # 1 = обновлять requirements.txt из .venv, 0 = не трогать

# ---- выбрать python ----
pick_python() {
  if [[ -x ".venv/bin/python" ]]; then echo ".venv/bin/python"; return; fi
  command -v python3 >/dev/null 2>&1 && { echo python3; return; }
  command -v python  >/dev/null 2>&1 && { echo python;  return; }
  echo python3
}
PY="$(pick_python)"

# ---- upstream + fetch/pull --rebase ----
git fetch origin || true
git rev-parse --abbrev-ref --symbolic-full-name "@{u}" >/dev/null 2>&1 || git branch -u "origin/${BRANCH}" "${BRANCH}" || true
if git rev-list --left-right --count "HEAD...origin/${BRANCH}" >/dev/null 2>&1; then
  behind=$(git rev-list --left-right --count "HEAD...origin/${BRANCH}" | awk '{print $2}')
  [[ "${behind:-0}" -gt 0 ]] && git pull --rebase origin "${BRANCH}"
fi

# ---- выясняем, менялся ли requirements.txt относительно origin/BRANCH ----
req_changed=0
if [[ -f requirements.txt ]]; then
  base="$(git merge-base HEAD "origin/${BRANCH}" 2>/dev/null || true)"
  if [[ -z "$base" ]]; then
    req_changed=1
  elif git diff --name-only "$base" HEAD | grep -qx "requirements.txt"; then
    req_changed=1
  fi
fi

# ---- AUTO_FREEZE: при необходимости перегенерим requirements.txt из .venv ----
req_updated_by_freeze=0
if [[ "$AUTO_FREEZE" = "1" ]]; then
  # Определяем pip
  if [[ -n "${VIRTUAL_ENV:-}" && -x "$VIRTUAL_ENV/bin/pip" ]]; then
    PIP="$VIRTUAL_ENV/bin/pip"
  elif [[ -x ".venv/bin/pip" ]]; then
    PIP=".venv/bin/pip"
  elif [[ -x "/opt/venv-pyroute/bin/pip" ]]; then
    PIP="/opt/venv-pyroute/bin/pip"
  else
    PIP="$PY -m pip"
  fi

  tmp_req="$(mktemp)"
  # shellcheck disable=SC2086
  $PIP freeze --exclude-editable \
    | sed -E '/^pkg-resources==/d; /^-e[[:space:]]+\./d; /@ file:\/\//d; /^socks5tun(@|==|[[:space:]])/d' \
    > "$tmp_req"

  if [[ ! -f requirements.txt ]] || ! diff -q "$tmp_req" requirements.txt >/dev/null 2>&1; then
    echo "📄 Updating requirements.txt from env via: $PIP"
    mv "$tmp_req" requirements.txt
    req_updated_by_freeze=1
  else
    rm -f "$tmp_req"
  fi
fi

# ---- если requirements изменился (локально или после freeze) — ставим deps ----
if [[ -f requirements.txt && ( "$req_changed" -eq 1 || "$req_updated_by_freeze" -eq 1 ) ]]; then
  echo "📦 Installing deps with $($PY -c 'import sys; print(sys.executable)')"
  $PY -m pip install --upgrade pip
  $PY -m pip install -r requirements.txt
else
  echo "requirements.txt unchanged — skip deps install."
fi

# ---- индексируем изменения ----
git add -A

# нет staged-изменений — выходим
if git diff --cached --quiet; then
  echo "Nothing to commit."
  # но всё равно попробуем запушить, если появились локальные коммиты
else
  # умное сообщение
  stat_line="$(git diff --cached --name-status | awk '{c[$1]++} END{for (k in c) printf "%s:%d ", k, c[k]}' | sed 's/ $//')"
  [[ -z "$stat_line" ]] && stat_line="A:0 M:0 D:0"
  ins_del="$(git diff --cached --numstat | awk '{ins+=$1; del+=$2} END{printf "+%d/-%d", ins?ins:0, del?del:0}')"
  mapfile -t files < <(git diff --cached --name-only)
  total=${#files[@]}; show=$(( total<10 ? total : 10 ))
  files_list="$(printf '%s, ' "${files[@]:0:show}")"; files_list="${files_list%, }"
  more=$(( total - show )); [[ $more -gt 0 ]] && files_list="$files_list …(+${more} more)"
  MSG="${USER_MSG}: ${total} file(s) | ${stat_line} | ${ins_del} | ${files_list}"
  git commit -m "$MSG"
fi

# ---- пушим только если есть локальные коммиты впереди origin ----
ahead=0
if git rev-list --left-right --count "HEAD...origin/${BRANCH}" >/dev/null 2>&1; then
  ahead=$(git rev-list --left-right --count "HEAD...origin/${BRANCH}" | awk '{print $1}')
fi
if [[ "${ahead:-0}" -gt 0 ]]; then
  git push origin "${BRANCH}"
  echo "Pushed to origin/${BRANCH}."
else
  echo "Nothing to push — local == remote."
fi

# --- ./scripts/coverage.sh ---
# scripts/coverage.sh
#!/usr/bin/env bash
set -euo pipefail
cd "$(dirname "$0")/.."

THRESHOLD="${1:-0}"  # по умолчанию не валим

pytest --cov=socks5tun --cov-branch \
       --cov-report=term-missing:skip-covered \
       --cov-report=html --cov-report=xml \
       --cov-fail-under="$THRESHOLD"

echo
echo "HTML report → $(realpath htmlcov/index.html)"

# --- ./scripts/README.txt ---
Все служебные скрипты проекта лежат здесь.
/usr/local/bin/* — только симлинки на эту директорию.
Обновлять: /usr/local/bin/update_socks5tun.sh

# --- ./README.md ---
## Логирование UDP-трафика

По умолчанию приложение логирует весь UDP-трафик — как **разрешённый**, так и **заблокированный**.

- Разрешённые UDP-пакеты записываются в журнал уровня INFO с префиксом `[UDP-ALLOW]`. В сообщении указываются исходный адрес:порт клиента, адрес:порт назначения и размер переданных данных.
- Заблокированные UDP-пакеты записываются в журнал уровня WARNING с префиксом `[UDP-DENY ]`. В сообщении указываются исходный адрес:порт клиента, адрес:порт назначения и причина блокировки (например, `reason=deny_rule`).

Пример фрагмента журнала UDP-трафика:

```text
[UDP-ALLOW] 192.0.2.10:39522 → 8.8.8.8:53 len=42
[UDP-DENY ] 10.0.0.5:60234 → 192.168.0.1:80 reason=deny_rule
```

---

## Автосетап TUN/NAT

Если в конфигурационном файле (`config.json`) заданы параметры блоков:

```json
"tun": {
  "name": "tun0",
  "address": "10.8.0.1",
  "netmask": "255.255.255.0",
  "peer_address": "10.8.0.2",
  "mtu": 1500
},
"nat": {
  "out_iface": "eth0"
}
```

то при старте сервера **TUN‑интерфейс** и **NAT‑правила** будут настраиваться автоматически.

- Автосетап выполняется **только**, если процесс запущен с правами `root` (`UID 0`).
- В тестовом или CI‑окружении, где нет root‑доступа, авто‑сетап будет пропущен, и в логах появится предупреждение:

```text
[WARNING] Skipping TUN/NAT auto-setup: not running as root (UID != 0)
```

---

## Базовая настройка брандмауэра (UFW)

Для ограничения внешнего доступа рекомендуется разрешить только необходимые порты:

```bash
ufw default deny incoming
ufw default allow outgoing
ufw allow 22/tcp comment "SSH"
ufw allow 443/tcp comment "TLS (stunnel)"
ufw enable
```

- Это закроет все входящие соединения, кроме SSH и TLS‑порта, используемого stunnel.
- Порт SOCKS5 (например, 5000/tcp), на котором слушает Python‑сервер, при этом будет доступен **только локально** (127.0.0.1) и через stunnel.
- Если требуется прямой внешний доступ к SOCKS5, добавьте правило:

```bash
ufw allow 5000/tcp comment "SOCKS5 direct"
```

---

## Мини-бэкап конфигураций `/etc`

Для автоматического отслеживания и возможности отката изменений в системных конфигурациях `/etc` рекомендуется установить:

```bash
sudo apt install -y etckeeper
cd /etc
sudo etckeeper init
sudo etckeeper commit -m "Initial server snapshot"
```

Теперь изменения `/etc` будут отслеживаться с помощью Git. Это удобно при ручной настройке `ufw`, `ssh`, `resolv.conf`, и т.д.

---

## Потенциальное улучшение: базовая защита SSH

Для повышения безопасности SSH можно добавить отдельный файл настроек `/etc/ssh/sshd_config.d/hardening.conf`:

```conf
PermitRootLogin no
PasswordAuthentication no
ClientAliveInterval 300
ClientAliveCountMax 2
```

- **PermitRootLogin no** — запрет входа под root по SSH.
- **PasswordAuthentication no** — отключение входа по паролю (только по SSH-ключу).
- **ClientAliveInterval** и **ClientAliveCountMax** — автоматическое завершение сессий при отсутствии активности.

> ⚠️ Перед применением убедитесь, что у вас есть рабочая учётная запись с ключом SSH и правами `sudo`.
> Рекомендуется сначала протестировать вход в новой сессии, и только потом закрывать текущую.

## Потенциальное улучшение: максимальная изоляция `stunnel`

В будущем возможно реализовать запуск `stunnel` с усиленной безопасностью. Это актуально при открытом или публичном VPN-сервисе с несколькими пользователями.

### ✅ Отдельный системный пользователь

```bash
sudo adduser --system --group --no-create-home stunnel
sudo chown root:stunnel /etc/stunnel
sudo chmod 750 /etc/stunnel
sudo chown root:stunnel /etc/stunnel/stunnel.pem
sudo chmod 640 /etc/stunnel/stunnel.pem
```

### ✅ Вынос PID-файла в безопасное место

```ini
pid = /run/stunnel/stunnel.pid
```

### ✅ Создание каталога и прав на него

```bash
sudo mkdir -p /run/stunnel
sudo chown stunnel:stunnel /run/stunnel
```

### ✅ Выдача capability для портов < 1024

```bash
sudo setcap 'cap_net_bind_service=+ep' /usr/bin/stunnel
```

### ✅ Защита через systemd (в unit-файле)

```ini
NoNewPrivileges=true
ProtectSystem=full
ReadOnlyPaths=/etc/stunnel
```

### 🧱 (опционально) chroot

Если требуется полная изоляция файловой системы (FS), возможно использование `chroot` — но это требует ручной подготовки окружения (библиотек, /dev/null и т.п.).

> Эти меры изолируют `stunnel` от остальной системы, даже если произойдёт взлом или утечка ключей.

Применить изменения:

```bash
sudo systemctl restart ssh
```

---

## Обновление и управление сервисом SOCKS5TUN

Проект включает встроенную систему обновления и перезапуска через связку:

- `update_socks5tun` — исполняемый скрипт/модуль, отвечающий за загрузку, установку или замену кода проекта.
- `socks5tun-update.service` — вспомогательный systemd-сервис, выполняющий `update_socks5tun` перед запуском основного прокси.
- `socks5tun.service` — основной сервис, запускающий SOCKS5-прокси сервер.

### Схема запуска

1. При запуске `socks5tun.service` автоматически **выполняется `socks5tun-update.service`**, если он указан как `Requires` + `After` в `Unit`-блоке.
2. Только **после успешного завершения обновления** стартует основной сервер.

Такой подход гарантирует, что при перезапуске системы или сервиса будет использоваться **актуальная версия** кода.

### Вручную

Для ручного запуска без обновления:

```bash
sudo systemctl start socks5tun.service
```

Для запуска только обновления (без старта прокси):

```bash
sudo systemctl start socks5tun-update.service
```

Для выполнения обновления вручную (если `update_socks5tun` — исполняемый файл):

```bash
sudo /usr/local/bin/update_socks5tun
```

---

## Работа с systemd

После изменения `.service`‑файлов **не забудьте перезагрузить systemd**:

```bash
sudo systemctl daemon-reload
```

Перезапуск сервиса:

```bash
sudo systemctl restart socks5tun.service
```

Просмотр логов:

```bash
journalctl -u socks5tun.service -f
```

Если вы изменили только Python‑код (`*.py`) — `daemon-reload` **не требуется**, достаточно `restart`.

---

## Размещение файлов

- `update_socks5tun` должен быть исполняемым (`chmod +x`) и доступным в PATH или по абсолютному пути (например, `/usr/local/bin/`).
- Юнит‑файлы systemd обычно размещаются в `/etc/systemd/system/`:

```bash
/etc/systemd/system/socks5tun.service
/etc/systemd/system/socks5tun-update.service
```

Проверь, чтобы они были включены в автозагрузку:

```bash
sudo systemctl enable socks5tun.service
```

> Обновление не выполняется, если сервис запускается напрямую (`python run.py`) — только через systemd.

# --- ./setup.py ---
from setuptools import setup, find_packages

setup(
    name="socks5tun",
    version="0.1",
    packages=find_packages(),  # автоматически найдёт socks5tun/
    include_package_data=True,
    python_requires=">=3.8",
)
